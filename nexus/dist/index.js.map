{"version":3,"file":"index.js","sources":["../webpack://nexus/./lib/config.js","../webpack://nexus/./lib/generate.js","../webpack://nexus/./lib/main.js","../webpack://nexus/../node_modules/@actions/core/lib/command.js","../webpack://nexus/../node_modules/@actions/core/lib/core.js","../webpack://nexus/../node_modules/@actions/core/lib/file-command.js","../webpack://nexus/../node_modules/@actions/core/lib/utils.js","../webpack://nexus/../node_modules/@actions/io/lib/io-util.js","../webpack://nexus/../node_modules/@actions/io/lib/io.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/AbortAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/AttrAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/BoundaryPointAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/CharacterDataAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/CreateAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/CustomElementAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/DOMAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/DOMTokenListAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/DocumentAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/ElementAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/EventAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/EventTargetAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/MutationAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/MutationObserverAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/NamespaceAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/NodeAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/NodeIteratorAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/OrderedSetAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/ParentNodeAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/RangeAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/SelectorsAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/ShadowTreeAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/TextAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/TraversalAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/TreeAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/TreeWalkerAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/WebIDLAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/XMLAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/algorithm/index.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/AbortControllerImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/AbortSignalImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/AbstractRangeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/AttrImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/CDATASectionImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/CharacterDataImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/ChildNodeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/CommentImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/CustomEventImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DOMException.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DOMImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DOMImplementationImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DOMTokenListImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DocumentFragmentImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DocumentImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DocumentOrShadowRootImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/DocumentTypeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/ElementImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/EventImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/EventTargetImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/HTMLCollectionImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/MutationObserverImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/MutationRecordImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NamedNodeMapImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NodeFilterImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NodeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NodeIteratorImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NodeListImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NodeListStaticImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NonDocumentTypeChildNodeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/NonElementParentNodeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/ParentNodeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/ProcessingInstructionImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/RangeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/ShadowRootImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/SlotableImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/StaticRangeImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/TextImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/TraverserImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/TreeWalkerImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/WindowImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/XMLDocumentImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/index.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/dom/interfaces.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/index.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/parser/DOMParserImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/parser/XMLParserImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/parser/XMLStringLexer.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/parser/index.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/parser/interfaces.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/serializer/LocalNameSet.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/serializer/NamespacePrefixMap.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/serializer/XMLSerializerImpl.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/serializer/index.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/util/Cast.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/util/EmptySet.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/util/Guard.js","../webpack://nexus/../node_modules/@oozcitak/dom/lib/util/index.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Base64.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Byte.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/ByteSequence.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/CodePoints.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/JSON.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/List.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Map.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Namespace.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Queue.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Set.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/Stack.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/String.js","../webpack://nexus/../node_modules/@oozcitak/infra/lib/index.js","../webpack://nexus/../node_modules/@oozcitak/url/lib/URLAlgorithm.js","../webpack://nexus/../node_modules/@oozcitak/url/lib/interfaces.js","../webpack://nexus/../node_modules/@oozcitak/util/lib/CompareCache.js","../webpack://nexus/../node_modules/@oozcitak/util/lib/FixedSizeSet.js","../webpack://nexus/../node_modules/@oozcitak/util/lib/Lazy.js","../webpack://nexus/../node_modules/@oozcitak/util/lib/ObjectCache.js","../webpack://nexus/../node_modules/@oozcitak/util/lib/StringWalker.js","../webpack://nexus/../node_modules/@oozcitak/util/lib/index.js","../webpack://nexus/../node_modules/ts-dedent/dist/index.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/builder/BuilderFunctions.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/builder/BuilderFunctionsCB.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/builder/XMLBuilderCBImpl.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/builder/XMLBuilderImpl.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/builder/dom.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/builder/index.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/index.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/interfaces.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/readers/BaseReader.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/readers/JSONReader.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/readers/ObjectReader.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/readers/XMLReader.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/readers/YAMLReader.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/readers/index.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/BaseCBWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/BaseWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/JSONCBWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/JSONWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/MapWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/ObjectWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/XMLCBWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/XMLWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/YAMLCBWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/YAMLWriter.js","../webpack://nexus/../node_modules/xmlbuilder2/lib/writers/index.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/index.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/common.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/dumper.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/exception.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/loader.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/mark.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/schema.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/schema/core.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/schema/default_full.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/schema/json.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/binary.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/bool.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/float.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/int.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/js/function.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/map.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/merge.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/null.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/omap.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/pairs.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/seq.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/set.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/str.js","../webpack://nexus/../node_modules/xmlbuilder2/node_modules/js-yaml/lib/js-yaml/type/timestamp.js","../webpack://nexus/../node_modules/yaml/dist/Document-9b4560a1.js","../webpack://nexus/../node_modules/yaml/dist/PlainValue-ec8e588e.js","../webpack://nexus/../node_modules/yaml/dist/Schema-88e323a7.js","../webpack://nexus/../node_modules/yaml/dist/index.js","../webpack://nexus/../node_modules/yaml/dist/parse-cst.js","../webpack://nexus/../node_modules/yaml/dist/resolveSeq-d03cb037.js","../webpack://nexus/../node_modules/yaml/dist/warnings-1000a372.js","../webpack://nexus/../node_modules/yaml/index.js","../webpack://nexus/external \"assert\"","../webpack://nexus/external \"child_process\"","../webpack://nexus/external \"events\"","../webpack://nexus/external \"fs\"","../webpack://nexus/external \"os\"","../webpack://nexus/external \"path\"","../webpack://nexus/external \"url\"","../webpack://nexus/external \"util\"","../webpack://nexus/webpack/bootstrap","../webpack://nexus/webpack/runtime/compat","../webpack://nexus/webpack/startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.DEFAULT_POLICIES = exports.DEFAULT_AUTH = void 0;\nconst yaml = __importStar(require(\"yaml\"));\nexports.DEFAULT_AUTH = {\n    default: {\n        username: 'NEXUS_USERNAME',\n        password: 'NEXUS_PASSWORD'\n    }\n};\nexports.DEFAULT_POLICIES = {\n    releases: {\n        enabled: true,\n        checksumPolicy: 'fail',\n        updatePolicy: 'daily'\n    },\n    snapshots: {\n        enabled: false,\n        checksumPolicy: 'fail',\n        updatePolicy: 'always'\n    }\n};\nfunction setDefaultPolicies(repos, configPolicies) {\n    const defaults = {\n        releases: Object.assign(Object.assign({}, exports.DEFAULT_POLICIES.releases), configPolicies === null || configPolicies === void 0 ? void 0 : configPolicies.releases),\n        snapshots: Object.assign(Object.assign({}, exports.DEFAULT_POLICIES.snapshots), configPolicies === null || configPolicies === void 0 ? void 0 : configPolicies.snapshots)\n    };\n    for (const r of Object.values(repos)) {\n        r.releases = Object.assign(Object.assign({}, defaults.releases), (r.releases || {}));\n        r.snapshots = Object.assign(Object.assign({}, defaults.snapshots), (r.snapshots || {}));\n    }\n}\nfunction parse(content, repoUrl) {\n    const parsed = yaml.parse(content) || {};\n    const baseUrl = repoUrl || parsed['url'];\n    if (!baseUrl) {\n        throw Error('Nexus base url should be specified via nexus.yml#url or base-url input');\n    }\n    const repos = parsed['repos'] || [];\n    const pluginRepos = parsed['plugin-repos'] || [];\n    setDefaultPolicies(repos, parsed['default-policies']);\n    setDefaultPolicies(pluginRepos, parsed['default-policies']);\n    const auth = parsed['auth'] || exports.DEFAULT_AUTH;\n    for (const a of Object.values(auth)) {\n        a.username = a.username || auth.default.username;\n        a.password = a.password || auth.default.password;\n    }\n    for (const [id, r] of Object.entries(repos)) {\n        if (r.auth && !auth[id]) {\n            auth[id] = auth.default;\n        }\n    }\n    return { baseUrl, auth, repos, pluginRepos };\n}\nexports.parse = parse;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generate = void 0;\nconst xmlbuilder2_1 = require(\"xmlbuilder2\");\nfunction generateRepoPolicy(policy) {\n    if (policy && typeof policy.updatePolicy === 'number') {\n        return Object.assign({ updatePolicy: `interval:${policy.updatePolicy}` }, policy);\n    }\n    else {\n        return policy;\n    }\n}\nfunction generateRepo(baseUrl, id, repo) {\n    return {\n        id,\n        url: `${baseUrl}/repository/${repo.repo}`,\n        releases: generateRepoPolicy(repo.releases),\n        snapshots: generateRepoPolicy(repo.snapshots)\n    };\n}\nfunction generate(config) {\n    const repos = Object.entries(config.repos).map(([id, repo]) => generateRepo(config.baseUrl, id, repo));\n    const pluginRepos = Object.entries(config.pluginRepos).map(([id, repo]) => generateRepo(config.baseUrl, id, repo));\n    const servers = Object.entries(config.auth)\n        .filter(([id]) => id !== 'default')\n        .map(([id, cred]) => {\n        return {\n            id,\n            username: `\\${env.${cred.username}}`,\n            password: `\\${env.${cred.password}}`\n        };\n    });\n    const xmlObj = {\n        settings: {\n            '@xmlns': 'http://maven.apache.org/SETTINGS/1.0.0',\n            '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n            '@xsi:schemaLocation': 'http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd',\n            activeProfiles: {\n                activeProfile: ['nexus']\n            },\n            profiles: {\n                profile: [\n                    {\n                        id: 'nexus',\n                        properties: {\n                            'nexus.url': config.baseUrl\n                        },\n                        repositories: {\n                            repository: repos\n                        },\n                        pluginRepositories: {\n                            pluginRepository: pluginRepos\n                        }\n                    }\n                ]\n            },\n            servers: {\n                server: servers\n            }\n        }\n    };\n    return xmlbuilder2_1.create(xmlObj).end({ headless: true, prettyPrint: true, width: 80 });\n}\nexports.generate = generate;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst core = __importStar(require(\"@actions/core\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst ts_dedent_1 = require(\"ts-dedent\");\nconst generate_1 = require(\"./generate\");\nconst config_1 = require(\"./config\");\nconst M2_DIR = '.m2';\nconst SETTINGS_FILE = 'settings.xml';\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const url = core.getInput('url');\n            const settingsPath = core.getInput('settings-path');\n            const config = yield parseConfig(url);\n            core.info(ts_dedent_1.dedent `\n      creating ${SETTINGS_FILE}\n      base url: ${config.baseUrl}\n      repos: ${JSON.stringify(config.repos, null, 2)}\n      plugin-repos: ${JSON.stringify(config.pluginRepos, null, 2)}\n      auth env vars: ${JSON.stringify(config.auth, null, 2)}\n    `);\n            // when an alternate m2 location is specified use only that location (no .m2 directory)\n            // otherwise use the home/.m2/ path\n            const settingsDir = path.join(settingsPath || os.homedir(), settingsPath ? '' : M2_DIR);\n            yield io.mkdirP(settingsDir);\n            yield write(settingsDir, generate_1.generate(config));\n        }\n        catch (error) {\n            core.setFailed(error.message);\n        }\n    });\n}\nfunction parseConfig(baseUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ws = process.env['GITHUB_WORKSPACE'] || '.';\n        const location = path.join(ws, '.github', 'nexus.yml');\n        if (fs.existsSync(location)) {\n            core.info(`using existing nexus config from ${location}`);\n            const content = yield fs.promises.readFile(location, {\n                encoding: 'utf-8',\n                flag: 'r'\n            });\n            return config_1.parse(content, baseUrl);\n        }\n        else {\n            throw Error(`Nexus configuration not found at ${location}`);\n        }\n    });\n}\nfunction write(directory, settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const location = path.join(directory, SETTINGS_FILE);\n        if (fs.existsSync(location)) {\n            core.warning(`overwriting existing file ${location}`);\n        }\n        else {\n            core.info(`writing ${location}`);\n        }\n        return fs.writeFileSync(location, settings, {\n            encoding: 'utf-8',\n            flag: 'w'\n        });\n    });\n}\nmain();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rename = exports.readlink = exports.readdir = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\n_a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;\nexports.IS_WINDOWS = process.platform === 'win32';\nfunction exists(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exports.stat(fsPath);\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return false;\n            }\n            throw err;\n        }\n        return true;\n    });\n}\nexports.exists = exists;\nfunction isDirectory(fsPath, useStat = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);\n        return stats.isDirectory();\n    });\n}\nexports.isDirectory = isDirectory;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction isRooted(p) {\n    p = normalizeSeparators(p);\n    if (!p) {\n        throw new Error('isRooted() parameter \"p\" cannot be empty');\n    }\n    if (exports.IS_WINDOWS) {\n        return (p.startsWith('\\\\') || /^[A-Z]:/i.test(p) // e.g. \\ or \\hello or \\\\hello\n        ); // e.g. C: or C:\\hello\n    }\n    return p.startsWith('/');\n}\nexports.isRooted = isRooted;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction tryGetExecutablePath(filePath, extensions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let stats = undefined;\n        try {\n            // test file exists\n            stats = yield exports.stat(filePath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                // eslint-disable-next-line no-console\n                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n            }\n        }\n        if (stats && stats.isFile()) {\n            if (exports.IS_WINDOWS) {\n                // on Windows, test for valid extension\n                const upperExt = path.extname(filePath).toUpperCase();\n                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {\n                    return filePath;\n                }\n            }\n            else {\n                if (isUnixExecutable(stats)) {\n                    return filePath;\n                }\n            }\n        }\n        // try each extension\n        const originalFilePath = filePath;\n        for (const extension of extensions) {\n            filePath = originalFilePath + extension;\n            stats = undefined;\n            try {\n                stats = yield exports.stat(filePath);\n            }\n            catch (err) {\n                if (err.code !== 'ENOENT') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n                }\n            }\n            if (stats && stats.isFile()) {\n                if (exports.IS_WINDOWS) {\n                    // preserve the case of the actual file (since an extension was appended)\n                    try {\n                        const directory = path.dirname(filePath);\n                        const upperName = path.basename(filePath).toUpperCase();\n                        for (const actualName of yield exports.readdir(directory)) {\n                            if (upperName === actualName.toUpperCase()) {\n                                filePath = path.join(directory, actualName);\n                                break;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);\n                    }\n                    return filePath;\n                }\n                else {\n                    if (isUnixExecutable(stats)) {\n                        return filePath;\n                    }\n                }\n            }\n        }\n        return '';\n    });\n}\nexports.tryGetExecutablePath = tryGetExecutablePath;\nfunction normalizeSeparators(p) {\n    p = p || '';\n    if (exports.IS_WINDOWS) {\n        // convert slashes on Windows\n        p = p.replace(/\\//g, '\\\\');\n        // remove redundant slashes\n        return p.replace(/\\\\\\\\+/g, '\\\\');\n    }\n    // remove redundant slashes\n    return p.replace(/\\/\\/+/g, '/');\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n    return ((stats.mode & 1) > 0 ||\n        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||\n        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));\n}\n// Get the path of cmd.exe in windows\nfunction getCmdPath() {\n    var _a;\n    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;\n}\nexports.getCmdPath = getCmdPath;\n//# sourceMappingURL=io-util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;\nconst assert_1 = require(\"assert\");\nconst childProcess = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst util_1 = require(\"util\");\nconst ioUtil = __importStar(require(\"./io-util\"));\nconst exec = util_1.promisify(childProcess.exec);\nconst execFile = util_1.promisify(childProcess.execFile);\n/**\n * Copies a file or folder.\n * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See CopyOptions.\n */\nfunction cp(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { force, recursive, copySourceDirectory } = readCopyOptions(options);\n        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;\n        // Dest is an existing file, but not forcing\n        if (destStat && destStat.isFile() && !force) {\n            return;\n        }\n        // If dest is an existing directory, should copy inside.\n        const newDest = destStat && destStat.isDirectory() && copySourceDirectory\n            ? path.join(dest, path.basename(source))\n            : dest;\n        if (!(yield ioUtil.exists(source))) {\n            throw new Error(`no such file or directory: ${source}`);\n        }\n        const sourceStat = yield ioUtil.stat(source);\n        if (sourceStat.isDirectory()) {\n            if (!recursive) {\n                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);\n            }\n            else {\n                yield cpDirRecursive(source, newDest, 0, force);\n            }\n        }\n        else {\n            if (path.relative(source, newDest) === '') {\n                // a file cannot be copied to itself\n                throw new Error(`'${newDest}' and '${source}' are the same file`);\n            }\n            yield copyFile(source, newDest, force);\n        }\n    });\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See MoveOptions.\n */\nfunction mv(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (yield ioUtil.exists(dest)) {\n            let destExists = true;\n            if (yield ioUtil.isDirectory(dest)) {\n                // If dest is directory copy src into dest\n                dest = path.join(dest, path.basename(source));\n                destExists = yield ioUtil.exists(dest);\n            }\n            if (destExists) {\n                if (options.force == null || options.force) {\n                    yield rmRF(dest);\n                }\n                else {\n                    throw new Error('Destination already exists');\n                }\n            }\n        }\n        yield mkdirP(path.dirname(dest));\n        yield ioUtil.rename(source, dest);\n    });\n}\nexports.mv = mv;\n/**\n * Remove a path recursively with force\n *\n * @param inputPath path to remove\n */\nfunction rmRF(inputPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (ioUtil.IS_WINDOWS) {\n            // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another\n            // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.\n            // Check for invalid characters\n            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n            if (/[*\"<>|]/.test(inputPath)) {\n                throw new Error('File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows');\n            }\n            try {\n                const cmdPath = ioUtil.getCmdPath();\n                if (yield ioUtil.isDirectory(inputPath, true)) {\n                    yield exec(`${cmdPath} /s /c \"rd /s /q \"%inputPath%\"\"`, {\n                        env: { inputPath }\n                    });\n                }\n                else {\n                    yield exec(`${cmdPath} /s /c \"del /f /a \"%inputPath%\"\"`, {\n                        env: { inputPath }\n                    });\n                }\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n            // Shelling out fails to remove a symlink folder with missing source, this unlink catches that\n            try {\n                yield ioUtil.unlink(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n        }\n        else {\n            let isDir = false;\n            try {\n                isDir = yield ioUtil.isDirectory(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n                return;\n            }\n            if (isDir) {\n                yield execFile(`rm`, [`-rf`, `${inputPath}`]);\n            }\n            else {\n                yield ioUtil.unlink(inputPath);\n            }\n        }\n    });\n}\nexports.rmRF = rmRF;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param   fsPath        path to create\n * @returns Promise<void>\n */\nfunction mkdirP(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(fsPath, 'a path argument must be provided');\n        yield ioUtil.mkdir(fsPath, { recursive: true });\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool              name of the tool\n * @param     check             whether to check if tool exists\n * @returns   Promise<string>   path to tool\n */\nfunction which(tool, check) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // recursive when check=true\n        if (check) {\n            const result = yield which(tool, false);\n            if (!result) {\n                if (ioUtil.IS_WINDOWS) {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);\n                }\n                else {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);\n                }\n            }\n            return result;\n        }\n        const matches = yield findInPath(tool);\n        if (matches && matches.length > 0) {\n            return matches[0];\n        }\n        return '';\n    });\n}\nexports.which = which;\n/**\n * Returns a list of all occurrences of the given tool on the system path.\n *\n * @returns   Promise<string[]>  the paths of the tool\n */\nfunction findInPath(tool) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // build the list of extensions to try\n        const extensions = [];\n        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {\n            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {\n                if (extension) {\n                    extensions.push(extension);\n                }\n            }\n        }\n        // if it's rooted, return it if exists. otherwise return empty.\n        if (ioUtil.isRooted(tool)) {\n            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);\n            if (filePath) {\n                return [filePath];\n            }\n            return [];\n        }\n        // if any path separators, return empty\n        if (tool.includes(path.sep)) {\n            return [];\n        }\n        // build the list of directories\n        //\n        // Note, technically \"where\" checks the current directory on Windows. From a toolkit perspective,\n        // it feels like we should not do this. Checking the current directory seems like more of a use\n        // case of a shell, and the which() function exposed by the toolkit should strive for consistency\n        // across platforms.\n        const directories = [];\n        if (process.env.PATH) {\n            for (const p of process.env.PATH.split(path.delimiter)) {\n                if (p) {\n                    directories.push(p);\n                }\n            }\n        }\n        // find all matches\n        const matches = [];\n        for (const directory of directories) {\n            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);\n            if (filePath) {\n                matches.push(filePath);\n            }\n        }\n        return matches;\n    });\n}\nexports.findInPath = findInPath;\nfunction readCopyOptions(options) {\n    const force = options.force == null ? true : options.force;\n    const recursive = Boolean(options.recursive);\n    const copySourceDirectory = options.copySourceDirectory == null\n        ? true\n        : Boolean(options.copySourceDirectory);\n    return { force, recursive, copySourceDirectory };\n}\nfunction cpDirRecursive(sourceDir, destDir, currentDepth, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Ensure there is not a run away recursive copy\n        if (currentDepth >= 255)\n            return;\n        currentDepth++;\n        yield mkdirP(destDir);\n        const files = yield ioUtil.readdir(sourceDir);\n        for (const fileName of files) {\n            const srcFile = `${sourceDir}/${fileName}`;\n            const destFile = `${destDir}/${fileName}`;\n            const srcFileStat = yield ioUtil.lstat(srcFile);\n            if (srcFileStat.isDirectory()) {\n                // Recurse\n                yield cpDirRecursive(srcFile, destFile, currentDepth, force);\n            }\n            else {\n                yield copyFile(srcFile, destFile, force);\n            }\n        }\n        // Change the mode for the newly created directory\n        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);\n    });\n}\n// Buffered file copy\nfunction copyFile(srcFile, destFile, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {\n            // unlink/re-link it\n            try {\n                yield ioUtil.lstat(destFile);\n                yield ioUtil.unlink(destFile);\n            }\n            catch (e) {\n                // Try to override file permission\n                if (e.code === 'EPERM') {\n                    yield ioUtil.chmod(destFile, '0666');\n                    yield ioUtil.unlink(destFile);\n                }\n                // other errors = it doesn't exist, no work to do\n            }\n            // Copy over symlink\n            const symlinkFull = yield ioUtil.readlink(srcFile);\n            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);\n        }\n        else if (!(yield ioUtil.exists(destFile)) || force) {\n            yield ioUtil.copyFile(srcFile, destFile);\n        }\n    });\n}\n//# sourceMappingURL=io.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventAlgorithm_1 = require(\"./EventAlgorithm\");\n/**\n * Adds an algorithm to the given abort signal.\n *\n * @param algorithm - an algorithm\n * @param signal - abort signal\n */\nfunction abort_add(algorithm, signal) {\n    /**\n     * 1. If signal’s aborted flag is set, then return.\n     * 2. Append algorithm to signal’s abort algorithms.\n     */\n    if (signal._abortedFlag)\n        return;\n    signal._abortAlgorithms.add(algorithm);\n}\nexports.abort_add = abort_add;\n/**\n * Removes an algorithm from the given abort signal.\n *\n * @param algorithm - an algorithm\n * @param signal - abort signal\n */\nfunction abort_remove(algorithm, signal) {\n    /**\n     * To remove an algorithm algorithm from an AbortSignal signal, remove\n     * algorithm from signal’s abort algorithms.\n     */\n    signal._abortAlgorithms.delete(algorithm);\n}\nexports.abort_remove = abort_remove;\n/**\n * Signals abort on the given abort signal.\n *\n * @param signal - abort signal\n */\nfunction abort_signalAbort(signal) {\n    var e_1, _a;\n    /**\n     * 1. If signal’s aborted flag is set, then return.\n     * 2. Set signal’s aborted flag.\n     * 3. For each algorithm in signal’s abort algorithms: run algorithm.\n     * 4. Empty signal’s abort algorithms.\n     * 5. Fire an event named abort at signal.\n     */\n    if (signal._abortedFlag)\n        return;\n    signal._abortedFlag = true;\n    try {\n        for (var _b = __values(signal._abortAlgorithms), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var algorithm = _c.value;\n            algorithm.call(signal);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    signal._abortAlgorithms.clear();\n    EventAlgorithm_1.event_fireAnEvent(\"abort\", signal);\n}\nexports.abort_signalAbort = abort_signalAbort;\n//# sourceMappingURL=AbortAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ElementAlgorithm_1 = require(\"./ElementAlgorithm\");\n/**\n * Changes the value of an existing attribute.\n *\n * @param attribute - an attribute node\n * @param value - attribute value\n */\nfunction attr_setAnExistingAttributeValue(attribute, value) {\n    /**\n     * 1. If attribute’s element is null, then set attribute’s value to value.\n     * 2. Otherwise, change attribute from attribute’s element to value.\n     */\n    if (attribute._element === null) {\n        attribute._value = value;\n    }\n    else {\n        ElementAlgorithm_1.element_change(attribute, attribute._element, value);\n    }\n}\nexports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;\n//# sourceMappingURL=AttrAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\n/**\n * Defines the position of a boundary point relative to another.\n *\n * @param bp - a boundary point\n * @param relativeTo - a boundary point to compare to\n */\nfunction boundaryPoint_position(bp, relativeTo) {\n    var nodeA = bp[0];\n    var offsetA = bp[1];\n    var nodeB = relativeTo[0];\n    var offsetB = relativeTo[1];\n    /**\n     * 1. Assert: nodeA and nodeB have the same root.\n     */\n    console.assert(TreeAlgorithm_1.tree_rootNode(nodeA) === TreeAlgorithm_1.tree_rootNode(nodeB), \"Boundary points must share the same root node.\");\n    /**\n     * 2. If nodeA is nodeB, then return equal if offsetA is offsetB, before\n     * if offsetA is less than offsetB, and after if offsetA is greater than\n     * offsetB.\n     */\n    if (nodeA === nodeB) {\n        if (offsetA === offsetB) {\n            return interfaces_1.BoundaryPosition.Equal;\n        }\n        else if (offsetA < offsetB) {\n            return interfaces_1.BoundaryPosition.Before;\n        }\n        else {\n            return interfaces_1.BoundaryPosition.After;\n        }\n    }\n    /**\n     * 3. If nodeA is following nodeB, then if the position of (nodeB, offsetB)\n     * relative to (nodeA, offsetA) is before, return after, and if it is after,\n     * return before.\n     */\n    if (TreeAlgorithm_1.tree_isFollowing(nodeB, nodeA)) {\n        var pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);\n        if (pos === interfaces_1.BoundaryPosition.Before) {\n            return interfaces_1.BoundaryPosition.After;\n        }\n        else if (pos === interfaces_1.BoundaryPosition.After) {\n            return interfaces_1.BoundaryPosition.Before;\n        }\n    }\n    /**\n     * 4. If nodeA is an ancestor of nodeB:\n     */\n    if (TreeAlgorithm_1.tree_isAncestorOf(nodeB, nodeA)) {\n        /**\n         * 4.1. Let child be nodeB.\n         * 4.2. While child is not a child of nodeA, set child to its parent.\n         * 4.3. If child’s index is less than offsetA, then return after.\n         */\n        var child = nodeB;\n        while (!TreeAlgorithm_1.tree_isChildOf(nodeA, child)) {\n            /* istanbul ignore else */\n            if (child._parent !== null) {\n                child = child._parent;\n            }\n        }\n        if (TreeAlgorithm_1.tree_index(child) < offsetA) {\n            return interfaces_1.BoundaryPosition.After;\n        }\n    }\n    /**\n     * 5. Return before.\n     */\n    return interfaces_1.BoundaryPosition.Before;\n}\nexports.boundaryPoint_position = boundaryPoint_position;\n//# sourceMappingURL=BoundaryPointAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar util_1 = require(\"../util\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar MutationObserverAlgorithm_1 = require(\"./MutationObserverAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\n/**\n * Replaces character data.\n *\n * @param node - a character data node\n * @param offset - start offset\n * @param count - count of characters to replace\n * @param data - new data\n */\nfunction characterData_replaceData(node, offset, count, data) {\n    var e_1, _a;\n    /**\n     * 1. Let length be node’s length.\n     * 2. If offset is greater than length, then throw an \"IndexSizeError\"\n     * DOMException.\n     * 3. If offset plus count is greater than length, then set count to length\n     * minus offset.\n     */\n    var length = TreeAlgorithm_1.tree_nodeLength(node);\n    if (offset > length) {\n        throw new DOMException_1.IndexSizeError(\"Offset exceeds character data length. Offset: \" + offset + \", Length: \" + length + \", Node is \" + node.nodeName + \".\");\n    }\n    if (offset + count > length) {\n        count = length - offset;\n    }\n    /**\n     * 4. Queue a mutation record of \"characterData\" for node with null, null,\n     * node’s data, « », « », null, and null.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueMutationRecord(\"characterData\", node, null, null, node._data, [], [], null, null);\n    }\n    /**\n     * 5. Insert data into node’s data after offset code units.\n     * 6. Let delete offset be offset + data’s length.\n     * 7. Starting from delete offset code units, remove count code units from\n     * node’s data.\n     */\n    var newData = node._data.substring(0, offset) + data +\n        node._data.substring(offset + count);\n    node._data = newData;\n    try {\n        /**\n         * 8. For each live range whose start node is node and start offset is\n         * greater than offset but less than or equal to offset plus count, set its\n         * start offset to offset.\n         * 9. For each live range whose end node is node and end offset is greater\n         * than offset but less than or equal to offset plus count, set its end\n         * offset to offset.\n         * 10. For each live range whose start node is node and start offset is\n         * greater than offset plus count, increase its start offset by data’s\n         * length and decrease it by count.\n         * 11. For each live range whose end node is node and end offset is greater\n         * than offset plus count, increase its end offset by data’s length and\n         * decrease it by count.\n         */\n        for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var range = _c.value;\n            if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {\n                range._start[1] = offset;\n            }\n            if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {\n                range._end[1] = offset;\n            }\n            if (range._start[0] === node && range._start[1] > offset + count) {\n                range._start[1] += data.length - count;\n            }\n            if (range._end[0] === node && range._end[1] > offset + count) {\n                range._end[1] += data.length - count;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    /**\n     * 12. If node is a Text node and its parent is not null, run the child\n     * text content change steps for node’s parent.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        if (util_1.Guard.isTextNode(node) && node._parent !== null) {\n            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(node._parent);\n        }\n    }\n}\nexports.characterData_replaceData = characterData_replaceData;\n/**\n * Returns `count` number of characters from `node`'s data starting at\n * the given `offset`.\n *\n * @param node - a character data node\n * @param offset - start offset\n * @param count - count of characters to return\n */\nfunction characterData_substringData(node, offset, count) {\n    /**\n     * 1. Let length be node’s length.\n     * 2. If offset is greater than length, then throw an \"IndexSizeError\"\n     * DOMException.\n     * 3. If offset plus count is greater than length, return a string whose\n     * value is the code units from the offsetth code unit to the end of node’s\n     * data, and then return.\n     * 4. Return a string whose value is the code units from the offsetth code\n     * unit to the offset+countth code unit in node’s data.\n     */\n    var length = TreeAlgorithm_1.tree_nodeLength(node);\n    if (offset > length) {\n        throw new DOMException_1.IndexSizeError(\"Offset exceeds character data length. Offset: \" + offset + \", Length: \" + length + \", Node is \" + node.nodeName + \".\");\n    }\n    if (offset + count > length) {\n        return node._data.substr(offset);\n    }\n    else {\n        return node._data.substr(offset, count);\n    }\n}\nexports.characterData_substringData = characterData_substringData;\n//# sourceMappingURL=CharacterDataAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImplementationImpl_1 = require(\"../dom/DOMImplementationImpl\");\nvar WindowImpl_1 = require(\"../dom/WindowImpl\");\nvar XMLDocumentImpl_1 = require(\"../dom/XMLDocumentImpl\");\nvar DocumentImpl_1 = require(\"../dom/DocumentImpl\");\nvar AbortControllerImpl_1 = require(\"../dom/AbortControllerImpl\");\nvar AbortSignalImpl_1 = require(\"../dom/AbortSignalImpl\");\nvar DocumentTypeImpl_1 = require(\"../dom/DocumentTypeImpl\");\nvar ElementImpl_1 = require(\"../dom/ElementImpl\");\nvar DocumentFragmentImpl_1 = require(\"../dom/DocumentFragmentImpl\");\nvar ShadowRootImpl_1 = require(\"../dom/ShadowRootImpl\");\nvar AttrImpl_1 = require(\"../dom/AttrImpl\");\nvar TextImpl_1 = require(\"../dom/TextImpl\");\nvar CDATASectionImpl_1 = require(\"../dom/CDATASectionImpl\");\nvar CommentImpl_1 = require(\"../dom/CommentImpl\");\nvar ProcessingInstructionImpl_1 = require(\"../dom/ProcessingInstructionImpl\");\nvar HTMLCollectionImpl_1 = require(\"../dom/HTMLCollectionImpl\");\nvar NodeListImpl_1 = require(\"../dom/NodeListImpl\");\nvar NodeListStaticImpl_1 = require(\"../dom/NodeListStaticImpl\");\nvar NamedNodeMapImpl_1 = require(\"../dom/NamedNodeMapImpl\");\nvar RangeImpl_1 = require(\"../dom/RangeImpl\");\nvar NodeIteratorImpl_1 = require(\"../dom/NodeIteratorImpl\");\nvar TreeWalkerImpl_1 = require(\"../dom/TreeWalkerImpl\");\nvar NodeFilterImpl_1 = require(\"../dom/NodeFilterImpl\");\nvar MutationRecordImpl_1 = require(\"../dom/MutationRecordImpl\");\nvar DOMTokenListImpl_1 = require(\"../dom/DOMTokenListImpl\");\n/**\n * Creates a `DOMImplementation`.\n *\n * @param document - associated document\n */\nfunction create_domImplementation(document) {\n    return DOMImplementationImpl_1.DOMImplementationImpl._create(document);\n}\nexports.create_domImplementation = create_domImplementation;\n/**\n * Creates a `Window` node.\n */\nfunction create_window() {\n    return WindowImpl_1.WindowImpl._create();\n}\nexports.create_window = create_window;\n/**\n * Creates an `XMLDocument` node.\n */\nfunction create_xmlDocument() {\n    return new XMLDocumentImpl_1.XMLDocumentImpl();\n}\nexports.create_xmlDocument = create_xmlDocument;\n/**\n * Creates a `Document` node.\n */\nfunction create_document() {\n    return new DocumentImpl_1.DocumentImpl();\n}\nexports.create_document = create_document;\n/**\n * Creates an `AbortController`.\n */\nfunction create_abortController() {\n    return new AbortControllerImpl_1.AbortControllerImpl();\n}\nexports.create_abortController = create_abortController;\n/**\n * Creates an `AbortSignal`.\n */\nfunction create_abortSignal() {\n    return AbortSignalImpl_1.AbortSignalImpl._create();\n}\nexports.create_abortSignal = create_abortSignal;\n/**\n * Creates a `DocumentType` node.\n *\n * @param document - owner document\n * @param name - name of the node\n * @param publicId - `PUBLIC` identifier\n * @param systemId - `SYSTEM` identifier\n */\nfunction create_documentType(document, name, publicId, systemId) {\n    return DocumentTypeImpl_1.DocumentTypeImpl._create(document, name, publicId, systemId);\n}\nexports.create_documentType = create_documentType;\n/**\n * Creates a new `Element` node.\n *\n * @param document - owner document\n * @param localName - local name\n * @param namespace - namespace\n * @param prefix - namespace prefix\n */\nfunction create_element(document, localName, namespace, prefix) {\n    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);\n}\nexports.create_element = create_element;\n/**\n * Creates a new `HTMLElement` node.\n *\n * @param document - owner document\n * @param localName - local name\n * @param namespace - namespace\n * @param prefix - namespace prefix\n */\nfunction create_htmlElement(document, localName, namespace, prefix) {\n    // TODO: Implement in HTML DOM\n    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);\n}\nexports.create_htmlElement = create_htmlElement;\n/**\n * Creates a new `HTMLUnknownElement` node.\n *\n * @param document - owner document\n * @param localName - local name\n * @param namespace - namespace\n * @param prefix - namespace prefix\n */\nfunction create_htmlUnknownElement(document, localName, namespace, prefix) {\n    // TODO: Implement in HTML DOM\n    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);\n}\nexports.create_htmlUnknownElement = create_htmlUnknownElement;\n/**\n * Creates a new `DocumentFragment` node.\n *\n * @param document - owner document\n */\nfunction create_documentFragment(document) {\n    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document);\n}\nexports.create_documentFragment = create_documentFragment;\n/**\n * Creates a new `ShadowRoot` node.\n *\n * @param document - owner document\n * @param host - shadow root's host element node\n */\nfunction create_shadowRoot(document, host) {\n    return ShadowRootImpl_1.ShadowRootImpl._create(document, host);\n}\nexports.create_shadowRoot = create_shadowRoot;\n/**\n * Creates a new `Attr` node.\n *\n * @param document - owner document\n * @param localName - local name\n */\nfunction create_attr(document, localName) {\n    return AttrImpl_1.AttrImpl._create(document, localName);\n}\nexports.create_attr = create_attr;\n/**\n * Creates a new `Text` node.\n *\n * @param document - owner document\n * @param data - node contents\n */\nfunction create_text(document, data) {\n    return TextImpl_1.TextImpl._create(document, data);\n}\nexports.create_text = create_text;\n/**\n * Creates a new `CDATASection` node.\n *\n * @param document - owner document\n * @param data - node contents\n */\nfunction create_cdataSection(document, data) {\n    return CDATASectionImpl_1.CDATASectionImpl._create(document, data);\n}\nexports.create_cdataSection = create_cdataSection;\n/**\n * Creates a new `Comment` node.\n *\n * @param document - owner document\n * @param data - node contents\n */\nfunction create_comment(document, data) {\n    return CommentImpl_1.CommentImpl._create(document, data);\n}\nexports.create_comment = create_comment;\n/**\n * Creates a new `ProcessingInstruction` node.\n *\n * @param document - owner document\n * @param target - instruction target\n * @param data - node contents\n */\nfunction create_processingInstruction(document, target, data) {\n    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document, target, data);\n}\nexports.create_processingInstruction = create_processingInstruction;\n/**\n * Creates a new `HTMLCollection`.\n *\n * @param root - root node\n * @param filter - node filter\n */\nfunction create_htmlCollection(root, filter) {\n    if (filter === void 0) { filter = (function () { return true; }); }\n    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);\n}\nexports.create_htmlCollection = create_htmlCollection;\n/**\n * Creates a new live `NodeList`.\n *\n * @param root - root node\n */\nfunction create_nodeList(root) {\n    return NodeListImpl_1.NodeListImpl._create(root);\n}\nexports.create_nodeList = create_nodeList;\n/**\n * Creates a new static `NodeList`.\n *\n * @param root - root node\n * @param items - a list of items to initialize the list\n */\nfunction create_nodeListStatic(root, items) {\n    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);\n}\nexports.create_nodeListStatic = create_nodeListStatic;\n/**\n * Creates a new `NamedNodeMap`.\n *\n * @param element - parent element\n */\nfunction create_namedNodeMap(element) {\n    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);\n}\nexports.create_namedNodeMap = create_namedNodeMap;\n/**\n * Creates a new `Range`.\n *\n * @param start - start point\n * @param end - end point\n */\nfunction create_range(start, end) {\n    return RangeImpl_1.RangeImpl._create(start, end);\n}\nexports.create_range = create_range;\n/**\n * Creates a new `NodeIterator`.\n *\n * @param root - iterator's root node\n * @param reference - reference node\n * @param pointerBeforeReference - whether the iterator is before or after the\n * reference node\n */\nfunction create_nodeIterator(root, reference, pointerBeforeReference) {\n    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);\n}\nexports.create_nodeIterator = create_nodeIterator;\n/**\n * Creates a new `TreeWalker`.\n *\n * @param root - iterator's root node\n * @param current - current node\n */\nfunction create_treeWalker(root, current) {\n    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);\n}\nexports.create_treeWalker = create_treeWalker;\n/**\n * Creates a new `NodeFilter`.\n */\nfunction create_nodeFilter() {\n    return NodeFilterImpl_1.NodeFilterImpl._create();\n}\nexports.create_nodeFilter = create_nodeFilter;\n/**\n * Creates a new `MutationRecord`.\n *\n * @param type - type of mutation: `\"attributes\"` for an attribute\n * mutation, `\"characterData\"` for a mutation to a CharacterData node\n * and `\"childList\"` for a mutation to the tree of nodes.\n * @param target - node affected by the mutation.\n * @param addedNodes - list of added nodes.\n * @param removedNodes - list of removed nodes.\n * @param previousSibling - previous sibling of added or removed nodes.\n * @param nextSibling - next sibling of added or removed nodes.\n * @param attributeName - local name of the changed attribute,\n * and `null` otherwise.\n * @param attributeNamespace - namespace of the changed attribute,\n * and `null` otherwise.\n * @param oldValue - value before mutation: attribute value for an attribute\n * mutation, node `data` for a mutation to a CharacterData node and `null`\n * for a mutation to the tree of nodes.\n */\nfunction create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {\n    return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);\n}\nexports.create_mutationRecord = create_mutationRecord;\n/**\n * Creates a new `DOMTokenList`.\n *\n * @param element - associated element\n * @param attribute - associated attribute\n */\nfunction create_domTokenList(element, attribute) {\n    return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute);\n}\nexports.create_domTokenList = create_domTokenList;\n//# sourceMappingURL=CreateAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PotentialCustomElementName = /[a-z]([\\0-\\t\\x2D\\._a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*-([\\0-\\t\\x2D\\._a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*/;\nvar NamesWithHyphen = new Set(['annotation-xml', 'color-profile',\n    'font-face', 'font-face-src', 'font-face-uri', 'font-face-format',\n    'font-face-name', 'missing-glyph']);\nvar ElementNames = new Set(['article', 'aside', 'blockquote',\n    'body', 'div', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n    'header', 'main', 'nav', 'p', 'section', 'span']);\nvar VoidElementNames = new Set(['area', 'base', 'basefont',\n    'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',\n    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);\nvar ShadowHostNames = new Set(['article', 'aside', 'blockquote', 'body',\n    'div', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'main',\n    'nav', 'p', 'section', 'span']);\n/**\n * Determines if the given string is a valid custom element name.\n *\n * @param name - a name string\n */\nfunction customElement_isValidCustomElementName(name) {\n    if (!PotentialCustomElementName.test(name))\n        return false;\n    if (NamesWithHyphen.has(name))\n        return false;\n    return true;\n}\nexports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;\n/**\n * Determines if the given string is a valid element name.\n *\n * @param name - a name string\n */\nfunction customElement_isValidElementName(name) {\n    return (ElementNames.has(name));\n}\nexports.customElement_isValidElementName = customElement_isValidElementName;\n/**\n * Determines if the given string is a void element name.\n *\n * @param name - a name string\n */\nfunction customElement_isVoidElementName(name) {\n    return (VoidElementNames.has(name));\n}\nexports.customElement_isVoidElementName = customElement_isVoidElementName;\n/**\n * Determines if the given string is a valid shadow host element name.\n *\n * @param name - a name string\n */\nfunction customElement_isValidShadowHostName(name) {\n    return (ShadowHostNames.has(name));\n}\nexports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;\n/**\n * Enqueues an upgrade reaction for a custom element.\n *\n * @param element - a custom element\n * @param definition - a custom element definition\n */\nfunction customElement_enqueueACustomElementUpgradeReaction(element, definition) {\n    // TODO: Implement in HTML DOM\n}\nexports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;\n/**\n * Enqueues a callback reaction for a custom element.\n *\n * @param element - a custom element\n * @param callbackName - name of the callback\n * @param args - callback arguments\n */\nfunction customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {\n    // TODO: Implement in HTML DOM\n}\nexports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;\n/**\n * Upgrade a custom element.\n *\n * @param element - a custom element\n */\nfunction customElement_upgrade(definition, element) {\n    // TODO: Implement in HTML DOM\n}\nexports.customElement_upgrade = customElement_upgrade;\n/**\n * Tries to upgrade a custom element.\n *\n * @param element - a custom element\n */\nfunction customElement_tryToUpgrade(element) {\n    // TODO: Implement in HTML DOM\n}\nexports.customElement_tryToUpgrade = customElement_tryToUpgrade;\n/**\n * Looks up a custom element definition.\n *\n * @param document - a document\n * @param namespace - element namespace\n * @param localName - element local name\n * @param is - an `is` value\n */\nfunction customElement_lookUpACustomElementDefinition(document, namespace, localName, is) {\n    // TODO: Implement in HTML DOM\n    return null;\n}\nexports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;\n//# sourceMappingURL=CustomElementAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar util_1 = require(\"../util\");\nvar ShadowTreeAlgorithm_1 = require(\"./ShadowTreeAlgorithm\");\nvar supportedTokens = new Map();\n/**\n * Runs removing steps for node.\n *\n * @param removedNode - removed node\n * @param oldParent - old parent node\n */\nfunction dom_runRemovingSteps(removedNode, oldParent) {\n    // No steps defined\n}\nexports.dom_runRemovingSteps = dom_runRemovingSteps;\n/**\n * Runs cloning steps for node.\n *\n * @param copy - node clone\n * @param node - node\n * @param document - document to own the cloned node\n * @param cloneChildrenFlag - whether child nodes are cloned\n */\nfunction dom_runCloningSteps(copy, node, document, cloneChildrenFlag) {\n    // No steps defined\n}\nexports.dom_runCloningSteps = dom_runCloningSteps;\n/**\n * Runs adopting steps for node.\n *\n * @param node - node\n * @param oldDocument - old document\n */\nfunction dom_runAdoptingSteps(node, oldDocument) {\n    // No steps defined\n}\nexports.dom_runAdoptingSteps = dom_runAdoptingSteps;\n/**\n * Runs attribute change steps for an element node.\n *\n * @param element - element node owning the attribute\n * @param localName - attribute's local name\n * @param oldValue - attribute's old value\n * @param value - attribute's new value\n * @param namespace - attribute's namespace\n */\nfunction dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {\n    var e_1, _a;\n    // run default steps\n    if (DOMImpl_1.dom.features.slots) {\n        updateASlotablesName.call(element, element, localName, oldValue, value, namespace);\n        updateASlotsName.call(element, element, localName, oldValue, value, namespace);\n    }\n    updateAnElementID.call(element, element, localName, value, namespace);\n    try {\n        // run custom steps\n        for (var _b = __values(element._attributeChangeSteps), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var step = _c.value;\n            step.call(element, element, localName, oldValue, value, namespace);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\nexports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;\n/**\n * Runs insertion steps for a node.\n *\n * @param insertedNode - inserted node\n */\nfunction dom_runInsertionSteps(insertedNode) {\n    // No steps defined\n}\nexports.dom_runInsertionSteps = dom_runInsertionSteps;\n/**\n * Runs pre-removing steps for a node iterator and node.\n *\n * @param nodeIterator - a node iterator\n * @param toBeRemoved - node to be removed\n */\nfunction dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {\n    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);\n}\nexports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;\n/**\n * Determines if there are any supported tokens defined for the given\n * attribute name.\n *\n * @param attributeName - an attribute name\n */\nfunction dom_hasSupportedTokens(attributeName) {\n    return supportedTokens.has(attributeName);\n}\nexports.dom_hasSupportedTokens = dom_hasSupportedTokens;\n/**\n * Returns the set of supported tokens defined for the given attribute name.\n *\n * @param attributeName - an attribute name\n */\nfunction dom_getSupportedTokens(attributeName) {\n    return supportedTokens.get(attributeName) || new Set();\n}\nexports.dom_getSupportedTokens = dom_getSupportedTokens;\n/**\n * Runs event construction steps.\n *\n * @param event - an event\n */\nfunction dom_runEventConstructingSteps(event) {\n    // No steps defined\n}\nexports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;\n/**\n * Runs child text content change steps for a parent node.\n *\n * @param parent - parent node with text node child nodes\n */\nfunction dom_runChildTextContentChangeSteps(parent) {\n    // No steps defined\n}\nexports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;\n/**\n * Defines pre-removing steps for a node iterator.\n */\nfunction removeNodeIterator(nodeIterator, toBeRemovedNode) {\n    /**\n     * 1. If toBeRemovedNode is not an inclusive ancestor of nodeIterator’s\n     * reference, or toBeRemovedNode is nodeIterator’s root, then return.\n     */\n    if (toBeRemovedNode === nodeIterator._root ||\n        !TreeAlgorithm_1.tree_isAncestorOf(nodeIterator._reference, toBeRemovedNode, true)) {\n        return;\n    }\n    /**\n     * 2. If nodeIterator’s pointer before reference is true, then:\n     */\n    if (nodeIterator._pointerBeforeReference) {\n        /**\n         * 2.1. Let next be toBeRemovedNode’s first following node that is an\n         * inclusive descendant of nodeIterator’s root and is not an inclusive\n         * descendant of toBeRemovedNode, and null if there is no such node.\n         */\n        while (true) {\n            var nextNode = TreeAlgorithm_1.tree_getFollowingNode(nodeIterator._root, toBeRemovedNode);\n            if (nextNode !== null &&\n                TreeAlgorithm_1.tree_isDescendantOf(nodeIterator._root, nextNode, true) &&\n                !TreeAlgorithm_1.tree_isDescendantOf(toBeRemovedNode, nextNode, true)) {\n                /**\n                 * 2.2. If next is non-null, then set nodeIterator’s reference to next\n                 * and return.\n                 */\n                nodeIterator._reference = nextNode;\n                return;\n            }\n            else if (nextNode === null) {\n                /**\n                 * 2.3. Otherwise, set nodeIterator’s pointer before reference to false.\n                 */\n                nodeIterator._pointerBeforeReference = false;\n                return;\n            }\n        }\n    }\n    /**\n     * 3. Set nodeIterator’s reference to toBeRemovedNode’s parent, if\n     * toBeRemovedNode’s previous sibling is null, and to the inclusive\n     * descendant of toBeRemovedNode’s previous sibling that appears last in\n     * tree order otherwise.\n     */\n    if (toBeRemovedNode._previousSibling === null) {\n        if (toBeRemovedNode._parent !== null) {\n            nodeIterator._reference = toBeRemovedNode._parent;\n        }\n    }\n    else {\n        var referenceNode = toBeRemovedNode._previousSibling;\n        var childNode = TreeAlgorithm_1.tree_getFirstDescendantNode(toBeRemovedNode._previousSibling, true, false);\n        while (childNode !== null) {\n            if (childNode !== null) {\n                referenceNode = childNode;\n            }\n            // loop through to get the last descendant node\n            childNode = TreeAlgorithm_1.tree_getNextDescendantNode(toBeRemovedNode._previousSibling, childNode, true, false);\n        }\n        nodeIterator._reference = referenceNode;\n    }\n}\n/**\n * Defines attribute change steps to update a slot’s name.\n */\nfunction updateASlotsName(element, localName, oldValue, value, namespace) {\n    /**\n     * 1. If element is a slot, localName is name, and namespace is null, then:\n     * 1.1. If value is oldValue, then return.\n     * 1.2. If value is null and oldValue is the empty string, then return.\n     * 1.3. If value is the empty string and oldValue is null, then return.\n     * 1.4. If value is null or the empty string, then set element’s name to the\n     * empty string.\n     * 1.5. Otherwise, set element’s name to value.\n     * 1.6. Run assign slotables for a tree with element’s root.\n     */\n    if (util_1.Guard.isSlot(element) && localName === \"name\" && namespace === null) {\n        if (value === oldValue)\n            return;\n        if (value === null && oldValue === '')\n            return;\n        if (value === '' && oldValue === null)\n            return;\n        if ((value === null || value === '')) {\n            element._name = '';\n        }\n        else {\n            element._name = value;\n        }\n        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(element));\n    }\n}\n/**\n * Defines attribute change steps to update a slotable’s name.\n */\nfunction updateASlotablesName(element, localName, oldValue, value, namespace) {\n    /**\n     * 1. If localName is slot and namespace is null, then:\n     * 1.1. If value is oldValue, then return.\n     * 1.2. If value is null and oldValue is the empty string, then return.\n     * 1.3. If value is the empty string and oldValue is null, then return.\n     * 1.4. If value is null or the empty string, then set element’s name to\n     * the empty string.\n     * 1.5. Otherwise, set element’s name to value.\n     * 1.6. If element is assigned, then run assign slotables for element’s\n     * assigned slot.\n     * 1.7. Run assign a slot for element.\n     */\n    if (util_1.Guard.isSlotable(element) && localName === \"slot\" && namespace === null) {\n        if (value === oldValue)\n            return;\n        if (value === null && oldValue === '')\n            return;\n        if (value === '' && oldValue === null)\n            return;\n        if ((value === null || value === '')) {\n            element._name = '';\n        }\n        else {\n            element._name = value;\n        }\n        if (ShadowTreeAlgorithm_1.shadowTree_isAssigned(element)) {\n            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(element._assignedSlot);\n        }\n        ShadowTreeAlgorithm_1.shadowTree_assignASlot(element);\n    }\n}\n/**\n * Defines attribute change steps to update an element's ID.\n */\nfunction updateAnElementID(element, localName, value, namespace) {\n    /**\n     * 1. If localName is id, namespace is null, and value is null or the empty\n     * string, then unset element’s ID.\n     * 2. Otherwise, if localName is id, namespace is null, then set element’s\n     * ID to value.\n     */\n    if (localName === \"id\" && namespace === null) {\n        if (!value)\n            element._uniqueIdentifier = undefined;\n        else\n            element._uniqueIdentifier = value;\n    }\n}\n//# sourceMappingURL=DOMAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OrderedSetAlgorithm_1 = require(\"./OrderedSetAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\nvar ElementAlgorithm_1 = require(\"./ElementAlgorithm\");\n/**\n * Validates a given token against the supported tokens defined for the given\n * token lists' associated attribute.\n *\n * @param tokenList - a token list\n * @param token - a token\n */\nfunction tokenList_validationSteps(tokenList, token) {\n    /**\n     * 1. If the associated attribute’s local name does not define supported\n     * tokens, throw a TypeError.\n     * 2. Let lowercase token be a copy of token, in ASCII lowercase.\n     * 3. If lowercase token is present in supported tokens, return true.\n     * 4. Return false.\n     */\n    if (!DOMAlgorithm_1.dom_hasSupportedTokens(tokenList._attribute._localName)) {\n        throw new TypeError(\"There are no supported tokens defined for attribute name: '\" + tokenList._attribute._localName + \"'.\");\n    }\n    return DOMAlgorithm_1.dom_getSupportedTokens(tokenList._attribute._localName).has(token.toLowerCase());\n}\nexports.tokenList_validationSteps = tokenList_validationSteps;\n/**\n * Updates the value of the token lists' associated attribute.\n *\n * @param tokenList - a token list\n */\nfunction tokenList_updateSteps(tokenList) {\n    /**\n     * 1. If the associated element does not have an associated attribute and\n     * token set is empty, then return.\n     * 2. Set an attribute value for the associated element using associated\n     * attribute’s local name and the result of running the ordered set\n     * serializer for token set.\n     */\n    if (!tokenList._element.hasAttribute(tokenList._attribute._localName) &&\n        tokenList._tokenSet.size === 0) {\n        return;\n    }\n    ElementAlgorithm_1.element_setAnAttributeValue(tokenList._element, tokenList._attribute._localName, OrderedSetAlgorithm_1.orderedSet_serialize(tokenList._tokenSet));\n}\nexports.tokenList_updateSteps = tokenList_updateSteps;\n/**\n * Gets the value of the token lists' associated attribute.\n *\n * @param tokenList - a token list\n */\nfunction tokenList_serializeSteps(tokenList) {\n    /**\n     * A DOMTokenList object’s serialize steps are to return the result of\n     * running get an attribute value given the associated element and the\n     * associated attribute’s local name.\n     */\n    return ElementAlgorithm_1.element_getAnAttributeValue(tokenList._element, tokenList._attribute._localName);\n}\nexports.tokenList_serializeSteps = tokenList_serializeSteps;\n//# sourceMappingURL=DOMTokenListAlgorithm.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar util_1 = require(\"../util\");\nvar util_2 = require(\"@oozcitak/util\");\nvar ElementImpl_1 = require(\"../dom/ElementImpl\");\nvar CustomElementAlgorithm_1 = require(\"./CustomElementAlgorithm\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar NamespaceAlgorithm_1 = require(\"./NamespaceAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\nvar ElementAlgorithm_1 = require(\"./ElementAlgorithm\");\nvar MutationAlgorithm_1 = require(\"./MutationAlgorithm\");\n/**\n * Returns an element interface for the given name and namespace.\n *\n * @param name - element name\n * @param namespace - namespace\n */\nfunction document_elementInterface(name, namespace) {\n    return ElementImpl_1.ElementImpl;\n}\nexports.document_elementInterface = document_elementInterface;\n/**\n * Creates a new element node.\n * See: https://dom.spec.whatwg.org/#internal-createelementns-steps\n *\n * @param document - owner document\n * @param namespace - element namespace\n * @param qualifiedName - qualified name\n * @param options - element options\n */\nfunction document_internalCreateElementNS(document, namespace, qualifiedName, options) {\n    /**\n     * 1. Let namespace, prefix, and localName be the result of passing\n     * namespace and qualifiedName to validate and extract.\n     * 2. Let is be null.\n     * 3. If options is a dictionary and options’s is is present, then set\n     * is to it.\n     * 4. Return the result of creating an element given document, localName,\n     * namespace, prefix, is, and with the synchronous custom elements flag set.\n     */\n    var _a = __read(NamespaceAlgorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];\n    var is = null;\n    if (options !== undefined) {\n        if (util_2.isString(options)) {\n            is = options;\n        }\n        else {\n            is = options.is;\n        }\n    }\n    return ElementAlgorithm_1.element_createAnElement(document, localName, ns, prefix, is, true);\n}\nexports.document_internalCreateElementNS = document_internalCreateElementNS;\n/**\n * Removes `node` and its subtree from its document and changes\n * its owner document to `document` so that it can be inserted\n * into `document`.\n *\n * @param node - the node to move\n * @param document - document to receive the node and its subtree\n */\nfunction document_adopt(node, document) {\n    var e_1, _a;\n    // Optimize for common case of inserting a fresh node\n    if (node._nodeDocument === document && node._parent === null) {\n        return;\n    }\n    /**\n     * 1. Let oldDocument be node’s node document.\n     * 2. If node’s parent is not null, remove node from its parent.\n     */\n    var oldDocument = node._nodeDocument;\n    if (node._parent)\n        MutationAlgorithm_1.mutation_remove(node, node._parent);\n    /**\n     * 3. If document is not oldDocument, then:\n     */\n    if (document !== oldDocument) {\n        /**\n         * 3.1. For each inclusiveDescendant in node’s shadow-including inclusive\n         * descendants:\n         */\n        var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, true);\n        while (inclusiveDescendant !== null) {\n            /**\n             * 3.1.1. Set inclusiveDescendant’s node document to document.\n             * 3.1.2. If inclusiveDescendant is an element, then set the node\n             * document of each attribute in inclusiveDescendant’s attribute list\n             * to document.\n             */\n            inclusiveDescendant._nodeDocument = document;\n            if (util_1.Guard.isElementNode(inclusiveDescendant)) {\n                try {\n                    for (var _b = (e_1 = void 0, __values(inclusiveDescendant._attributeList._asArray())), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var attr = _c.value;\n                        attr._nodeDocument = document;\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n            /**\n             * 3.2. For each inclusiveDescendant in node's shadow-including\n             * inclusive descendants that is custom, enqueue a custom\n             * element callback reaction with inclusiveDescendant,\n             * callback name \"adoptedCallback\", and an argument list\n             * containing oldDocument and document.\n             */\n            if (DOMImpl_1.dom.features.customElements) {\n                if (util_1.Guard.isElementNode(inclusiveDescendant) &&\n                    inclusiveDescendant._customElementState === \"custom\") {\n                    CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, \"adoptedCallback\", [oldDocument, document]);\n                }\n            }\n            /**\n             * 3.3. For each inclusiveDescendant in node’s shadow-including\n             * inclusive descendants, in shadow-including tree order, run the\n             * adopting steps with inclusiveDescendant and oldDocument.\n             */\n            if (DOMImpl_1.dom.features.steps) {\n                DOMAlgorithm_1.dom_runAdoptingSteps(inclusiveDescendant, oldDocument);\n            }\n            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, inclusiveDescendant, true, true);\n        }\n    }\n}\nexports.document_adopt = document_adopt;\n//# sourceMappingURL=DocumentAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar util_1 = require(\"../util\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar CreateAlgorithm_1 = require(\"./CreateAlgorithm\");\nvar CustomElementAlgorithm_1 = require(\"./CustomElementAlgorithm\");\nvar MutationObserverAlgorithm_1 = require(\"./MutationObserverAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\nvar MutationAlgorithm_1 = require(\"./MutationAlgorithm\");\nvar DocumentAlgorithm_1 = require(\"./DocumentAlgorithm\");\n/**\n * Determines whether the element's attribute list contains the given\n * attribute.\n *\n * @param attribute - an attribute node\n * @param element - an element node\n */\nfunction element_has(attribute, element) {\n    /**\n     * An element has an attribute A if its attribute list contains A.\n     */\n    return element._attributeList._asArray().indexOf(attribute) !== -1;\n}\nexports.element_has = element_has;\n/**\n * Changes the value of an attribute node.\n *\n * @param attribute - an attribute node\n * @param element - an element node\n * @param value - attribute value\n */\nfunction element_change(attribute, element, value) {\n    /**\n     * 1. Queue an attribute mutation record for element with attribute’s\n     * local name, attribute’s namespace, and attribute’s value.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);\n    }\n    /**\n     * 2. If element is custom, then enqueue a custom element callback reaction\n     * with element, callback name \"attributeChangedCallback\", and an argument\n     * list containing attribute’s local name, attribute’s value, value, and\n     * attribute’s namespace.\n     */\n    if (DOMImpl_1.dom.features.customElements) {\n        if (util_1.Guard.isCustomElementNode(element)) {\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, \"attributeChangedCallback\", [attribute._localName, attribute._value, value, attribute._namespace]);\n        }\n    }\n    /**\n     * 3. Run the attribute change steps with element, attribute’s local name,\n     * attribute’s value, value, and attribute’s namespace.\n     * 4. Set attribute’s value to value.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, value, attribute._namespace);\n    }\n    attribute._value = value;\n}\nexports.element_change = element_change;\n/**\n * Appends an attribute to an element node.\n *\n * @param attribute - an attribute\n * @param element - an element to receive the attribute\n */\nfunction element_append(attribute, element) {\n    /**\n     * 1. Queue an attribute mutation record for element with attribute’s\n     * local name, attribute’s namespace, and null.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, null);\n    }\n    /**\n     * 2. If element is custom, then enqueue a custom element callback reaction\n     * with element, callback name \"attributeChangedCallback\", and an argument\n     * list containing attribute’s local name, null, attribute’s value, and\n     * attribute’s namespace.\n     */\n    if (DOMImpl_1.dom.features.customElements) {\n        if (util_1.Guard.isCustomElementNode(element)) {\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, \"attributeChangedCallback\", [attribute._localName, null, attribute._value, attribute._namespace]);\n        }\n    }\n    /**\n     * 3. Run the attribute change steps with element, attribute’s local name,\n     * null, attribute’s value, and attribute’s namespace.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, null, attribute._value, attribute._namespace);\n    }\n    /**\n     * 4. Append attribute to element’s attribute list.\n     * 5. Set attribute’s element to element.\n     */\n    element._attributeList._asArray().push(attribute);\n    attribute._element = element;\n    // mark that the document has namespaces\n    if (!element._nodeDocument._hasNamespaces && (attribute._namespace !== null ||\n        attribute._namespacePrefix !== null || attribute._localName === \"xmlns\")) {\n        element._nodeDocument._hasNamespaces = true;\n    }\n}\nexports.element_append = element_append;\n/**\n * Removes an attribute from an element node.\n *\n * @param attribute - an attribute\n * @param element - an element to receive the attribute\n */\nfunction element_remove(attribute, element) {\n    /**\n     * 1. Queue an attribute mutation record for element with attribute’s\n     * local name, attribute’s namespace, and attribute’s value.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);\n    }\n    /**\n     * 2. If element is custom, then enqueue a custom element callback reaction\n     * with element, callback name \"attributeChangedCallback\", and an argument\n     * list containing attribute’s local name, attribute’s value, null,\n     * and attribute’s namespace.\n     */\n    if (DOMImpl_1.dom.features.customElements) {\n        if (util_1.Guard.isCustomElementNode(element)) {\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, \"attributeChangedCallback\", [attribute._localName, attribute._value, null, attribute._namespace]);\n        }\n    }\n    /**\n     * 3. Run the attribute change steps with element, attribute’s local name,\n     * attribute’s value, null, and attribute’s namespace.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, null, attribute._namespace);\n    }\n    /**\n     * 3. Remove attribute from element’s attribute list.\n     * 5. Set attribute’s element to null.\n     */\n    var index = element._attributeList._asArray().indexOf(attribute);\n    element._attributeList._asArray().splice(index, 1);\n    attribute._element = null;\n}\nexports.element_remove = element_remove;\n/**\n * Replaces an attribute with another of an element node.\n *\n * @param oldAttr - old attribute\n * @param newAttr - new attribute\n * @param element - an element to receive the attribute\n */\nfunction element_replace(oldAttr, newAttr, element) {\n    /**\n     * 1. Queue an attribute mutation record for element with oldAttr’s\n     * local name, oldAttr’s namespace, and oldAttr’s value.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);\n    }\n    /**\n     * 2. If element is custom, then enqueue a custom element callback reaction\n     * with element, callback name \"attributeChangedCallback\", and an argument\n     * list containing oldAttr’s local name, oldAttr’s value, newAttr’s value,\n     * and oldAttr’s namespace.\n     */\n    if (DOMImpl_1.dom.features.customElements) {\n        if (util_1.Guard.isCustomElementNode(element)) {\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, \"attributeChangedCallback\", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);\n        }\n    }\n    /**\n     * 3. Run the attribute change steps with element, oldAttr’s local name,\n     * oldAttr’s value, newAttr’s value, and oldAttr’s namespace.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);\n    }\n    /**\n     * 4. Replace oldAttr by newAttr in element’s attribute list.\n     * 5. Set oldAttr’s element to null.\n     * 6. Set newAttr’s element to element.\n     */\n    var index = element._attributeList._asArray().indexOf(oldAttr);\n    if (index !== -1) {\n        element._attributeList._asArray()[index] = newAttr;\n    }\n    oldAttr._element = null;\n    newAttr._element = element;\n    // mark that the document has namespaces\n    if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null ||\n        newAttr._namespacePrefix !== null || newAttr._localName === \"xmlns\")) {\n        element._nodeDocument._hasNamespaces = true;\n    }\n}\nexports.element_replace = element_replace;\n/**\n * Retrieves an attribute with the given name from an element node.\n *\n * @param qualifiedName - an attribute name\n * @param element - an element to receive the attribute\n */\nfunction element_getAnAttributeByName(qualifiedName, element) {\n    /**\n     * 1. If element is in the HTML namespace and its node document is an HTML\n     * document, then set qualifiedName to qualifiedName in ASCII lowercase.\n     * 2. Return the first attribute in element’s attribute list whose qualified\n     * name is qualifiedName, and null otherwise.\n     */\n    if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === \"html\") {\n        qualifiedName = qualifiedName.toLowerCase();\n    }\n    return element._attributeList._asArray().find(function (attr) { return attr._qualifiedName === qualifiedName; }) || null;\n}\nexports.element_getAnAttributeByName = element_getAnAttributeByName;\n/**\n * Retrieves an attribute with the given namespace and local name from an\n * element node.\n *\n * @param namespace - an attribute namespace\n * @param localName - an attribute local name\n * @param element - an element to receive the attribute\n */\nfunction element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {\n    /**\n     * 1. If namespace is the empty string, set it to null.\n     * 2. Return the attribute in element’s attribute list whose namespace is\n     * namespace and local name is localName, if any, and null otherwise.\n     */\n    var ns = namespace || null;\n    return element._attributeList._asArray().find(function (attr) { return attr._namespace === ns && attr._localName === localName; }) || null;\n}\nexports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;\n/**\n * Retrieves an attribute's value with the given name namespace and local\n * name from an element node.\n *\n * @param element - an element to receive the attribute\n * @param localName - an attribute local name\n * @param namespace - an attribute namespace\n */\nfunction element_getAnAttributeValue(element, localName, namespace) {\n    if (namespace === void 0) { namespace = ''; }\n    /**\n     * 1. Let attr be the result of getting an attribute given namespace,\n     * localName, and element.\n     * 2. If attr is null, then return the empty string.\n     * 3. Return attr’s value.\n     */\n    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);\n    if (attr === null)\n        return '';\n    else\n        return attr._value;\n}\nexports.element_getAnAttributeValue = element_getAnAttributeValue;\n/**\n * Sets an attribute of an element node.\n *\n * @param attr - an attribute\n * @param element - an element to receive the attribute\n */\nfunction element_setAnAttribute(attr, element) {\n    /**\n     * 1. If attr’s element is neither null nor element, throw an\n     * \"InUseAttributeError\" DOMException.\n     * 2. Let oldAttr be the result of getting an attribute given attr’s\n     * namespace, attr’s local name, and element.\n     * 3. If oldAttr is attr, return attr.\n     * 4. If oldAttr is non-null, replace it by attr in element.\n     * 5. Otherwise, append attr to element.\n     * 6. Return oldAttr.\n     */\n    if (attr._element !== null && attr._element !== element)\n        throw new DOMException_1.InUseAttributeError(\"This attribute already exists in the document: \" + attr._qualifiedName + \" as a child of \" + attr._element._qualifiedName + \".\");\n    var oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || '', attr._localName, element);\n    if (oldAttr === attr)\n        return attr;\n    if (oldAttr !== null) {\n        element_replace(oldAttr, attr, element);\n    }\n    else {\n        element_append(attr, element);\n    }\n    return oldAttr;\n}\nexports.element_setAnAttribute = element_setAnAttribute;\n/**\n * Sets an attribute's value of an element node.\n *\n * @param element - an element to receive the attribute\n * @param localName - an attribute local name\n * @param value - an attribute value\n * @param prefix - an attribute prefix\n * @param namespace - an attribute namespace\n */\nfunction element_setAnAttributeValue(element, localName, value, prefix, namespace) {\n    if (prefix === void 0) { prefix = null; }\n    if (namespace === void 0) { namespace = null; }\n    /**\n     * 1. If prefix is not given, set it to null.\n     * 2. If namespace is not given, set it to null.\n     * 3. Let attribute be the result of getting an attribute given namespace,\n     * localName, and element.\n     * 4. If attribute is null, create an attribute whose namespace is\n     * namespace, namespace prefix is prefix, local name is localName, value\n     * is value, and node document is element’s node document, then append this\n     * attribute to element, and then return.\n     * 5. Change attribute from element to value.\n     */\n    var attribute = element_getAnAttributeByNamespaceAndLocalName(namespace || '', localName, element);\n    if (attribute === null) {\n        var newAttr = CreateAlgorithm_1.create_attr(element._nodeDocument, localName);\n        newAttr._namespace = namespace;\n        newAttr._namespacePrefix = prefix;\n        newAttr._value = value;\n        element_append(newAttr, element);\n        return;\n    }\n    element_change(attribute, element, value);\n}\nexports.element_setAnAttributeValue = element_setAnAttributeValue;\n/**\n * Removes an attribute with the given name from an element node.\n *\n * @param qualifiedName - an attribute name\n * @param element - an element to receive the attribute\n */\nfunction element_removeAnAttributeByName(qualifiedName, element) {\n    /**\n     * 1. Let attr be the result of getting an attribute given qualifiedName\n     * and element.\n     * 2. If attr is non-null, remove it from element.\n     * 3. Return attr.\n     */\n    var attr = element_getAnAttributeByName(qualifiedName, element);\n    if (attr !== null) {\n        element_remove(attr, element);\n    }\n    return attr;\n}\nexports.element_removeAnAttributeByName = element_removeAnAttributeByName;\n/**\n * Removes an attribute with the given namespace and local name from an\n * element node.\n *\n * @param namespace - an attribute namespace\n * @param localName - an attribute local name\n * @param element - an element to receive the attribute\n */\nfunction element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {\n    /**\n     * 1. Let attr be the result of getting an attribute given namespace, localName, and element.\n     * 2. If attr is non-null, remove it from element.\n     * 3. Return attr.\n     */\n    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);\n    if (attr !== null) {\n        element_remove(attr, element);\n    }\n    return attr;\n}\nexports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;\n/**\n * Creates an element node.\n * See: https://dom.spec.whatwg.org/#concept-create-element.\n *\n * @param document - the document owning the element\n * @param localName - local name\n * @param namespace - element namespace\n * @param prefix - namespace prefix\n * @param is - the \"is\" value\n * @param synchronousCustomElementsFlag - synchronous custom elements flag\n */\nfunction element_createAnElement(document, localName, namespace, prefix, is, synchronousCustomElementsFlag) {\n    if (prefix === void 0) { prefix = null; }\n    if (is === void 0) { is = null; }\n    if (synchronousCustomElementsFlag === void 0) { synchronousCustomElementsFlag = false; }\n    /**\n     * 1. If prefix was not given, let prefix be null.\n     * 2. If is was not given, let is be null.\n     * 3. Let result be null.\n     */\n    var result = null;\n    if (!DOMImpl_1.dom.features.customElements) {\n        result = CreateAlgorithm_1.create_element(document, localName, namespace, prefix);\n        result._customElementState = \"uncustomized\";\n        result._customElementDefinition = null;\n        result._is = is;\n        return result;\n    }\n    /**\n     * 4. Let definition be the result of looking up a custom element definition\n     * given document, namespace, localName, and is.\n     */\n    var definition = CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition(document, namespace, localName, is);\n    if (definition !== null && definition.name !== definition.localName) {\n        /**\n        * 5. If definition is non-null, and definition’s name is not equal to\n        * its local name (i.e., definition represents a customized built-in\n        * element), then:\n          * 5.1. Let interface be the element interface for localName and the HTML\n          * namespace.\n          * 5.2. Set result to a new element that implements interface, with no\n          * attributes, namespace set to the HTML namespace, namespace prefix\n          * set to prefix, local name set to localName, custom element state set\n          * to \"undefined\", custom element definition set to null, is value set\n          * to is, and node document set to document.\n          * 5.3. If the synchronous custom elements flag is set, upgrade element\n          * using definition.\n          * 5.4. Otherwise, enqueue a custom element upgrade reaction given result\n          * and definition.\n          */\n        var elemenInterface = DocumentAlgorithm_1.document_elementInterface(localName, infra_1.namespace.HTML);\n        result = new elemenInterface();\n        result._localName = localName;\n        result._namespace = infra_1.namespace.HTML;\n        result._namespacePrefix = prefix;\n        result._customElementState = \"undefined\";\n        result._customElementDefinition = null;\n        result._is = is;\n        result._nodeDocument = document;\n        if (synchronousCustomElementsFlag) {\n            CustomElementAlgorithm_1.customElement_upgrade(definition, result);\n        }\n        else {\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);\n        }\n    }\n    else if (definition !== null) {\n        /**\n         * 6. Otherwise, if definition is non-null, then:\n         */\n        if (synchronousCustomElementsFlag) {\n            /**\n             * 6.1. If the synchronous custom elements flag is set, then run these\n             * steps while catching any exceptions:\n             */\n            try {\n                /**\n                 * 6.1.1. Let C be definition’s constructor.\n                 * 6.1.2. Set result to the result of constructing C, with no arguments.\n                 * 6.1.3. Assert: result’s custom element state and custom element definition\n                 * are initialized.\n                 * 6.1.4. Assert: result’s namespace is the HTML namespace.\n                 * _Note:_ IDL enforces that result is an HTMLElement object, which all\n                 * use the HTML namespace.\n                 */\n                var C = definition.constructor;\n                var result_1 = new C();\n                console.assert(result_1._customElementState !== undefined);\n                console.assert(result_1._customElementDefinition !== undefined);\n                console.assert(result_1._namespace === infra_1.namespace.HTML);\n                /**\n                 * 6.1.5. If result’s attribute list is not empty, then throw a\n                 * \"NotSupportedError\" DOMException.\n                 * 6.1.6. If result has children, then throw a \"NotSupportedError\"\n                 * DOMException.\n                 * 6.1.7. If result’s parent is not null, then throw a\n                 * \"NotSupportedError\" DOMException.\n                 * 6.1.8. If result’s node document is not document, then throw a\n                 * \"NotSupportedError\" DOMException.\n                 * 6.1.9. If result’s local name is not equal to localName, then throw\n                 * a \"NotSupportedError\" DOMException.\n                 */\n                if (result_1._attributeList.length !== 0)\n                    throw new DOMException_1.NotSupportedError(\"Custom element already has attributes.\");\n                if (result_1._children.size !== 0)\n                    throw new DOMException_1.NotSupportedError(\"Custom element already has child nodes.\");\n                if (result_1._parent !== null)\n                    throw new DOMException_1.NotSupportedError(\"Custom element already has a parent node.\");\n                if (result_1._nodeDocument !== document)\n                    throw new DOMException_1.NotSupportedError(\"Custom element is already in a document.\");\n                if (result_1._localName !== localName)\n                    throw new DOMException_1.NotSupportedError(\"Custom element has a different local name.\");\n                /**\n                 * 6.1.10. Set result’s namespace prefix to prefix.\n                 * 6.1.11. Set result’s is value to null.\n                 */\n                result_1._namespacePrefix = prefix;\n                result_1._is = null;\n            }\n            catch (e) {\n                /**\n                 * If any of these steps threw an exception, then:\n                 * - Report the exception.\n                 * - Set result to a new element that implements the HTMLUnknownElement\n                 * interface, with no attributes, namespace set to the HTML namespace,\n                 * namespace prefix set to prefix, local name set to localName, custom\n                 * element state set to \"failed\", custom element definition set to null,\n                 * is value set to null, and node document set to document.\n                 */\n                // TODO: Report the exception\n                result = CreateAlgorithm_1.create_htmlUnknownElement(document, localName, infra_1.namespace.HTML, prefix);\n                result._customElementState = \"failed\";\n                result._customElementDefinition = null;\n                result._is = null;\n            }\n        }\n        else {\n            /**\n             * 6.2. Otherwise:\n             * 6.2.1. Set result to a new element that implements the HTMLElement\n             * interface, with no attributes, namespace set to the HTML namespace,\n             * namespace prefix set to prefix, local name set to localName, custom\n             * element state set to \"undefined\", custom element definition set to\n             * null, is value set to null, and node document set to document.\n             * 6.2.2. Enqueue a custom element upgrade reaction given result and\n             * definition.\n             */\n            result = CreateAlgorithm_1.create_htmlElement(document, localName, infra_1.namespace.HTML, prefix);\n            result._customElementState = \"undefined\";\n            result._customElementDefinition = null;\n            result._is = null;\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);\n        }\n    }\n    else {\n        /**\n         * 7. Otherwise:\n         * 7.1. Let interface be the element interface for localName and\n         * namespace.\n         * 7.2. Set result to a new element that implements interface, with no\n         * attributes, namespace set to namespace, namespace prefix set to prefix,\n         * local name set to localName, custom element state set to\n         * \"uncustomized\", custom element definition set to null, is value set to\n         * is, and node document set to document.\n         */\n        var elementInterface = DocumentAlgorithm_1.document_elementInterface(localName, namespace);\n        result = new elementInterface();\n        result._localName = localName;\n        result._namespace = namespace;\n        result._namespacePrefix = prefix;\n        result._customElementState = \"uncustomized\";\n        result._customElementDefinition = null;\n        result._is = is;\n        result._nodeDocument = document;\n        /**\n         * 7.3. If namespace is the HTML namespace, and either localName is a\n         * valid custom element name or is is non-null, then set result’s\n         * custom element state to \"undefined\".\n         */\n        if (namespace === infra_1.namespace.HTML && (is !== null ||\n            CustomElementAlgorithm_1.customElement_isValidCustomElementName(localName))) {\n            result._customElementState = \"undefined\";\n        }\n    }\n    /* istanbul ignore next */\n    if (result === null) {\n        throw new Error(\"Unable to create element.\");\n    }\n    /**\n     * 8. Returns result\n     */\n    return result;\n}\nexports.element_createAnElement = element_createAnElement;\n/**\n * Inserts a new node adjacent to this element.\n *\n * @param element - a reference element\n * @param where - a string defining where to insert the element node.\n *   - `beforebegin` before this element itself.\n *   - `afterbegin` before the first child.\n *   - `beforeend` after the last child.\n *   - `afterend` after this element itself.\n * @param node - node to insert\n */\nfunction element_insertAdjacent(element, where, node) {\n    /**\n     * - \"beforebegin\"\n     * If element’s parent is null, return null.\n     * Return the result of pre-inserting node into element’s parent before\n     * element.\n     * - \"afterbegin\"\n     * Return the result of pre-inserting node into element before element’s\n     * first child.\n     * - \"beforeend\"\n     * Return the result of pre-inserting node into element before null.\n     * - \"afterend\"\n     * If element’s parent is null, return null.\n     * Return the result of pre-inserting node into element’s parent before element’s next sibling.\n     * - Otherwise\n     * Throw a \"SyntaxError\" DOMException.\n     */\n    switch (where.toLowerCase()) {\n        case 'beforebegin':\n            if (element._parent === null)\n                return null;\n            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element);\n        case 'afterbegin':\n            return MutationAlgorithm_1.mutation_preInsert(node, element, element._firstChild);\n        case 'beforeend':\n            return MutationAlgorithm_1.mutation_preInsert(node, element, null);\n        case 'afterend':\n            if (element._parent === null)\n                return null;\n            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element._nextSibling);\n        default:\n            throw new DOMException_1.SyntaxError(\"Invalid 'where' argument. \\\"beforebegin\\\", \\\"afterbegin\\\", \\\"beforeend\\\" or \\\"afterend\\\" expected\");\n    }\n}\nexports.element_insertAdjacent = element_insertAdjacent;\n//# sourceMappingURL=ElementAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar util_1 = require(\"../util\");\nvar CustomEventImpl_1 = require(\"../dom/CustomEventImpl\");\nvar EventImpl_1 = require(\"../dom/EventImpl\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar ShadowTreeAlgorithm_1 = require(\"./ShadowTreeAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\n/**\n * Sets the canceled flag of an event.\n *\n * @param event - an event\n */\nfunction event_setTheCanceledFlag(event) {\n    if (event._cancelable && !event._inPassiveListenerFlag) {\n        event._canceledFlag = true;\n    }\n}\nexports.event_setTheCanceledFlag = event_setTheCanceledFlag;\n/**\n * Initializes the value of an event.\n *\n * @param event - an event to initialize\n * @param type - the type of event\n * @param bubbles - whether the event propagates in reverse\n * @param cancelable - whether the event can be cancelled\n */\nfunction event_initialize(event, type, bubbles, cancelable) {\n    event._initializedFlag = true;\n    event._stopPropagationFlag = false;\n    event._stopImmediatePropagationFlag = false;\n    event._canceledFlag = false;\n    event._isTrusted = false;\n    event._target = null;\n    event._type = type;\n    event._bubbles = bubbles;\n    event._cancelable = cancelable;\n}\nexports.event_initialize = event_initialize;\n/**\n * Creates a new event.\n *\n * @param eventInterface - event interface\n * @param realm - realm\n */\nfunction event_createAnEvent(eventInterface, realm) {\n    if (realm === void 0) { realm = undefined; }\n    /**\n     * 1. If realm is not given, then set it to null.\n     * 2. Let dictionary be the result of converting the JavaScript value\n     * undefined to the dictionary type accepted by eventInterface’s\n     * constructor. (This dictionary type will either be EventInit or a\n     * dictionary that inherits from it.)\n     * 3. Let event be the result of running the inner event creation steps with\n     * eventInterface, realm, the time of the occurrence that the event is\n     * signaling, and dictionary.\n     * 4. Initialize event’s isTrusted attribute to true.\n     * 5. Return event.\n     */\n    if (realm === undefined)\n        realm = null;\n    var dictionary = {};\n    var event = event_innerEventCreationSteps(eventInterface, realm, new Date(), dictionary);\n    event._isTrusted = true;\n    return event;\n}\nexports.event_createAnEvent = event_createAnEvent;\n/**\n * Performs event creation steps.\n *\n * @param eventInterface - event interface\n * @param realm - realm\n * @param time - time of occurrance\n * @param dictionary - event attributes\n *\n */\nfunction event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {\n    /**\n     * 1. Let event be the result of creating a new object using eventInterface.\n     * TODO: Implement realms\n     * If realm is non-null, then use that Realm; otherwise, use the default\n     * behavior defined in Web IDL.\n     */\n    var event = new eventInterface(\"\");\n    /**\n     * 2. Set event’s initialized flag.\n     * 3. Initialize event’s timeStamp attribute to a DOMHighResTimeStamp\n     * representing the high resolution time from the time origin to time.\n     * 4. For each member → value in dictionary, if event has an attribute\n     * whose identifier is member, then initialize that attribute to value.\n     * 5. Run the event constructing steps with event.\n     * 6. Return event.\n     */\n    event._initializedFlag = true;\n    event._timeStamp = time.getTime();\n    Object.assign(event, dictionary);\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runEventConstructingSteps(event);\n    }\n    return event;\n}\nexports.event_innerEventCreationSteps = event_innerEventCreationSteps;\n/**\n * Dispatches an event to an event target.\n *\n * @param event - the event to dispatch\n * @param target - event target\n * @param legacyTargetOverrideFlag - legacy target override flag\n * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns\n * whether the event listener's callback threw an exception\n */\nfunction event_dispatch(event, target, legacyTargetOverrideFlag, legacyOutputDidListenersThrowFlag) {\n    var e_1, _a, e_2, _b;\n    if (legacyTargetOverrideFlag === void 0) { legacyTargetOverrideFlag = false; }\n    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }\n    var clearTargets = false;\n    /**\n     * 1. Set event's dispatch flag.\n     */\n    event._dispatchFlag = true;\n    /**\n     * 2. Let targetOverride be target, if legacy target override flag is not\n     * given, and target's associated Document otherwise.\n     *\n     * _Note:_ legacy target override flag is only used by HTML and only when\n     * target is a Window object.\n     */\n    var targetOverride = target;\n    if (legacyTargetOverrideFlag) {\n        var doc = target._associatedDocument;\n        if (util_1.Guard.isDocumentNode(doc)) {\n            targetOverride = doc;\n        }\n    }\n    /**\n     * 3. Let activationTarget be null.\n     * 4. Let relatedTarget be the result of retargeting event's relatedTarget\n     * against target.\n     * 5. If target is not relatedTarget or target is event's relatedTarget,\n     * then:\n    */\n    var activationTarget = null;\n    var relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, target);\n    if (target !== relatedTarget || target === event._relatedTarget) {\n        /**\n         * 5.1. Let touchTargets be a new list.\n         * 5.2. For each touchTarget of event's touch target list, append the\n         * result of retargeting touchTarget against target to touchTargets.\n         * 5.3. Append to an event path with event, target, targetOverride,\n         * relatedTarget, touchTargets, and false.\n         * 5.4. Let isActivationEvent be true, if event is a MouseEvent object\n         * and event's type attribute is \"click\", and false otherwise.\n         * 5.5. If isActivationEvent is true and target has activation behavior,\n         * then set activationTarget to target.\n         * 5.6. Let slotable be target, if target is a slotable and is assigned,\n         * and null otherwise.\n         * 5.7. Let slot-in-closed-tree be false.\n         * 5.8. Let parent be the result of invoking target's get the parent with\n         * event.\n         */\n        var touchTargets = [];\n        try {\n            for (var _c = __values(event._touchTargetList), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var touchTarget = _d.value;\n                touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, target));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);\n        var isActivationEvent = (util_1.Guard.isMouseEvent(event) && event._type === \"click\");\n        if (isActivationEvent && target._activationBehavior !== undefined) {\n            activationTarget = target;\n        }\n        var slotable = (util_1.Guard.isSlotable(target) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(target)) ?\n            target : null;\n        var slotInClosedTree = false;\n        var parent = target._getTheParent(event);\n        /**\n         * 5.9. While parent is non-null:\n         */\n        while (parent !== null && util_1.Guard.isNode(parent)) {\n            /**\n             * 5.9.1 If slotable is non-null:\n             * 5.9.1.1. Assert: parent is a slot.\n             * 5.9.1.2. Set slotable to null.\n             * 5.9.1.3. If parent's root is a shadow root whose mode is \"closed\",\n             * then set slot-in-closed-tree to true.\n             */\n            if (slotable !== null) {\n                if (!util_1.Guard.isSlot(parent)) {\n                    throw new Error(\"Parent node of a slotable should be a slot.\");\n                }\n                slotable = null;\n                var root = TreeAlgorithm_1.tree_rootNode(parent, true);\n                if (util_1.Guard.isShadowRoot(root) && root._mode === \"closed\") {\n                    slotInClosedTree = true;\n                }\n            }\n            /**\n             * 5.9.2 If parent is a slotable and is assigned, then set slotable to\n             * parent.\n             * 5.9.3. Let relatedTarget be the result of retargeting event's\n             * relatedTarget against parent.\n             * 5.9.4. Let touchTargets be a new list.\n             * 5.9.4. For each touchTarget of event's touch target list, append the\n             * result of retargeting touchTarget against parent to touchTargets.\n             */\n            if (util_1.Guard.isSlotable(parent) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(parent)) {\n                slotable = parent;\n            }\n            relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, parent);\n            touchTargets = [];\n            try {\n                for (var _e = (e_2 = void 0, __values(event._touchTargetList)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var touchTarget = _f.value;\n                    touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, parent));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            /**\n             * 5.9.6. If parent is a Window object, or parent is a node and target's\n             * root is a shadow-including inclusive ancestor of parent, then:\n             */\n            if (util_1.Guard.isWindow(parent) || (util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) &&\n                TreeAlgorithm_1.tree_isAncestorOf(TreeAlgorithm_1.tree_rootNode(target, true), parent, true, true))) {\n                /**\n                 * 5.9.6.1. If isActivationEvent is true, event's bubbles attribute\n                 * is true, activationTarget is null, and parent has activation\n                 * behavior, then set activationTarget to parent.\n                 * 5.9.6.2. Append to an event path with event, parent, null,\n                 * relatedTarget, touchTargets, and slot-in-closed-tree.\n                 */\n                if (isActivationEvent && event._bubbles && activationTarget === null &&\n                    parent._activationBehavior) {\n                    activationTarget = parent;\n                }\n                event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n            }\n            else if (parent === relatedTarget) {\n                /**\n                 * 5.9.7. Otherwise, if parent is relatedTarget,\n                 * then set parent to null.\n                 */\n                parent = null;\n            }\n            else {\n                /**\n                 * 5.9.8. Otherwise, set target to parent and then:\n                 * 5.9.8.1. If isActivationEvent is true, activationTarget is null,\n                 * and target has activation behavior, then set activationTarget\n                 * to target.\n                 * 5.9.8.2. Append to an event path with event, parent, target,\n                 * relatedTarget, touchTargets, and slot-in-closed-tree.\n                 */\n                target = parent;\n                if (isActivationEvent && activationTarget === null &&\n                    target._activationBehavior) {\n                    activationTarget = target;\n                }\n                event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);\n            }\n            /**\n             * 5.9.9. If parent is non-null, then set parent to the result of\n             * invoking parent's get the parent with event.\n             * 5.9.10. Set slot-in-closed-tree to false.\n             */\n            if (parent !== null) {\n                parent = parent._getTheParent(event);\n            }\n            slotInClosedTree = false;\n        }\n        /**\n         * 5.10. Let clearTargetsStruct be the last struct in event's path whose\n         * shadow-adjusted target is non-null.\n         */\n        var clearTargetsStruct = null;\n        var path = event._path;\n        for (var i = path.length - 1; i >= 0; i--) {\n            var struct = path[i];\n            if (struct.shadowAdjustedTarget !== null) {\n                clearTargetsStruct = struct;\n                break;\n            }\n        }\n        /**\n         * 5.11. Let clearTargets be true if clearTargetsStruct's shadow-adjusted\n         * target, clearTargetsStruct's relatedTarget, or an EventTarget object\n         * in clearTargetsStruct's touch target list is a node and its root is\n         * a shadow root, and false otherwise.\n         */\n        if (clearTargetsStruct !== null) {\n            if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) &&\n                util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.shadowAdjustedTarget, true))) {\n                clearTargets = true;\n            }\n            else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) &&\n                util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.relatedTarget, true))) {\n                clearTargets = true;\n            }\n            else {\n                for (var j = 0; j < clearTargetsStruct.touchTargetList.length; j++) {\n                    var struct = clearTargetsStruct.touchTargetList[j];\n                    if (util_1.Guard.isNode(struct) &&\n                        util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(struct, true))) {\n                        clearTargets = true;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * 5.12. If activationTarget is non-null and activationTarget has\n         * legacy-pre-activation behavior, then run activationTarget's\n         * legacy-pre-activation behavior.\n         */\n        if (activationTarget !== null &&\n            activationTarget._legacyPreActivationBehavior !== undefined) {\n            activationTarget._legacyPreActivationBehavior(event);\n        }\n        /**\n         * 5.13. For each struct in event's path, in reverse order:\n         */\n        for (var i = path.length - 1; i >= 0; i--) {\n            var struct = path[i];\n            /**\n             * 5.13.1. If struct's shadow-adjusted target is non-null, then set\n             * event's eventPhase attribute to AT_TARGET.\n             * 5.13.2. Otherwise, set event's eventPhase attribute to\n             * CAPTURING_PHASE.\n             * 5.13.3. Invoke with struct, event, \"capturing\", and\n             * legacyOutputDidListenersThrowFlag if given.\n             */\n            if (struct.shadowAdjustedTarget !== null) {\n                event._eventPhase = interfaces_1.EventPhase.AtTarget;\n            }\n            else {\n                event._eventPhase = interfaces_1.EventPhase.Capturing;\n            }\n            event_invoke(struct, event, \"capturing\", legacyOutputDidListenersThrowFlag);\n        }\n        /**\n         * 5.14. For each struct in event's path\n         */\n        for (var i = 0; i < path.length; i++) {\n            var struct = path[i];\n            /**\n             * 5.14.1. If struct's shadow-adjusted target is non-null, then set\n             * event's eventPhase attribute to AT_TARGET.\n             * 5.14.2. Otherwise:\n             * 5.14.2.1. If event's bubbles attribute is false, then continue.\n             * 5.14.2.2. Set event's eventPhase attribute to BUBBLING_PHASE.\n             * 5.14.3. Invoke with struct, event, \"bubbling\", and\n             * legacyOutputDidListenersThrowFlag if given.\n             */\n            if (struct.shadowAdjustedTarget !== null) {\n                event._eventPhase = interfaces_1.EventPhase.AtTarget;\n            }\n            else {\n                if (!event._bubbles)\n                    continue;\n                event._eventPhase = interfaces_1.EventPhase.Bubbling;\n            }\n            event_invoke(struct, event, \"bubbling\", legacyOutputDidListenersThrowFlag);\n        }\n    }\n    /**\n     * 6. Set event's eventPhase attribute to NONE.\n     * 7. Set event's currentTarget attribute to null.\n     * 8. Set event's path to the empty list.\n     * 9. Unset event's dispatch flag, stop propagation flag, and stop\n     * immediate propagation flag.\n     */\n    event._eventPhase = interfaces_1.EventPhase.None;\n    event._currentTarget = null;\n    event._path = [];\n    event._dispatchFlag = false;\n    event._stopPropagationFlag = false;\n    event._stopImmediatePropagationFlag = false;\n    /**\n     * 10. If clearTargets, then:\n     * 10.1. Set event's target to null.\n     * 10.2. Set event's relatedTarget to null.\n     * 10.3. Set event's touch target list to the empty list.\n     */\n    if (clearTargets) {\n        event._target = null;\n        event._relatedTarget = null;\n        event._touchTargetList = [];\n    }\n    /**\n     * 11. If activationTarget is non-null, then:\n     * 11.1. If event's canceled flag is unset, then run activationTarget's\n     * activation behavior with event.\n     * 11.2. Otherwise, if activationTarget has legacy-canceled-activation\n     * behavior, then run activationTarget's legacy-canceled-activation\n     * behavior.\n     */\n    if (activationTarget !== null) {\n        if (!event._canceledFlag && activationTarget._activationBehavior !== undefined) {\n            activationTarget._activationBehavior(event);\n        }\n        else if (activationTarget._legacyCanceledActivationBehavior !== undefined) {\n            activationTarget._legacyCanceledActivationBehavior(event);\n        }\n    }\n    /**\n     * 12. Return false if event's canceled flag is set, and true otherwise.\n     */\n    return !event._canceledFlag;\n}\nexports.event_dispatch = event_dispatch;\n/**\n * Appends a new struct to an event's path.\n *\n * @param event - an event\n * @param invocationTarget - the target of the invocation\n * @param shadowAdjustedTarget - shadow-root adjusted event target\n * @param relatedTarget - related event target\n * @param touchTargets - a list of touch targets\n * @param slotInClosedTree - if the target's parent is a closed shadow root\n */\nfunction event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {\n    /**\n     * 1. Let invocationTargetInShadowTree be false.\n     * 2. If invocationTarget is a node and its root is a shadow root, then\n     * set invocationTargetInShadowTree to true.\n     */\n    var invocationTargetInShadowTree = false;\n    if (util_1.Guard.isNode(invocationTarget) &&\n        util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(invocationTarget))) {\n        invocationTargetInShadowTree = true;\n    }\n    /**\n     * 3. Let root-of-closed-tree be false.\n     * 4. If invocationTarget is a shadow root whose mode is \"closed\", then\n     * set root-of-closed-tree to true.\n     */\n    var rootOfClosedTree = false;\n    if (util_1.Guard.isShadowRoot(invocationTarget) &&\n        invocationTarget._mode === \"closed\") {\n        rootOfClosedTree = true;\n    }\n    /**\n     * 5. Append a new struct to event's path whose invocation target is\n     * invocationTarget, invocation-target-in-shadow-tree is\n     * invocationTargetInShadowTree, shadow-adjusted target is\n     * shadowAdjustedTarget, relatedTarget is relatedTarget,\n     * touch target list is touchTargets, root-of-closed-tree is\n     * root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.\n     */\n    event._path.push({\n        invocationTarget: invocationTarget,\n        invocationTargetInShadowTree: invocationTargetInShadowTree,\n        shadowAdjustedTarget: shadowAdjustedTarget,\n        relatedTarget: relatedTarget,\n        touchTargetList: touchTargets,\n        rootOfClosedTree: rootOfClosedTree,\n        slotInClosedTree: slotInClosedTree\n    });\n}\nexports.event_appendToAnEventPath = event_appendToAnEventPath;\n/**\n * Invokes an event.\n *\n * @param struct - a struct defining event's path\n * @param event - the event to invoke\n * @param phase - event phase\n * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns\n * whether the event listener's callback threw an exception\n */\nfunction event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag) {\n    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }\n    /**\n     * 1. Set event's target to the shadow-adjusted target of the last struct\n     * in event's path, that is either struct or preceding struct, whose\n     * shadow-adjusted target is non-null.\n     */\n    var path = event._path;\n    var index = -1;\n    for (var i = 0; i < path.length; i++) {\n        if (path[i] === struct) {\n            index = i;\n            break;\n        }\n    }\n    if (index !== -1) {\n        var item = path[index];\n        if (item.shadowAdjustedTarget !== null) {\n            event._target = item.shadowAdjustedTarget;\n        }\n        else if (index > 0) {\n            item = path[index - 1];\n            if (item.shadowAdjustedTarget !== null) {\n                event._target = item.shadowAdjustedTarget;\n            }\n        }\n    }\n    /**\n     * 2. Set event's relatedTarget to struct's relatedTarget.\n     * 3. Set event's touch target list to struct's touch target list.\n     * 4. If event's stop propagation flag is set, then return.\n     * 5. Initialize event's currentTarget attribute to struct's invocation\n     * target.\n     * 6. Let listeners be a clone of event's currentTarget attribute value's\n     * event listener list.\n     *\n     * _Note:_ This avoids event listeners added after this point from being\n     * run. Note that removal still has an effect due to the removed field.\n     */\n    event._relatedTarget = struct.relatedTarget;\n    event._touchTargetList = struct.touchTargetList;\n    if (event._stopPropagationFlag)\n        return;\n    event._currentTarget = struct.invocationTarget;\n    var currentTarget = event._currentTarget;\n    var targetListeners = currentTarget._eventListenerList;\n    var listeners = new (Array.bind.apply(Array, __spread([void 0], targetListeners)))();\n    /**\n     * 7. Let found be the result of running inner invoke with event, listeners,\n     * phase, and legacyOutputDidListenersThrowFlag if given.\n     */\n    var found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);\n    /**\n     * 8. If found is false and event's isTrusted attribute is true, then:\n     */\n    if (!found && event._isTrusted) {\n        /**\n         * 8.1. Let originalEventType be event's type attribute value.\n         * 8.2. If event's type attribute value is a match for any of the strings\n         * in the first column in the following table, set event's type attribute\n         * value to the string in the second column on the same row as the matching\n         * string, and return otherwise.\n         *\n         * Event type           | Legacy event type\n         * -------------------------------------------------\n         * \"animationend\"       | \"webkitAnimationEnd\"\n         * \"animationiteration\" | \"webkitAnimationIteration\"\n         * \"animationstart\"     | \"webkitAnimationStart\"\n         * \"transitionend\"      | \"webkitTransitionEnd\"\n         */\n        var originalEventType = event._type;\n        if (originalEventType === \"animationend\") {\n            event._type = \"webkitAnimationEnd\";\n        }\n        else if (originalEventType === \"animationiteration\") {\n            event._type = \"webkitAnimationIteration\";\n        }\n        else if (originalEventType === \"animationstart\") {\n            event._type = \"webkitAnimationStart\";\n        }\n        else if (originalEventType === \"transitionend\") {\n            event._type = \"webkitTransitionEnd\";\n        }\n        /**\n         * 8.3. Inner invoke with event, listeners, phase, and\n         * legacyOutputDidListenersThrowFlag if given.\n         * 8.4. Set event's type attribute value to originalEventType.\n         */\n        event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);\n        event._type = originalEventType;\n    }\n}\nexports.event_invoke = event_invoke;\n/**\n * Invokes an event.\n *\n * @param event - the event to invoke\n * @param listeners - event listeners\n * @param phase - event phase\n * @param struct - a struct defining event's path\n * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns\n * whether the event listener's callback threw an exception\n */\nfunction event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag) {\n    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }\n    /**\n     * 1. Let found be false.\n     * 2. For each listener in listeners, whose removed is false:\n     */\n    var found = false;\n    for (var i = 0; i < listeners.length; i++) {\n        var listener = listeners[i];\n        if (!listener.removed) {\n            /**\n             * 2.1. If event's type attribute value is not listener's type, then\n             * continue.\n             * 2.2. Set found to true.\n             * 2.3. If phase is \"capturing\" and listener's capture is false, then\n             * continue.\n             * 2.4. If phase is \"bubbling\" and listener's capture is true, then\n             * continue.\n             */\n            if (event._type !== listener.type)\n                continue;\n            found = true;\n            if (phase === \"capturing\" && !listener.capture)\n                continue;\n            if (phase === \"bubbling\" && listener.capture)\n                continue;\n            /**\n             * 2.5. If listener's once is true, then remove listener from event's\n             * currentTarget attribute value's event listener list.\n             */\n            if (listener.once && event._currentTarget !== null) {\n                var impl = event._currentTarget;\n                var index = -1;\n                for (var i_1 = 0; i_1 < impl._eventListenerList.length; i_1++) {\n                    if (impl._eventListenerList[i_1] === listener) {\n                        index = i_1;\n                        break;\n                    }\n                }\n                if (index !== -1) {\n                    impl._eventListenerList.splice(index, 1);\n                }\n            }\n            /**\n             * TODO: Implement realms\n             *\n             * 2.6. Let global be listener callback's associated Realm's global\n             * object.\n             */\n            var globalObject = undefined;\n            /**\n             * 2.7. Let currentEvent be undefined.\n             * 2.8. If global is a Window object, then:\n             * 2.8.1. Set currentEvent to global's current event.\n             * 2.8.2. If struct's invocation-target-in-shadow-tree is false, then\n             * set global's current event to event.\n             */\n            var currentEvent = undefined;\n            if (util_1.Guard.isWindow(globalObject)) {\n                currentEvent = globalObject._currentEvent;\n                if (struct.invocationTargetInShadowTree === false) {\n                    globalObject._currentEvent = event;\n                }\n            }\n            /**\n             * 2.9. If listener's passive is true, then set event's in passive\n             * listener flag.\n             * 2.10. Call a user object's operation with listener's callback,\n             * \"handleEvent\", « event », and event's currentTarget attribute value.\n             */\n            if (listener.passive)\n                event._inPassiveListenerFlag = true;\n            try {\n                listener.callback.handleEvent.call(event._currentTarget, event);\n            }\n            catch (err) {\n                /**\n                 * If this throws an exception, then:\n                 * 2.10.1. Report the exception.\n                 * 2.10.2. Set legacyOutputDidListenersThrowFlag if given.\n                 *\n                 * _Note:_ The legacyOutputDidListenersThrowFlag is only used by\n                 * Indexed Database API.\n                 * TODO: Report the exception\n                 * See: https://html.spec.whatwg.org/multipage/webappapis.html#runtime-script-errors-in-documents\n                 */\n                legacyOutputDidListenersThrowFlag.value = true;\n            }\n            /**\n             * 2.11. Unset event's in passive listener flag.\n             */\n            if (listener.passive)\n                event._inPassiveListenerFlag = false;\n            /**\n             * 2.12. If global is a Window object, then set global's current event\n             * to currentEvent.\n             */\n            if (util_1.Guard.isWindow(globalObject)) {\n                globalObject._currentEvent = currentEvent;\n            }\n            /**\n             * 2.13. If event's stop immediate propagation flag is set, then return\n             * found.\n             */\n            if (event._stopImmediatePropagationFlag)\n                return found;\n        }\n    }\n    /**\n     * 3. Return found.\n     */\n    return found;\n}\nexports.event_innerInvoke = event_innerInvoke;\n/**\n * Fires an event at target.\n * @param e - event name\n * @param target - event target\n * @param eventConstructor - an event constructor, with a description of how\n * IDL attributes are to be initialized\n * @param idlAttributes - a dictionary describing how IDL attributes are\n * to be initialized\n * @param legacyTargetOverrideFlag - legacy target override flag\n */\nfunction event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {\n    /**\n     * 1. If eventConstructor is not given, then let eventConstructor be Event.\n     */\n    if (eventConstructor === undefined) {\n        eventConstructor = EventImpl_1.EventImpl;\n    }\n    /**\n     * 2. Let event be the result of creating an event given eventConstructor,\n     * in the relevant Realm of target.\n     */\n    var event = event_createAnEvent(eventConstructor);\n    /**\n     * 3. Initialize event’s type attribute to e.\n     */\n    event._type = e;\n    /**\n     * 4. Initialize any other IDL attributes of event as described in the\n     * invocation of this algorithm.\n     * _Note:_ This also allows for the isTrusted attribute to be set to false.\n     */\n    if (idlAttributes) {\n        for (var key in idlAttributes) {\n            var idlObj = event;\n            idlObj[key] = idlAttributes[key];\n        }\n    }\n    /**\n     * 5. Return the result of dispatching event at target, with legacy target\n     * override flag set if set.\n     */\n    return event_dispatch(event, target, legacyTargetOverrideFlag);\n}\nexports.event_fireAnEvent = event_fireAnEvent;\n/**\n * Creates an event.\n *\n * @param eventInterface - the name of the event interface\n */\nfunction event_createLegacyEvent(eventInterface) {\n    /**\n     * 1. Let constructor be null.\n     */\n    var constructor = null;\n    /**\n     * TODO: Implement in HTML DOM\n     * 2. If interface is an ASCII case-insensitive match for any of the strings\n     * in the first column in the following table, then set constructor to the\n     * interface in the second column on the same row as the matching string:\n     *\n     * String | Interface\n     * -------|----------\n     * \"beforeunloadevent\" | BeforeUnloadEvent\n     * \"compositionevent\" | CompositionEvent\n     * \"customevent\" | CustomEvent\n     * \"devicemotionevent\" | DeviceMotionEvent\n     * \"deviceorientationevent\" | DeviceOrientationEvent\n     * \"dragevent\" | DragEvent\n     * \"event\" | Event\n     * \"events\" | Event\n     * \"focusevent\" | FocusEvent\n     * \"hashchangeevent\" | HashChangeEvent\n     * \"htmlevents\" | Event\n     * \"keyboardevent\" | KeyboardEvent\n     * \"messageevent\" | MessageEvent\n     * \"mouseevent\" | MouseEvent\n     * \"mouseevents\" |\n     * \"storageevent\" | StorageEvent\n     * \"svgevents\" | Event\n     * \"textevent\" | CompositionEvent\n     * \"touchevent\" | TouchEvent\n     * \"uievent\" | UIEvent\n     * \"uievents\" | UIEvent\n     */\n    switch (eventInterface.toLowerCase()) {\n        case \"beforeunloadevent\":\n            break;\n        case \"compositionevent\":\n            break;\n        case \"customevent\":\n            constructor = CustomEventImpl_1.CustomEventImpl;\n            break;\n        case \"devicemotionevent\":\n            break;\n        case \"deviceorientationevent\":\n            break;\n        case \"dragevent\":\n            break;\n        case \"event\":\n        case \"events\":\n            constructor = EventImpl_1.EventImpl;\n            break;\n        case \"focusevent\":\n            break;\n        case \"hashchangeevent\":\n            break;\n        case \"htmlevents\":\n            break;\n        case \"keyboardevent\":\n            break;\n        case \"messageevent\":\n            break;\n        case \"mouseevent\":\n            break;\n        case \"mouseevents\":\n            break;\n        case \"storageevent\":\n            break;\n        case \"svgevents\":\n            break;\n        case \"textevent\":\n            break;\n        case \"touchevent\":\n            break;\n        case \"uievent\":\n            break;\n        case \"uievents\":\n            break;\n    }\n    /**\n     * 3. If constructor is null, then throw a \"NotSupportedError\" DOMException.\n     */\n    if (constructor === null) {\n        throw new DOMException_1.NotSupportedError(\"Event constructor not found for interface \" + eventInterface + \".\");\n    }\n    /**\n     * 4. If the interface indicated by constructor is not exposed on the\n     * relevant global object of the context object, then throw a\n     * \"NotSupportedError\" DOMException.\n     * _Note:_ Typically user agents disable support for touch events in some\n     * configurations, in which case this clause would be triggered for the\n     * interface TouchEvent.\n     */\n    // TODO: Implement realms\n    /**\n     * 5. Let event be the result of creating an event given constructor.\n     * 6. Initialize event’s type attribute to the empty string.\n     * 7. Initialize event’s timeStamp attribute to a DOMHighResTimeStamp\n     * representing the high resolution time from the time origin to now.\n     * 8. Initialize event’s isTrusted attribute to false.\n     * 9. Unset event’s initialized flag.\n     */\n    var event = new constructor(\"\");\n    event._type = \"\";\n    event._timeStamp = new Date().getTime();\n    event._isTrusted = false;\n    event._initializedFlag = false;\n    /**\n     * 10. Return event.\n     */\n    return event;\n}\nexports.event_createLegacyEvent = event_createLegacyEvent;\n/**\n * Getter of an event handler IDL attribute.\n *\n * @param eventTarget - event target\n * @param name - event name\n */\nfunction event_getterEventHandlerIDLAttribute(thisObj, name) {\n    /**\n     * 1. Let eventTarget be the result of determining the target of an event\n     * handler given this object and name.\n     * 2. If eventTarget is null, then return null.\n     * 3. Return the result of getting the current value of the event handler\n     * given eventTarget and name.\n     */\n    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);\n    if (eventTarget === null)\n        return null;\n    return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);\n}\nexports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;\n/**\n * Setter of an event handler IDL attribute.\n *\n * @param eventTarget - event target\n * @param name - event name\n * @param value - event handler\n */\nfunction event_setterEventHandlerIDLAttribute(thisObj, name, value) {\n    /**\n     * 1. Let eventTarget be the result of determining the target of an event\n     * handler given this object and name.\n     * 2. If eventTarget is null, then return.\n     * 3. If the given value is null, then deactivate an event handler given\n     * eventTarget and name.\n     * 4. Otherwise:\n     * 4.1. Let handlerMap be eventTarget's event handler map.\n     * 4.2. Let eventHandler be handlerMap[name].\n     * 4.3. Set eventHandler's value to the given value.\n     * 4.4. Activate an event handler given eventTarget and name.\n     */\n    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);\n    if (eventTarget === null)\n        return;\n    if (value === null) {\n        event_deactivateAnEventHandler(eventTarget, name);\n    }\n    else {\n        var handlerMap = eventTarget._eventHandlerMap;\n        var eventHandler = handlerMap[\"onabort\"];\n        if (eventHandler !== undefined) {\n            eventHandler.value = value;\n        }\n        event_activateAnEventHandler(eventTarget, name);\n    }\n}\nexports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;\n/**\n * Determines the target of an event handler.\n *\n * @param eventTarget - event target\n * @param name - event name\n */\nfunction event_determineTheTargetOfAnEventHandler(eventTarget, name) {\n    // TODO: Implement in HTML DOM\n    return null;\n}\nexports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;\n/**\n * Gets the current value of an event handler.\n *\n * @param eventTarget - event target\n * @param name - event name\n */\nfunction event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {\n    // TODO: Implement in HTML DOM\n    return null;\n}\nexports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;\n/**\n * Activates an event handler.\n *\n * @param eventTarget - event target\n * @param name - event name\n */\nfunction event_activateAnEventHandler(eventTarget, name) {\n    // TODO: Implement in HTML DOM\n}\nexports.event_activateAnEventHandler = event_activateAnEventHandler;\n/**\n * Deactivates an event handler.\n *\n * @param eventTarget - event target\n * @param name - event name\n */\nfunction event_deactivateAnEventHandler(eventTarget, name) {\n    // TODO: Implement in HTML DOM\n}\nexports.event_deactivateAnEventHandler = event_deactivateAnEventHandler;\n//# sourceMappingURL=EventAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Flattens the given options argument.\n *\n * @param options - options argument\n */\nfunction eventTarget_flatten(options) {\n    /**\n     * 1. If options is a boolean, then return options.\n     * 2. Return options’s capture.\n     */\n    if (util_1.isBoolean(options)) {\n        return options;\n    }\n    else {\n        return options.capture || false;\n    }\n}\nexports.eventTarget_flatten = eventTarget_flatten;\n/**\n * Flattens the given options argument.\n *\n * @param options - options argument\n */\nfunction eventTarget_flattenMore(options) {\n    /**\n     * 1. Let capture be the result of flattening options.\n     * 2. Let once and passive be false.\n     * 3. If options is a dictionary, then set passive to options’s passive and\n     * once to options’s once.\n     * 4. Return capture, passive, and once.\n     */\n    var capture = eventTarget_flatten(options);\n    var once = false;\n    var passive = false;\n    if (!util_1.isBoolean(options)) {\n        once = options.once || false;\n        passive = options.passive || false;\n    }\n    return [capture, passive, once];\n}\nexports.eventTarget_flattenMore = eventTarget_flattenMore;\n/**\n * Adds a new event listener.\n *\n * @param eventTarget - event target\n * @param listener - event listener\n */\nfunction eventTarget_addEventListener(eventTarget, listener) {\n    /**\n     * 1. If eventTarget is a ServiceWorkerGlobalScope object, its service\n     * worker’s script resource’s has ever been evaluated flag is set, and\n     * listener’s type matches the type attribute value of any of the service\n     * worker events, then report a warning to the console that this might not\n     * give the expected results. [SERVICE-WORKERS]\n     */\n    // TODO: service worker\n    /**\n     * 2. If listener’s callback is null, then return.\n     */\n    if (listener.callback === null)\n        return;\n    /**\n     * 3. If eventTarget’s event listener list does not contain an event listener\n     * whose type is listener’s type, callback is listener’s callback, and capture\n     * is listener’s capture, then append listener to eventTarget’s event listener\n     * list.\n     */\n    for (var i = 0; i < eventTarget._eventListenerList.length; i++) {\n        var entry = eventTarget._eventListenerList[i];\n        if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent\n            && entry.capture === listener.capture) {\n            return;\n        }\n    }\n    eventTarget._eventListenerList.push(listener);\n}\nexports.eventTarget_addEventListener = eventTarget_addEventListener;\n/**\n * Removes an event listener.\n *\n * @param eventTarget - event target\n * @param listener - event listener\n */\nfunction eventTarget_removeEventListener(eventTarget, listener, index) {\n    /**\n     * 1. If eventTarget is a ServiceWorkerGlobalScope object and its service\n     * worker’s set of event types to handle contains type, then report a\n     * warning to the console that this might not give the expected results.\n     * [SERVICE-WORKERS]\n     */\n    // TODO: service worker\n    /**\n     * 2. Set listener’s removed to true and remove listener from eventTarget’s\n     * event listener list.\n     */\n    listener.removed = true;\n    eventTarget._eventListenerList.splice(index, 1);\n}\nexports.eventTarget_removeEventListener = eventTarget_removeEventListener;\n/**\n * Removes all event listeners.\n *\n * @param eventTarget - event target\n */\nfunction eventTarget_removeAllEventListeners(eventTarget) {\n    /**\n     * To remove all event listeners, given an EventTarget object eventTarget,\n     * for each listener of eventTarget’s event listener list, remove an event\n     * listener with eventTarget and listener.\n     */\n    var e_1, _a;\n    try {\n        for (var _b = __values(eventTarget._eventListenerList), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var e = _c.value;\n            e.removed = true;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    eventTarget._eventListenerList.length = 0;\n}\nexports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;\n//# sourceMappingURL=EventTargetAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar util_1 = require(\"../util\");\nvar util_2 = require(\"@oozcitak/util\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar CustomElementAlgorithm_1 = require(\"./CustomElementAlgorithm\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar NodeIteratorAlgorithm_1 = require(\"./NodeIteratorAlgorithm\");\nvar ShadowTreeAlgorithm_1 = require(\"./ShadowTreeAlgorithm\");\nvar MutationObserverAlgorithm_1 = require(\"./MutationObserverAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\nvar DocumentAlgorithm_1 = require(\"./DocumentAlgorithm\");\n/**\n * Ensures pre-insertion validity of a node into a parent before a\n * child.\n *\n * @param node - node to insert\n * @param parent - parent node to receive node\n * @param child - child node to insert node before\n */\nfunction mutation_ensurePreInsertionValidity(node, parent, child) {\n    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\n    var parentNodeType = parent._nodeType;\n    var nodeNodeType = node._nodeType;\n    var childNodeType = child ? child._nodeType : null;\n    /**\n     * 1. If parent is not a Document, DocumentFragment, or Element node,\n     * throw a \"HierarchyRequestError\" DOMException.\n     */\n    if (parentNodeType !== interfaces_1.NodeType.Document &&\n        parentNodeType !== interfaces_1.NodeType.DocumentFragment &&\n        parentNodeType !== interfaces_1.NodeType.Element)\n        throw new DOMException_1.HierarchyRequestError(\"Only document, document fragment and element nodes can contain child nodes. Parent node is \" + parent.nodeName + \".\");\n    /**\n     * 2. If node is a host-including inclusive ancestor of parent, throw a\n     * \"HierarchyRequestError\" DOMException.\n     */\n    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))\n        throw new DOMException_1.HierarchyRequestError(\"The node to be inserted cannot be an inclusive ancestor of parent node. Node is \" + node.nodeName + \", parent node is \" + parent.nodeName + \".\");\n    /**\n     * 3. If child is not null and its parent is not parent, then throw a\n     * \"NotFoundError\" DOMException.\n     */\n    if (child !== null && child._parent !== parent)\n        throw new DOMException_1.NotFoundError(\"The reference child node cannot be found under parent node. Child node is \" + child.nodeName + \", parent node is \" + parent.nodeName + \".\");\n    /**\n     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,\n     * ProcessingInstruction, or Comment node, throw a \"HierarchyRequestError\"\n     * DOMException.\n     */\n    if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment &&\n        nodeNodeType !== interfaces_1.NodeType.DocumentType &&\n        nodeNodeType !== interfaces_1.NodeType.Element &&\n        nodeNodeType !== interfaces_1.NodeType.Text &&\n        nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction &&\n        nodeNodeType !== interfaces_1.NodeType.CData &&\n        nodeNodeType !== interfaces_1.NodeType.Comment)\n        throw new DOMException_1.HierarchyRequestError(\"Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is \" + node.nodeName + \".\");\n    /**\n     * 5. If either node is a Text node and parent is a document, or node is a\n     * doctype and parent is not a document, throw a \"HierarchyRequestError\"\n     * DOMException.\n     */\n    if (nodeNodeType === interfaces_1.NodeType.Text &&\n        parentNodeType === interfaces_1.NodeType.Document)\n        throw new DOMException_1.HierarchyRequestError(\"Cannot insert a text node as a child of a document node. Node is \" + node.nodeName + \".\");\n    if (nodeNodeType === interfaces_1.NodeType.DocumentType &&\n        parentNodeType !== interfaces_1.NodeType.Document)\n        throw new DOMException_1.HierarchyRequestError(\"A document type node can only be inserted under a document node. Parent node is \" + parent.nodeName + \".\");\n    /**\n     * 6. If parent is a document, and any of the statements below, switched on\n     * node, are true, throw a \"HierarchyRequestError\" DOMException.\n     * - DocumentFragment node\n     * If node has more than one element child or has a Text node child.\n     * Otherwise, if node has one element child and either parent has an element\n     * child, child is a doctype, or child is not null and a doctype is\n     * following child.\n     * - element\n     * parent has an element child, child is a doctype, or child is not null and\n     * a doctype is following child.\n     * - doctype\n     * parent has a doctype child, child is non-null and an element is preceding\n     * child, or child is null and parent has an element child.\n     */\n    if (parentNodeType === interfaces_1.NodeType.Document) {\n        if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {\n            var eleCount = 0;\n            try {\n                for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var childNode = _f.value;\n                    if (childNode._nodeType === interfaces_1.NodeType.Element)\n                        eleCount++;\n                    else if (childNode._nodeType === interfaces_1.NodeType.Text)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert text a node as a child of a document node. Node is \" + childNode.nodeName + \".\");\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (eleCount > 1) {\n                throw new DOMException_1.HierarchyRequestError(\"A document node can only have one document element node. Document fragment to be inserted has \" + eleCount + \" element nodes.\");\n            }\n            else if (eleCount === 1) {\n                try {\n                    for (var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        var ele = _h.value;\n                        if (ele._nodeType === interfaces_1.NodeType.Element)\n                            throw new DOMException_1.HierarchyRequestError(\"The document node already has a document element node.\");\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                if (child) {\n                    if (childNodeType === interfaces_1.NodeType.DocumentType)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert an element node before a document type node.\");\n                    var doctypeChild = child._nextSibling;\n                    while (doctypeChild) {\n                        if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)\n                            throw new DOMException_1.HierarchyRequestError(\"Cannot insert an element node before a document type node.\");\n                        doctypeChild = doctypeChild._nextSibling;\n                    }\n                }\n            }\n        }\n        else if (nodeNodeType === interfaces_1.NodeType.Element) {\n            try {\n                for (var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()) {\n                    var ele = _k.value;\n                    if (ele._nodeType === interfaces_1.NodeType.Element)\n                        throw new DOMException_1.HierarchyRequestError(\"Document already has a document element node. Node is \" + node.nodeName + \".\");\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            if (child) {\n                if (childNodeType === interfaces_1.NodeType.DocumentType)\n                    throw new DOMException_1.HierarchyRequestError(\"Cannot insert an element node before a document type node. Node is \" + node.nodeName + \".\");\n                var doctypeChild = child._nextSibling;\n                while (doctypeChild) {\n                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert an element node before a document type node. Node is \" + node.nodeName + \".\");\n                    doctypeChild = doctypeChild._nextSibling;\n                }\n            }\n        }\n        else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {\n            try {\n                for (var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()) {\n                    var ele = _m.value;\n                    if (ele._nodeType === interfaces_1.NodeType.DocumentType)\n                        throw new DOMException_1.HierarchyRequestError(\"Document already has a document type node. Node is \" + node.nodeName + \".\");\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            if (child) {\n                var elementChild = child._previousSibling;\n                while (elementChild) {\n                    if (elementChild._nodeType === interfaces_1.NodeType.Element)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert a document type node before an element node. Node is \" + node.nodeName + \".\");\n                    elementChild = elementChild._previousSibling;\n                }\n            }\n            else {\n                var elementChild = parent._firstChild;\n                while (elementChild) {\n                    if (elementChild._nodeType === interfaces_1.NodeType.Element)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert a document type node before an element node. Node is \" + node.nodeName + \".\");\n                    elementChild = elementChild._nextSibling;\n                }\n            }\n        }\n    }\n}\nexports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;\n/**\n * Ensures pre-insertion validity of a node into a parent before a\n * child, then adopts the node to the tree and inserts it.\n *\n * @param node - node to insert\n * @param parent - parent node to receive node\n * @param child - child node to insert node before\n */\nfunction mutation_preInsert(node, parent, child) {\n    /**\n     * 1. Ensure pre-insertion validity of node into parent before child.\n     * 2. Let reference child be child.\n     * 3. If reference child is node, set it to node’s next sibling.\n     * 4. Adopt node into parent’s node document.\n     * 5. Insert node into parent before reference child.\n     * 6. Return node.\n     */\n    mutation_ensurePreInsertionValidity(node, parent, child);\n    var referenceChild = child;\n    if (referenceChild === node)\n        referenceChild = node._nextSibling;\n    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);\n    mutation_insert(node, parent, referenceChild);\n    return node;\n}\nexports.mutation_preInsert = mutation_preInsert;\n/**\n * Inserts a node into a parent node before the given child node.\n *\n * @param node - node to insert\n * @param parent - parent node to receive node\n * @param child - child node to insert node before\n * @param suppressObservers - whether to notify observers\n */\nfunction mutation_insert(node, parent, child, suppressObservers) {\n    var e_5, _a;\n    // Optimized common case\n    if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {\n        mutation_insert_single(node, parent, suppressObservers);\n        return;\n    }\n    /**\n     * 1. Let count be the number of children of node if it is a\n     * DocumentFragment node, and one otherwise.\n     */\n    var count = (node._nodeType === interfaces_1.NodeType.DocumentFragment ?\n        node._children.size : 1);\n    /**\n     * 2. If child is non-null, then:\n     */\n    if (child !== null) {\n        /**\n         * 2.1. For each live range whose start node is parent and start\n         * offset is greater than child's index, increase its start\n         * offset by count.\n         * 2.2. For each live range whose end node is parent and end\n         * offset is greater than child's index, increase its end\n         * offset by count.\n         */\n        if (DOMImpl_1.dom.rangeList.size !== 0) {\n            var index_1 = TreeAlgorithm_1.tree_index(child);\n            try {\n                for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var range = _c.value;\n                    if (range._start[0] === parent && range._start[1] > index_1) {\n                        range._start[1] += count;\n                    }\n                    if (range._end[0] === parent && range._end[1] > index_1) {\n                        range._end[1] += count;\n                    }\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n        }\n    }\n    /**\n     * 3. Let nodes be node’s children, if node is a DocumentFragment node;\n     * otherwise « node ».\n     */\n    var nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new (Array.bind.apply(Array, __spread([void 0], node._children)))() : [node];\n    /**\n     * 4. If node is a DocumentFragment node, remove its children with the\n     * suppress observers flag set.\n     */\n    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {\n        while (node._firstChild) {\n            mutation_remove(node._firstChild, node, true);\n        }\n    }\n    /**\n     * 5. If node is a DocumentFragment node, then queue a tree mutation record\n     * for node with « », nodes, null, and null.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {\n            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(node, [], nodes, null, null);\n        }\n    }\n    /**\n     * 6. Let previousSibling be child’s previous sibling or parent’s last\n     * child if child is null.\n     */\n    var previousSibling = (child ? child._previousSibling : parent._lastChild);\n    var index = child === null ? -1 : TreeAlgorithm_1.tree_index(child);\n    /**\n     * 7. For each node in nodes, in tree order:\n     */\n    for (var i = 0; i < nodes.length; i++) {\n        var node_1 = nodes[i];\n        if (util_1.Guard.isElementNode(node_1)) {\n            // set document element node\n            if (util_1.Guard.isDocumentNode(parent)) {\n                parent._documentElement = node_1;\n            }\n            // mark that the document has namespaces\n            if (!node_1._nodeDocument._hasNamespaces && (node_1._namespace !== null ||\n                node_1._namespacePrefix !== null)) {\n                node_1._nodeDocument._hasNamespaces = true;\n            }\n        }\n        /**\n         * 7.1. If child is null, then append node to parent’s children.\n         * 7.2. Otherwise, insert node into parent’s children before child’s\n         * index.\n         */\n        node_1._parent = parent;\n        if (child === null) {\n            infra_1.set.append(parent._children, node_1);\n        }\n        else {\n            infra_1.set.insert(parent._children, node_1, index);\n            index++;\n        }\n        // assign siblings and children for quick lookups\n        if (parent._firstChild === null) {\n            node_1._previousSibling = null;\n            node_1._nextSibling = null;\n            parent._firstChild = node_1;\n            parent._lastChild = node_1;\n        }\n        else {\n            var prev = (child ? child._previousSibling : parent._lastChild);\n            var next = (child ? child : null);\n            node_1._previousSibling = prev;\n            node_1._nextSibling = next;\n            if (prev)\n                prev._nextSibling = node_1;\n            if (next)\n                next._previousSibling = node_1;\n            if (!prev)\n                parent._firstChild = node_1;\n            if (!next)\n                parent._lastChild = node_1;\n        }\n        /**\n         * 7.3. If parent is a shadow host and node is a slotable, then\n         * assign a slot for node.\n         */\n        if (DOMImpl_1.dom.features.slots) {\n            if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node_1)) {\n                ShadowTreeAlgorithm_1.shadowTree_assignASlot(node_1);\n            }\n        }\n        /**\n         * 7.4. If node is a Text node, run the child text content change\n         * steps for parent.\n         */\n        if (DOMImpl_1.dom.features.steps) {\n            if (util_1.Guard.isTextNode(node_1)) {\n                DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);\n            }\n        }\n        /**\n         * 7.5. If parent's root is a shadow root, and parent is a slot\n         * whose assigned nodes is the empty list, then run signal\n         * a slot change for parent.\n         */\n        if (DOMImpl_1.dom.features.slots) {\n            if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&\n                util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {\n                ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);\n            }\n        }\n        /**\n         * 7.6. Run assign slotables for a tree with node's root.\n         */\n        if (DOMImpl_1.dom.features.slots) {\n            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node_1));\n        }\n        /**\n         * 7.7. For each shadow-including inclusive descendant\n         * inclusiveDescendant of node, in shadow-including tree\n         * order:\n         */\n        var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node_1, true, true);\n        while (inclusiveDescendant !== null) {\n            /**\n             * 7.7.1. Run the insertion steps with inclusiveDescendant.\n             */\n            if (DOMImpl_1.dom.features.steps) {\n                DOMAlgorithm_1.dom_runInsertionSteps(inclusiveDescendant);\n            }\n            if (DOMImpl_1.dom.features.customElements) {\n                /**\n                 * 7.7.2. If inclusiveDescendant is connected, then:\n                 */\n                if (util_1.Guard.isElementNode(inclusiveDescendant) &&\n                    ShadowTreeAlgorithm_1.shadowTree_isConnected(inclusiveDescendant)) {\n                    if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {\n                        /**\n                         * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom\n                         * element callback reaction with inclusiveDescendant, callback name\n                         * \"connectedCallback\", and an empty argument list.\n                         */\n                        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n                    }\n                    else {\n                        /**\n                         * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.\n                         */\n                        CustomElementAlgorithm_1.customElement_tryToUpgrade(inclusiveDescendant);\n                    }\n                }\n            }\n            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node_1, inclusiveDescendant, true, true);\n        }\n    }\n    /**\n     * 8. If suppress observers flag is unset, then queue a tree mutation record\n     * for parent with nodes, « », previousSibling, and child.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        if (!suppressObservers) {\n            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, [], previousSibling, child);\n        }\n    }\n}\nexports.mutation_insert = mutation_insert;\n/**\n * Inserts a node into a parent node. Optimized routine for the common case where\n * node is not a document fragment node and it has no child nodes.\n *\n * @param node - node to insert\n * @param parent - parent node to receive node\n * @param suppressObservers - whether to notify observers\n */\nfunction mutation_insert_single(node, parent, suppressObservers) {\n    /**\n     * 1. Let count be the number of children of node if it is a\n     * DocumentFragment node, and one otherwise.\n     * 2. If child is non-null, then:\n     * 2.1. For each live range whose start node is parent and start\n     * offset is greater than child's index, increase its start\n     * offset by count.\n     * 2.2. For each live range whose end node is parent and end\n     * offset is greater than child's index, increase its end\n     * offset by count.\n     * 3. Let nodes be node’s children, if node is a DocumentFragment node;\n     * otherwise « node ».\n     * 4. If node is a DocumentFragment node, remove its children with the\n     * suppress observers flag set.\n     * 5. If node is a DocumentFragment node, then queue a tree mutation record\n     * for node with « », nodes, null, and null.\n     */\n    /**\n     * 6. Let previousSibling be child’s previous sibling or parent’s last\n     * child if child is null.\n     */\n    var previousSibling = parent._lastChild;\n    // set document element node\n    if (util_1.Guard.isElementNode(node)) {\n        // set document element node\n        if (util_1.Guard.isDocumentNode(parent)) {\n            parent._documentElement = node;\n        }\n        // mark that the document has namespaces\n        if (!node._nodeDocument._hasNamespaces && (node._namespace !== null ||\n            node._namespacePrefix !== null)) {\n            node._nodeDocument._hasNamespaces = true;\n        }\n    }\n    /**\n     * 7. For each node in nodes, in tree order:\n     * 7.1. If child is null, then append node to parent’s children.\n     * 7.2. Otherwise, insert node into parent’s children before child’s\n     * index.\n     */\n    node._parent = parent;\n    parent._children.add(node);\n    // assign siblings and children for quick lookups\n    if (parent._firstChild === null) {\n        node._previousSibling = null;\n        node._nextSibling = null;\n        parent._firstChild = node;\n        parent._lastChild = node;\n    }\n    else {\n        var prev = parent._lastChild;\n        node._previousSibling = prev;\n        node._nextSibling = null;\n        if (prev)\n            prev._nextSibling = node;\n        if (!prev)\n            parent._firstChild = node;\n        parent._lastChild = node;\n    }\n    /**\n     * 7.3. If parent is a shadow host and node is a slotable, then\n     * assign a slot for node.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {\n            ShadowTreeAlgorithm_1.shadowTree_assignASlot(node);\n        }\n    }\n    /**\n     * 7.4. If node is a Text node, run the child text content change\n     * steps for parent.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        if (util_1.Guard.isTextNode(node)) {\n            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);\n        }\n    }\n    /**\n     * 7.5. If parent's root is a shadow root, and parent is a slot\n     * whose assigned nodes is the empty list, then run signal\n     * a slot change for parent.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&\n            util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {\n            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);\n        }\n    }\n    /**\n     * 7.6. Run assign slotables for a tree with node's root.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node));\n    }\n    /**\n     * 7.7. For each shadow-including inclusive descendant\n     * inclusiveDescendant of node, in shadow-including tree\n     * order:\n     * 7.7.1. Run the insertion steps with inclusiveDescendant.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runInsertionSteps(node);\n    }\n    if (DOMImpl_1.dom.features.customElements) {\n        /**\n         * 7.7.2. If inclusiveDescendant is connected, then:\n         */\n        if (util_1.Guard.isElementNode(node) &&\n            ShadowTreeAlgorithm_1.shadowTree_isConnected(node)) {\n            if (util_1.Guard.isCustomElementNode(node)) {\n                /**\n                 * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom\n                 * element callback reaction with inclusiveDescendant, callback name\n                 * \"connectedCallback\", and an empty argument list.\n                 */\n                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, \"connectedCallback\", []);\n            }\n            else {\n                /**\n                 * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.\n                 */\n                CustomElementAlgorithm_1.customElement_tryToUpgrade(node);\n            }\n        }\n    }\n    /**\n     * 8. If suppress observers flag is unset, then queue a tree mutation record\n     * for parent with nodes, « », previousSibling, and child.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        if (!suppressObservers) {\n            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [node], [], previousSibling, null);\n        }\n    }\n}\n/**\n * Appends a node to the children of a parent node.\n *\n * @param node - a node\n * @param parent - the parent to receive node\n */\nfunction mutation_append(node, parent) {\n    /**\n     * To append a node to a parent, pre-insert node into parent before null.\n     */\n    return mutation_preInsert(node, parent, null);\n}\nexports.mutation_append = mutation_append;\n/**\n * Replaces a node with another node.\n *\n * @param child - child node to remove\n * @param node - node to insert\n * @param parent - parent node to receive node\n */\nfunction mutation_replace(child, node, parent) {\n    var e_6, _a, e_7, _b, e_8, _c, e_9, _d;\n    /**\n     * 1. If parent is not a Document, DocumentFragment, or Element node,\n     * throw a \"HierarchyRequestError\" DOMException.\n     */\n    if (parent._nodeType !== interfaces_1.NodeType.Document &&\n        parent._nodeType !== interfaces_1.NodeType.DocumentFragment &&\n        parent._nodeType !== interfaces_1.NodeType.Element)\n        throw new DOMException_1.HierarchyRequestError(\"Only document, document fragment and element nodes can contain child nodes. Parent node is \" + parent.nodeName + \".\");\n    /**\n     * 2. If node is a host-including inclusive ancestor of parent, throw a\n     * \"HierarchyRequestError\" DOMException.\n     */\n    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))\n        throw new DOMException_1.HierarchyRequestError(\"The node to be inserted cannot be an ancestor of parent node. Node is \" + node.nodeName + \", parent node is \" + parent.nodeName + \".\");\n    /**\n     * 3. If child’s parent is not parent, then throw a \"NotFoundError\"\n     * DOMException.\n     */\n    if (child._parent !== parent)\n        throw new DOMException_1.NotFoundError(\"The reference child node cannot be found under parent node. Child node is \" + child.nodeName + \", parent node is \" + parent.nodeName + \".\");\n    /**\n     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,\n     * ProcessingInstruction, or Comment node, throw a \"HierarchyRequestError\"\n     * DOMException.\n     */\n    if (node._nodeType !== interfaces_1.NodeType.DocumentFragment &&\n        node._nodeType !== interfaces_1.NodeType.DocumentType &&\n        node._nodeType !== interfaces_1.NodeType.Element &&\n        node._nodeType !== interfaces_1.NodeType.Text &&\n        node._nodeType !== interfaces_1.NodeType.ProcessingInstruction &&\n        node._nodeType !== interfaces_1.NodeType.CData &&\n        node._nodeType !== interfaces_1.NodeType.Comment)\n        throw new DOMException_1.HierarchyRequestError(\"Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is \" + node.nodeName + \".\");\n    /**\n     * 5. If either node is a Text node and parent is a document, or node is a\n     * doctype and parent is not a document, throw a \"HierarchyRequestError\"\n     * DOMException.\n     */\n    if (node._nodeType === interfaces_1.NodeType.Text &&\n        parent._nodeType === interfaces_1.NodeType.Document)\n        throw new DOMException_1.HierarchyRequestError(\"Cannot insert a text node as a child of a document node. Node is \" + node.nodeName + \".\");\n    if (node._nodeType === interfaces_1.NodeType.DocumentType &&\n        parent._nodeType !== interfaces_1.NodeType.Document)\n        throw new DOMException_1.HierarchyRequestError(\"A document type node can only be inserted under a document node. Parent node is \" + parent.nodeName + \".\");\n    /**\n     * 6. If parent is a document, and any of the statements below, switched on\n     * node, are true, throw a \"HierarchyRequestError\" DOMException.\n     * - DocumentFragment node\n     * If node has more than one element child or has a Text node child.\n     * Otherwise, if node has one element child and either parent has an element\n     * child that is not child or a doctype is following child.\n     * - element\n     * parent has an element child that is not child or a doctype is\n     * following child.\n     * - doctype\n     * parent has a doctype child that is not child, or an element is\n     * preceding child.\n     */\n    if (parent._nodeType === interfaces_1.NodeType.Document) {\n        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {\n            var eleCount = 0;\n            try {\n                for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var childNode = _f.value;\n                    if (childNode._nodeType === interfaces_1.NodeType.Element)\n                        eleCount++;\n                    else if (childNode._nodeType === interfaces_1.NodeType.Text)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert text a node as a child of a document node. Node is \" + childNode.nodeName + \".\");\n                }\n            }\n            catch (e_6_1) { e_6 = { error: e_6_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n                }\n                finally { if (e_6) throw e_6.error; }\n            }\n            if (eleCount > 1) {\n                throw new DOMException_1.HierarchyRequestError(\"A document node can only have one document element node. Document fragment to be inserted has \" + eleCount + \" element nodes.\");\n            }\n            else if (eleCount === 1) {\n                try {\n                    for (var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        var ele = _h.value;\n                        if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)\n                            throw new DOMException_1.HierarchyRequestError(\"The document node already has a document element node.\");\n                    }\n                }\n                catch (e_7_1) { e_7 = { error: e_7_1 }; }\n                finally {\n                    try {\n                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n                    }\n                    finally { if (e_7) throw e_7.error; }\n                }\n                var doctypeChild = child._nextSibling;\n                while (doctypeChild) {\n                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)\n                        throw new DOMException_1.HierarchyRequestError(\"Cannot insert an element node before a document type node.\");\n                    doctypeChild = doctypeChild._nextSibling;\n                }\n            }\n        }\n        else if (node._nodeType === interfaces_1.NodeType.Element) {\n            try {\n                for (var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()) {\n                    var ele = _k.value;\n                    if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)\n                        throw new DOMException_1.HierarchyRequestError(\"Document already has a document element node. Node is \" + node.nodeName + \".\");\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n            var doctypeChild = child._nextSibling;\n            while (doctypeChild) {\n                if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)\n                    throw new DOMException_1.HierarchyRequestError(\"Cannot insert an element node before a document type node. Node is \" + node.nodeName + \".\");\n                doctypeChild = doctypeChild._nextSibling;\n            }\n        }\n        else if (node._nodeType === interfaces_1.NodeType.DocumentType) {\n            try {\n                for (var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()) {\n                    var ele = _m.value;\n                    if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)\n                        throw new DOMException_1.HierarchyRequestError(\"Document already has a document type node. Node is \" + node.nodeName + \".\");\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n            var elementChild = child._previousSibling;\n            while (elementChild) {\n                if (elementChild._nodeType === interfaces_1.NodeType.Element)\n                    throw new DOMException_1.HierarchyRequestError(\"Cannot insert a document type node before an element node. Node is \" + node.nodeName + \".\");\n                elementChild = elementChild._previousSibling;\n            }\n        }\n    }\n    /**\n     * 7. Let reference child be child’s next sibling.\n     * 8. If reference child is node, set it to node’s next sibling.\n     * 8. Let previousSibling be child’s previous sibling.\n     */\n    var referenceChild = child._nextSibling;\n    if (referenceChild === node)\n        referenceChild = node._nextSibling;\n    var previousSibling = child._previousSibling;\n    /**\n     * 10. Adopt node into parent’s node document.\n     * 11. Let removedNodes be the empty list.\n     */\n    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);\n    var removedNodes = [];\n    /**\n     * 12. If child’s parent is not null, then:\n     */\n    if (child._parent !== null) {\n        /**\n         * 12.1. Set removedNodes to [child].\n         * 12.2. Remove child from its parent with the suppress observers flag\n         * set.\n         */\n        removedNodes.push(child);\n        mutation_remove(child, child._parent, true);\n    }\n    /**\n     * 13. Let nodes be node’s children if node is a DocumentFragment node;\n     * otherwise [node].\n     */\n    var nodes = [];\n    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {\n        nodes = Array.from(node._children);\n    }\n    else {\n        nodes.push(node);\n    }\n    /**\n     * 14. Insert node into parent before reference child with the suppress\n     * observers flag set.\n     */\n    mutation_insert(node, parent, referenceChild, true);\n    /**\n     * 15. Queue a tree mutation record for parent with nodes, removedNodes,\n     * previousSibling, and reference child.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, removedNodes, previousSibling, referenceChild);\n    }\n    /**\n     * 16. Return child.\n     */\n    return child;\n}\nexports.mutation_replace = mutation_replace;\n/**\n * Replaces all nodes of a parent with the given node.\n *\n * @param node - node to insert\n * @param parent - parent node to receive node\n */\nfunction mutation_replaceAll(node, parent) {\n    var e_10, _a;\n    /**\n     * 1. If node is not null, adopt node into parent’s node document.\n     */\n    if (node !== null) {\n        DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);\n    }\n    /**\n     * 2. Let removedNodes be parent’s children.\n     */\n    var removedNodes = Array.from(parent._children);\n    /**\n     * 3. Let addedNodes be the empty list.\n     * 4. If node is DocumentFragment node, then set addedNodes to node’s\n     * children.\n     * 5. Otherwise, if node is non-null, set addedNodes to [node].\n     */\n    var addedNodes = [];\n    if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {\n        addedNodes = Array.from(node._children);\n    }\n    else if (node !== null) {\n        addedNodes.push(node);\n    }\n    try {\n        /**\n         * 6. Remove all parent’s children, in tree order, with the suppress\n         * observers flag set.\n         */\n        for (var removedNodes_1 = __values(removedNodes), removedNodes_1_1 = removedNodes_1.next(); !removedNodes_1_1.done; removedNodes_1_1 = removedNodes_1.next()) {\n            var childNode = removedNodes_1_1.value;\n            mutation_remove(childNode, parent, true);\n        }\n    }\n    catch (e_10_1) { e_10 = { error: e_10_1 }; }\n    finally {\n        try {\n            if (removedNodes_1_1 && !removedNodes_1_1.done && (_a = removedNodes_1.return)) _a.call(removedNodes_1);\n        }\n        finally { if (e_10) throw e_10.error; }\n    }\n    /**\n     * 7. If node is not null, then insert node into parent before null with the\n     * suppress observers flag set.\n     */\n    if (node !== null) {\n        mutation_insert(node, parent, null, true);\n    }\n    /**\n     * 8. Queue a tree mutation record for parent with addedNodes, removedNodes,\n     * null, and null.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, addedNodes, removedNodes, null, null);\n    }\n}\nexports.mutation_replaceAll = mutation_replaceAll;\n/**\n * Ensures pre-removal validity of a child node from a parent, then\n * removes it.\n *\n * @param child - child node to remove\n * @param parent - parent node\n */\nfunction mutation_preRemove(child, parent) {\n    /**\n     * 1. If child’s parent is not parent, then throw a \"NotFoundError\"\n     * DOMException.\n     * 2. Remove child from parent.\n     * 3. Return child.\n     */\n    if (child._parent !== parent)\n        throw new DOMException_1.NotFoundError(\"The child node cannot be found under parent node. Child node is \" + child.nodeName + \", parent node is \" + parent.nodeName + \".\");\n    mutation_remove(child, parent);\n    return child;\n}\nexports.mutation_preRemove = mutation_preRemove;\n/**\n * Removes a child node from its parent.\n *\n * @param node - node to remove\n * @param parent - parent node\n * @param suppressObservers - whether to notify observers\n */\nfunction mutation_remove(node, parent, suppressObservers) {\n    var e_11, _a, e_12, _b, e_13, _c, e_14, _d;\n    if (DOMImpl_1.dom.rangeList.size !== 0) {\n        /**\n         * 1. Let index be node’s index.\n         */\n        var index = TreeAlgorithm_1.tree_index(node);\n        try {\n            /**\n             * 2. For each live range whose start node is an inclusive descendant of\n             * node, set its start to (parent, index).\n             * 3. For each live range whose end node is an inclusive descendant of\n             * node, set its end to (parent, index).\n             */\n            for (var _e = __values(DOMImpl_1.dom.rangeList), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var range = _f.value;\n                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._start[0], true)) {\n                    range._start = [parent, index];\n                }\n                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._end[0], true)) {\n                    range._end = [parent, index];\n                }\n                if (range._start[0] === parent && range._start[1] > index) {\n                    range._start[1]--;\n                }\n                if (range._end[0] === parent && range._end[1] > index) {\n                    range._end[1]--;\n                }\n            }\n        }\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n            }\n            finally { if (e_11) throw e_11.error; }\n        }\n        try {\n            /**\n             * 4. For each live range whose start node is parent and start offset is\n             * greater than index, decrease its start offset by 1.\n             * 5. For each live range whose end node is parent and end offset is greater\n             * than index, decrease its end offset by 1.\n             */\n            for (var _g = __values(DOMImpl_1.dom.rangeList), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var range = _h.value;\n                if (range._start[0] === parent && range._start[1] > index) {\n                    range._start[1] -= 1;\n                }\n                if (range._end[0] === parent && range._end[1] > index) {\n                    range._end[1] -= 1;\n                }\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n    }\n    /**\n     * 6. For each NodeIterator object iterator whose root’s node document is\n     * node’s node document, run the NodeIterator pre-removing steps given node\n     * and iterator.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        try {\n            for (var _j = __values(NodeIteratorAlgorithm_1.nodeIterator_iteratorList()), _k = _j.next(); !_k.done; _k = _j.next()) {\n                var iterator = _k.value;\n                if (iterator._root._nodeDocument === node._nodeDocument) {\n                    DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps(iterator, node);\n                }\n            }\n        }\n        catch (e_13_1) { e_13 = { error: e_13_1 }; }\n        finally {\n            try {\n                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n            }\n            finally { if (e_13) throw e_13.error; }\n        }\n    }\n    /**\n     * 7. Let oldPreviousSibling be node’s previous sibling.\n     * 8. Let oldNextSibling be node’s next sibling.\n     */\n    var oldPreviousSibling = node._previousSibling;\n    var oldNextSibling = node._nextSibling;\n    // set document element node\n    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {\n        parent._documentElement = null;\n    }\n    /**\n     * 9. Remove node from its parent’s children.\n     */\n    node._parent = null;\n    parent._children.delete(node);\n    // assign siblings and children for quick lookups\n    var prev = node._previousSibling;\n    var next = node._nextSibling;\n    node._previousSibling = null;\n    node._nextSibling = null;\n    if (prev)\n        prev._nextSibling = next;\n    if (next)\n        next._previousSibling = prev;\n    if (!prev)\n        parent._firstChild = next;\n    if (!next)\n        parent._lastChild = prev;\n    /**\n     * 10. If node is assigned, then run assign slotables for node’s assigned\n     * slot.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && ShadowTreeAlgorithm_1.shadowTree_isAssigned(node)) {\n            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(node._assignedSlot);\n        }\n    }\n    /**\n     * 11. If parent’s root is a shadow root, and parent is a slot whose\n     * assigned nodes is the empty list, then run signal a slot change for\n     * parent.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&\n            util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {\n            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);\n        }\n    }\n    /**\n     * 12. If node has an inclusive descendant that is a slot, then:\n     * 12.1. Run assign slotables for a tree with parent's root.\n     * 12.2. Run assign slotables for a tree with node.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        var descendant_1 = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, false, function (e) { return util_1.Guard.isSlot(e); });\n        if (descendant_1 !== null) {\n            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(parent));\n            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(node);\n        }\n    }\n    /**\n     * 13. Run the removing steps with node and parent.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runRemovingSteps(node, parent);\n    }\n    /**\n     * 14. If node is custom, then enqueue a custom element callback\n     * reaction with node, callback name \"disconnectedCallback\",\n     * and an empty argument list.\n     */\n    if (DOMImpl_1.dom.features.customElements) {\n        if (util_1.Guard.isCustomElementNode(node)) {\n            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, \"disconnectedCallback\", []);\n        }\n    }\n    /**\n     * 15. For each shadow-including descendant descendant of node,\n     * in shadow-including tree order, then:\n     */\n    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, true);\n    while (descendant !== null) {\n        /**\n         * 15.1. Run the removing steps with descendant.\n         */\n        if (DOMImpl_1.dom.features.steps) {\n            DOMAlgorithm_1.dom_runRemovingSteps(descendant, node);\n        }\n        /**\n         * 15.2. If descendant is custom, then enqueue a custom element\n         * callback reaction with descendant, callback name\n         * \"disconnectedCallback\", and an empty argument list.\n         */\n        if (DOMImpl_1.dom.features.customElements) {\n            if (util_1.Guard.isCustomElementNode(descendant)) {\n                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(descendant, \"disconnectedCallback\", []);\n            }\n        }\n        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, descendant, false, true);\n    }\n    /**\n     * 16. For each inclusive ancestor inclusiveAncestor of parent, and\n     * then for each registered of inclusiveAncestor's registered\n     * observer list, if registered's options's subtree is true,\n     * then append a new transient registered observer whose\n     * observer is registered's observer, options is registered's\n     * options, and source is registered to node's registered\n     * observer list.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        var inclusiveAncestor = TreeAlgorithm_1.tree_getFirstAncestorNode(parent, true);\n        while (inclusiveAncestor !== null) {\n            try {\n                for (var _l = (e_14 = void 0, __values(inclusiveAncestor._registeredObserverList)), _m = _l.next(); !_m.done; _m = _l.next()) {\n                    var registered = _m.value;\n                    if (registered.options.subtree) {\n                        node._registeredObserverList.push({\n                            observer: registered.observer,\n                            options: registered.options,\n                            source: registered\n                        });\n                    }\n                }\n            }\n            catch (e_14_1) { e_14 = { error: e_14_1 }; }\n            finally {\n                try {\n                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n                }\n                finally { if (e_14) throw e_14.error; }\n            }\n            inclusiveAncestor = TreeAlgorithm_1.tree_getNextAncestorNode(parent, inclusiveAncestor, true);\n        }\n    }\n    /**\n     * 17. If suppress observers flag is unset, then queue a tree mutation\n     * record for parent with « », « node », oldPreviousSibling, and\n     * oldNextSibling.\n     */\n    if (DOMImpl_1.dom.features.mutationObservers) {\n        if (!suppressObservers) {\n            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [], [node], oldPreviousSibling, oldNextSibling);\n        }\n    }\n    /**\n     * 18. If node is a Text node, then run the child text content change steps\n     * for parent.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        if (util_1.Guard.isTextNode(node)) {\n            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);\n        }\n    }\n}\nexports.mutation_remove = mutation_remove;\n//# sourceMappingURL=MutationAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar util_1 = require(\"../util\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar CreateAlgorithm_1 = require(\"./CreateAlgorithm\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar EventAlgorithm_1 = require(\"./EventAlgorithm\");\n/**\n * Queues a mutation observer microtask to the surrounding agent’s mutation\n * observers.\n */\nfunction observer_queueAMutationObserverMicrotask() {\n    /**\n     * 1. If the surrounding agent’s mutation observer microtask queued is true,\n     * then return.\n     * 2. Set the surrounding agent’s mutation observer microtask queued to true.\n     * 3. Queue a microtask to notify mutation observers.\n     */\n    var window = DOMImpl_1.dom.window;\n    if (window._mutationObserverMicrotaskQueued)\n        return;\n    window._mutationObserverMicrotaskQueued = true;\n    Promise.resolve().then(function () { observer_notifyMutationObservers(); });\n}\nexports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;\n/**\n * Notifies the surrounding agent’s mutation observers.\n */\nfunction observer_notifyMutationObservers() {\n    var e_1, _a, e_2, _b;\n    /**\n     * 1. Set the surrounding agent’s mutation observer microtask queued to false.\n     * 2. Let notifySet be a clone of the surrounding agent’s mutation observers.\n     * 3. Let signalSet be a clone of the surrounding agent’s signal slots.\n     * 4. Empty the surrounding agent’s signal slots.\n     */\n    var window = DOMImpl_1.dom.window;\n    window._mutationObserverMicrotaskQueued = false;\n    var notifySet = infra_1.set.clone(window._mutationObservers);\n    var signalSet = infra_1.set.clone(window._signalSlots);\n    infra_1.set.empty(window._signalSlots);\n    var _loop_1 = function (mo) {\n        /**\n         * 5.1. Let records be a clone of mo’s record queue.\n         * 5.2. Empty mo’s record queue.\n         */\n        var records = infra_1.list.clone(mo._recordQueue);\n        infra_1.list.empty(mo._recordQueue);\n        /**\n         * 5.3. For each node of mo’s node list, remove all transient registered\n         * observers whose observer is mo from node’s registered observer list.\n         */\n        for (var i = 0; i < mo._nodeList.length; i++) {\n            var node = mo._nodeList[i];\n            infra_1.list.remove(node._registeredObserverList, function (observer) {\n                return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;\n            });\n        }\n        /**\n         * 5.4. If records is not empty, then invoke mo’s callback with « records,\n         * mo », and mo. If this throws an exception, then report the exception.\n         */\n        if (!infra_1.list.isEmpty(records)) {\n            try {\n                mo._callback.call(mo, records, mo);\n            }\n            catch (err) {\n                // TODO: Report the exception\n            }\n        }\n    };\n    try {\n        /**\n         * 5. For each mo of notifySet:\n         */\n        for (var notifySet_1 = __values(notifySet), notifySet_1_1 = notifySet_1.next(); !notifySet_1_1.done; notifySet_1_1 = notifySet_1.next()) {\n            var mo = notifySet_1_1.value;\n            _loop_1(mo);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (notifySet_1_1 && !notifySet_1_1.done && (_a = notifySet_1.return)) _a.call(notifySet_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    /**\n     * 6. For each slot of signalSet, fire an event named slotchange, with its\n     * bubbles attribute set to true, at slot.\n     */\n    if (DOMImpl_1.dom.features.slots) {\n        try {\n            for (var signalSet_1 = __values(signalSet), signalSet_1_1 = signalSet_1.next(); !signalSet_1_1.done; signalSet_1_1 = signalSet_1.next()) {\n                var slot = signalSet_1_1.value;\n                EventAlgorithm_1.event_fireAnEvent(\"slotchange\", slot, undefined, { bubbles: true });\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (signalSet_1_1 && !signalSet_1_1.done && (_b = signalSet_1.return)) _b.call(signalSet_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n}\nexports.observer_notifyMutationObservers = observer_notifyMutationObservers;\n/**\n * Queues a mutation record of the given type for target.\n *\n * @param type - mutation record type\n * @param target - target node\n * @param name - name before mutation\n * @param namespace - namespace before mutation\n * @param oldValue - attribute value before mutation\n * @param addedNodes - a list od added nodes\n * @param removedNodes - a list of removed nodes\n * @param previousSibling - previous sibling of target before mutation\n * @param nextSibling - next sibling of target before mutation\n */\nfunction observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {\n    var e_3, _a;\n    /**\n     * 1. Let interestedObservers be an empty map.\n     * 2. Let nodes be the inclusive ancestors of target.\n     * 3. For each node in nodes, and then for each registered of node’s\n     * registered observer list:\n     */\n    var interestedObservers = new Map();\n    var node = TreeAlgorithm_1.tree_getFirstAncestorNode(target, true);\n    while (node !== null) {\n        for (var i = 0; i < node._registeredObserverList.length; i++) {\n            var registered = node._registeredObserverList[i];\n            /**\n             * 3.1. Let options be registered’s options.\n             * 3.2. If none of the following are true\n             * - node is not target and options’s subtree is false\n             * - type is \"attributes\" and options’s attributes is not true\n             * - type is \"attributes\", options’s attributeFilter is present, and\n             * options’s attributeFilter does not contain name or namespace is\n             * non-null\n             * - type is \"characterData\" and options’s characterData is not true\n             * - type is \"childList\" and options’s childList is false\n             */\n            var options = registered.options;\n            if (node !== target && !options.subtree)\n                continue;\n            if (type === \"attributes\" && !options.attributes)\n                continue;\n            if (type === \"attributes\" && options.attributeFilter &&\n                (!options.attributeFilter.indexOf(name || '') || namespace !== null))\n                continue;\n            if (type === \"characterData\" && !options.characterData)\n                continue;\n            if (type === \"childList\" && !options.childList)\n                continue;\n            /**\n             * then:\n             * 3.2.1. Let mo be registered’s observer.\n             * 3.2.2. If interestedObservers[mo] does not exist, then set\n             * interestedObservers[mo] to null.\n             * 3.2.3. If either type is \"attributes\" and options’s attributeOldValue\n             * is true, or type is \"characterData\" and options’s\n             * characterDataOldValue is true, then set interestedObservers[mo]\n             * to oldValue.\n             */\n            var mo = registered.observer;\n            if (!interestedObservers.has(mo)) {\n                interestedObservers.set(mo, null);\n            }\n            if ((type === \"attributes\" && options.attributeOldValue) ||\n                (type === \"characterData\" && options.characterDataOldValue)) {\n                interestedObservers.set(mo, oldValue);\n            }\n        }\n        node = TreeAlgorithm_1.tree_getNextAncestorNode(target, node, true);\n    }\n    try {\n        /**\n         * 4. For each observer → mappedOldValue of interestedObservers:\n         */\n        for (var interestedObservers_1 = __values(interestedObservers), interestedObservers_1_1 = interestedObservers_1.next(); !interestedObservers_1_1.done; interestedObservers_1_1 = interestedObservers_1.next()) {\n            var _b = __read(interestedObservers_1_1.value, 2), observer = _b[0], mappedOldValue = _b[1];\n            /**\n             * 4.1. Let record be a new MutationRecord object with its type set to\n             * type, target set to target, attributeName set to name,\n             * attributeNamespace set to namespace, oldValue set to mappedOldValue,\n             * addedNodes set to addedNodes, removedNodes set to removedNodes,\n             * previousSibling set to previousSibling, and nextSibling set to\n             * nextSibling.\n             * 4.2. Enqueue record to observer’s record queue.\n             */\n            var record = CreateAlgorithm_1.create_mutationRecord(type, target, CreateAlgorithm_1.create_nodeListStatic(target, addedNodes), CreateAlgorithm_1.create_nodeListStatic(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);\n            var queue = observer._recordQueue;\n            queue.push(record);\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (interestedObservers_1_1 && !interestedObservers_1_1.done && (_a = interestedObservers_1.return)) _a.call(interestedObservers_1);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    /**\n     * 5. Queue a mutation observer microtask.\n     */\n    observer_queueAMutationObserverMicrotask();\n}\nexports.observer_queueMutationRecord = observer_queueMutationRecord;\n/**\n * Queues a tree mutation record for target.\n *\n * @param target - target node\n * @param addedNodes - a list od added nodes\n * @param removedNodes - a list of removed nodes\n * @param previousSibling - previous sibling of target before mutation\n * @param nextSibling - next sibling of target before mutation\n */\nfunction observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {\n    /**\n     * To queue a tree mutation record for target with addedNodes, removedNodes,\n     * previousSibling, and nextSibling, queue a mutation record of \"childList\"\n     * for target with null, null, null, addedNodes, removedNodes,\n     * previousSibling, and nextSibling.\n     */\n    observer_queueMutationRecord(\"childList\", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);\n}\nexports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;\n/**\n * Queues an attribute mutation record for target.\n *\n * @param target - target node\n * @param name - name before mutation\n * @param namespace - namespace before mutation\n * @param oldValue - attribute value before mutation\n */\nfunction observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {\n    /**\n     * To queue an attribute mutation record for target with name, namespace,\n     * and oldValue, queue a mutation record of \"attributes\" for target with\n     * name, namespace, oldValue, « », « », null, and null.\n     */\n    observer_queueMutationRecord(\"attributes\", target, name, namespace, oldValue, [], [], null, null);\n}\nexports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;\n//# sourceMappingURL=MutationObserverAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar XMLAlgorithm_1 = require(\"./XMLAlgorithm\");\n/**\n * Validates the given qualified name.\n *\n * @param qualifiedName - qualified name\n */\nfunction namespace_validate(qualifiedName) {\n    /**\n     * To validate a qualifiedName, throw an \"InvalidCharacterError\"\n     * DOMException if qualifiedName does not match the Name or QName\n     * production.\n     */\n    if (!XMLAlgorithm_1.xml_isName(qualifiedName))\n        throw new DOMException_1.InvalidCharacterError(\"Invalid XML name: \" + qualifiedName);\n    if (!XMLAlgorithm_1.xml_isQName(qualifiedName))\n        throw new DOMException_1.InvalidCharacterError(\"Invalid XML qualified name: \" + qualifiedName + \".\");\n}\nexports.namespace_validate = namespace_validate;\n/**\n * Validates and extracts a namespace, prefix and localName from the\n * given namespace and qualified name.\n * See: https://dom.spec.whatwg.org/#validate-and-extract.\n *\n * @param namespace - namespace\n * @param qualifiedName - qualified name\n *\n * @returns a tuple with `namespace`, `prefix` and `localName`.\n */\nfunction namespace_validateAndExtract(namespace, qualifiedName) {\n    /**\n     * 1. If namespace is the empty string, set it to null.\n     * 2. Validate qualifiedName.\n     * 3. Let prefix be null.\n     * 4. Let localName be qualifiedName.\n     * 5. If qualifiedName contains a \":\" (U+003E), then split the string on it\n     * and set prefix to the part before and localName to the part after.\n     * 6. If prefix is non-null and namespace is null, then throw a\n     * \"NamespaceError\" DOMException.\n     * 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw\n     * a \"NamespaceError\" DOMException.\n     * 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the\n     * XMLNS namespace, then throw a \"NamespaceError\" DOMException.\n     * 9. If namespace is the XMLNS namespace and neither qualifiedName nor\n     * prefix is \"xmlns\", then throw a \"NamespaceError\" DOMException.\n     * 10. Return namespace, prefix, and localName.\n     */\n    if (!namespace)\n        namespace = null;\n    namespace_validate(qualifiedName);\n    var parts = qualifiedName.split(':');\n    var prefix = (parts.length === 2 ? parts[0] : null);\n    var localName = (parts.length === 2 ? parts[1] : qualifiedName);\n    if (prefix && namespace === null)\n        throw new DOMException_1.NamespaceError(\"Qualified name includes a prefix but the namespace is null.\");\n    if (prefix === \"xml\" && namespace !== infra_1.namespace.XML)\n        throw new DOMException_1.NamespaceError(\"Qualified name includes the \\\"xml\\\" prefix but the namespace is not the XML namespace.\");\n    if (namespace !== infra_1.namespace.XMLNS &&\n        (prefix === \"xmlns\" || qualifiedName === \"xmlns\"))\n        throw new DOMException_1.NamespaceError(\"Qualified name includes the \\\"xmlns\\\" prefix but the namespace is not the XMLNS namespace.\");\n    if (namespace === infra_1.namespace.XMLNS &&\n        (prefix !== \"xmlns\" && qualifiedName !== \"xmlns\"))\n        throw new DOMException_1.NamespaceError(\"Qualified name does not include the \\\"xmlns\\\" prefix but the namespace is the XMLNS namespace.\");\n    return [namespace, prefix, localName];\n}\nexports.namespace_validateAndExtract = namespace_validateAndExtract;\n/**\n * Extracts a prefix and localName from the given qualified name.\n *\n * @param qualifiedName - qualified name\n *\n * @returns an tuple with `prefix` and `localName`.\n */\nfunction namespace_extractQName(qualifiedName) {\n    namespace_validate(qualifiedName);\n    var parts = qualifiedName.split(':');\n    var prefix = (parts.length === 2 ? parts[0] : null);\n    var localName = (parts.length === 2 ? parts[1] : qualifiedName);\n    return [prefix, localName];\n}\nexports.namespace_extractQName = namespace_extractQName;\n//# sourceMappingURL=NamespaceAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar util_1 = require(\"../util\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar CreateAlgorithm_1 = require(\"./CreateAlgorithm\");\nvar OrderedSetAlgorithm_1 = require(\"./OrderedSetAlgorithm\");\nvar DOMAlgorithm_1 = require(\"./DOMAlgorithm\");\nvar MutationAlgorithm_1 = require(\"./MutationAlgorithm\");\nvar ElementAlgorithm_1 = require(\"./ElementAlgorithm\");\n/**\n * Replaces the contents of the given node with a single text node.\n *\n * @param string - node contents\n * @param parent - a node\n */\nfunction node_stringReplaceAll(str, parent) {\n    /**\n     * 1. Let node be null.\n     * 2. If string is not the empty string, then set node to a new Text node\n     * whose data is string and node document is parent’s node document.\n     * 3. Replace all with node within parent.\n     */\n    var node = null;\n    if (str !== '') {\n        node = CreateAlgorithm_1.create_text(parent._nodeDocument, str);\n    }\n    MutationAlgorithm_1.mutation_replaceAll(node, parent);\n}\nexports.node_stringReplaceAll = node_stringReplaceAll;\n/**\n * Clones a node.\n *\n * @param node - a node to clone\n * @param document - the document to own the cloned node\n * @param cloneChildrenFlag - whether to clone node's children\n */\nfunction node_clone(node, document, cloneChildrenFlag) {\n    var e_1, _a, e_2, _b;\n    if (document === void 0) { document = null; }\n    if (cloneChildrenFlag === void 0) { cloneChildrenFlag = false; }\n    /**\n     * 1. If document is not given, let document be node’s node document.\n     */\n    if (document === null)\n        document = node._nodeDocument;\n    var copy;\n    if (util_1.Guard.isElementNode(node)) {\n        /**\n         * 2. If node is an element, then:\n         * 2.1. Let copy be the result of creating an element, given document,\n         * node’s local name, node’s namespace, node’s namespace prefix,\n         * and node’s is value, with the synchronous custom elements flag unset.\n         * 2.2. For each attribute in node’s attribute list:\n         * 2.2.1. Let copyAttribute be a clone of attribute.\n         * 2.2.2. Append copyAttribute to copy.\n         */\n        copy = ElementAlgorithm_1.element_createAnElement(document, node._localName, node._namespace, node._namespacePrefix, node._is, false);\n        try {\n            for (var _c = __values(node._attributeList), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var attribute = _d.value;\n                var copyAttribute = node_clone(attribute, document);\n                ElementAlgorithm_1.element_append(copyAttribute, copy);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    else {\n        /**\n         * 3. Otherwise, let copy be a node that implements the same interfaces as\n         * node, and fulfills these additional requirements, switching on node:\n         * - Document\n         * Set copy’s encoding, content type, URL, origin, type, and mode, to those\n         * of node.\n         * - DocumentType\n         * Set copy’s name, public ID, and system ID, to those of node.\n         * - Attr\n         * Set copy’s namespace, namespace prefix, local name, and value, to\n         * those of node.\n         * - Text\n         * - Comment\n         * Set copy’s data, to that of node.\n         * - ProcessingInstruction\n         * Set copy’s target and data to those of node.\n         * - Any other node\n         */\n        if (util_1.Guard.isDocumentNode(node)) {\n            var doc = CreateAlgorithm_1.create_document();\n            doc._encoding = node._encoding;\n            doc._contentType = node._contentType;\n            doc._URL = node._URL;\n            doc._origin = node._origin;\n            doc._type = node._type;\n            doc._mode = node._mode;\n            copy = doc;\n        }\n        else if (util_1.Guard.isDocumentTypeNode(node)) {\n            var doctype = CreateAlgorithm_1.create_documentType(document, node._name, node._publicId, node._systemId);\n            copy = doctype;\n        }\n        else if (util_1.Guard.isAttrNode(node)) {\n            var attr = CreateAlgorithm_1.create_attr(document, node.localName);\n            attr._namespace = node._namespace;\n            attr._namespacePrefix = node._namespacePrefix;\n            attr._value = node._value;\n            copy = attr;\n        }\n        else if (util_1.Guard.isExclusiveTextNode(node)) {\n            copy = CreateAlgorithm_1.create_text(document, node._data);\n        }\n        else if (util_1.Guard.isCDATASectionNode(node)) {\n            copy = CreateAlgorithm_1.create_cdataSection(document, node._data);\n        }\n        else if (util_1.Guard.isCommentNode(node)) {\n            copy = CreateAlgorithm_1.create_comment(document, node._data);\n        }\n        else if (util_1.Guard.isProcessingInstructionNode(node)) {\n            copy = CreateAlgorithm_1.create_processingInstruction(document, node._target, node._data);\n        }\n        else if (util_1.Guard.isDocumentFragmentNode(node)) {\n            copy = CreateAlgorithm_1.create_documentFragment(document);\n        }\n        else {\n            copy = Object.create(node);\n        }\n    }\n    /**\n     * 4. Set copy’s node document and document to copy, if copy is a document,\n     * and set copy’s node document to document otherwise.\n     */\n    if (util_1.Guard.isDocumentNode(copy)) {\n        copy._nodeDocument = copy;\n        document = copy;\n    }\n    else {\n        copy._nodeDocument = document;\n    }\n    /**\n     * 5. Run any cloning steps defined for node in other applicable\n     * specifications and pass copy, node, document and the clone children flag\n     * if set, as parameters.\n     */\n    if (DOMImpl_1.dom.features.steps) {\n        DOMAlgorithm_1.dom_runCloningSteps(copy, node, document, cloneChildrenFlag);\n    }\n    /**\n     * 6. If the clone children flag is set, clone all the children of node and\n     * append them to copy, with document as specified and the clone children\n     * flag being set.\n     */\n    if (cloneChildrenFlag) {\n        try {\n            for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var child = _f.value;\n                var childCopy = node_clone(child, document, true);\n                MutationAlgorithm_1.mutation_append(childCopy, copy);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    /**\n     * 7. Return copy.\n     */\n    return copy;\n}\nexports.node_clone = node_clone;\n/**\n * Determines if two nodes can be considered equal.\n *\n * @param a - node to compare\n * @param b - node to compare\n */\nfunction node_equals(a, b) {\n    var e_3, _a, e_4, _b;\n    /**\n     * 1. A and B’s nodeType attribute value is identical.\n     */\n    if (a._nodeType !== b._nodeType)\n        return false;\n    /**\n     * 2. The following are also equal, depending on A:\n     * - DocumentType\n     * Its name, public ID, and system ID.\n     * - Element\n     * Its namespace, namespace prefix, local name, and its attribute list’s size.\n     * - Attr\n     * Its namespace, local name, and value.\n     * - ProcessingInstruction\n     * Its target and data.\n     * - Text\n     * - Comment\n     * Its data.\n     */\n    if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {\n        if (a._name !== b._name || a._publicId !== b._publicId ||\n            a._systemId !== b._systemId)\n            return false;\n    }\n    else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {\n        if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix ||\n            a._localName !== b._localName ||\n            a._attributeList.length !== b._attributeList.length)\n            return false;\n    }\n    else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {\n        if (a._namespace !== b._namespace || a._localName !== b._localName ||\n            a._value !== b._value)\n            return false;\n    }\n    else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {\n        if (a._target !== b._target || a._data !== b._data)\n            return false;\n    }\n    else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {\n        if (a._data !== b._data)\n            return false;\n    }\n    /**\n     * 3. If A is an element, each attribute in its attribute list has an attribute\n     * that equals an attribute in B’s attribute list.\n     */\n    if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {\n        var attrMap = {};\n        try {\n            for (var _c = __values(a._attributeList), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var attrA = _d.value;\n                attrMap[attrA._localName] = attrA;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        try {\n            for (var _e = __values(b._attributeList), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var attrB = _f.value;\n                var attrA = attrMap[attrB._localName];\n                if (!attrA)\n                    return false;\n                if (!node_equals(attrA, attrB))\n                    return false;\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    }\n    /**\n     * 4. A and B have the same number of children.\n     * 5. Each child of A equals the child of B at the identical index.\n     */\n    if (a._children.size !== b._children.size)\n        return false;\n    var itA = a._children[Symbol.iterator]();\n    var itB = b._children[Symbol.iterator]();\n    var resultA = itA.next();\n    var resultB = itB.next();\n    while (!resultA.done && !resultB.done) {\n        var child1 = resultA.value;\n        var child2 = resultB.value;\n        if (!node_equals(child1, child2))\n            return false;\n        resultA = itA.next();\n        resultB = itB.next();\n    }\n    return true;\n}\nexports.node_equals = node_equals;\n/**\n * Returns a collection of elements with the given qualified name which are\n * descendants of the given root node.\n * See: https://dom.spec.whatwg.org/#concept-getelementsbytagname\n *\n * @param qualifiedName - qualified name\n * @param root - root node\n */\nfunction node_listOfElementsWithQualifiedName(qualifiedName, root) {\n    /**\n     * 1. If qualifiedName is \"*\" (U+002A), return a HTMLCollection rooted at\n     * root, whose filter matches only descendant elements.\n     * 2. Otherwise, if root’s node document is an HTML document, return a\n     * HTMLCollection rooted at root, whose filter matches the following\n     * descendant elements:\n     * 2.1. Whose namespace is the HTML namespace and whose qualified name is\n     * qualifiedName, in ASCII lowercase.\n     * 2.2. Whose namespace is not the HTML namespace and whose qualified name\n     * is qualifiedName.\n     * 3. Otherwise, return a HTMLCollection rooted at root, whose filter\n     * matches descendant elements whose qualified name is qualifiedName.\n     */\n    if (qualifiedName === \"*\") {\n        return CreateAlgorithm_1.create_htmlCollection(root);\n    }\n    else if (root._nodeDocument._type === \"html\") {\n        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {\n            if (ele._namespace === infra_1.namespace.HTML &&\n                ele._qualifiedName === qualifiedName.toLowerCase()) {\n                return true;\n            }\n            else if (ele._namespace !== infra_1.namespace.HTML &&\n                ele._qualifiedName === qualifiedName) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        });\n    }\n    else {\n        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {\n            return (ele._qualifiedName === qualifiedName);\n        });\n    }\n}\nexports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;\n/**\n * Returns a collection of elements with the given namespace which are\n * descendants of the given root node.\n * See: https://dom.spec.whatwg.org/#concept-getelementsbytagnamens\n *\n * @param namespace - element namespace\n * @param localName - local name\n * @param root - root node\n */\nfunction node_listOfElementsWithNamespace(namespace, localName, root) {\n    /**\n     * 1. If namespace is the empty string, set it to null.\n     * 2. If both namespace and localName are \"*\" (U+002A), return a\n     * HTMLCollection rooted at root, whose filter matches descendant elements.\n     * 3. Otherwise, if namespace is \"*\" (U+002A), return a HTMLCollection\n     * rooted at root, whose filter matches descendant elements whose local\n     * name is localName.\n     * 4. Otherwise, if localName is \"*\" (U+002A), return a HTMLCollection\n     * rooted at root, whose filter matches descendant elements whose\n     * namespace is namespace.\n     * 5. Otherwise, return a HTMLCollection rooted at root, whose filter\n     * matches descendant elements whose namespace is namespace and local\n     * name is localName.\n     */\n    if (namespace === '')\n        namespace = null;\n    if (namespace === \"*\" && localName === \"*\") {\n        return CreateAlgorithm_1.create_htmlCollection(root);\n    }\n    else if (namespace === \"*\") {\n        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {\n            return (ele._localName === localName);\n        });\n    }\n    else if (localName === \"*\") {\n        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {\n            return (ele._namespace === namespace);\n        });\n    }\n    else {\n        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {\n            return (ele._localName === localName && ele._namespace === namespace);\n        });\n    }\n}\nexports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;\n/**\n * Returns a collection of elements with the given class names which are\n * descendants of the given root node.\n * See: https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n *\n * @param namespace - element namespace\n * @param localName - local name\n * @param root - root node\n */\nfunction node_listOfElementsWithClassNames(classNames, root) {\n    /**\n     * 1. Let classes be the result of running the ordered set parser\n     * on classNames.\n     * 2. If classes is the empty set, return an empty HTMLCollection.\n     * 3. Return a HTMLCollection rooted at root, whose filter matches\n     * descendant elements that have all their classes in classes.\n     * The comparisons for the classes must be done in an ASCII case-insensitive\n     * manner if root’s node document’s mode is \"quirks\", and in a\n     * case-sensitive manner otherwise.\n     */\n    var classes = OrderedSetAlgorithm_1.orderedSet_parse(classNames);\n    if (classes.size === 0) {\n        return CreateAlgorithm_1.create_htmlCollection(root, function () { return false; });\n    }\n    var caseSensitive = (root._nodeDocument._mode !== \"quirks\");\n    return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {\n        var eleClasses = ele.classList;\n        return OrderedSetAlgorithm_1.orderedSet_contains(eleClasses._tokenSet, classes, caseSensitive);\n    });\n}\nexports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;\n/**\n * Searches for a namespace prefix associated with the given namespace\n * starting from the given element through its ancestors.\n *\n * @param element - an element node to start searching at\n * @param namespace - namespace to search for\n */\nfunction node_locateANamespacePrefix(element, namespace) {\n    /**\n     * 1. If element’s namespace is namespace and its namespace prefix is not\n     * null, then return its namespace prefix.\n     */\n    if (element._namespace === namespace && element._namespacePrefix !== null) {\n        return element._namespacePrefix;\n    }\n    /**\n     * 2. If element has an attribute whose namespace prefix is \"xmlns\" and\n     * value is namespace, then return element’s first such attribute’s\n     * local name.\n     */\n    for (var i = 0; i < element._attributeList.length; i++) {\n        var attr = element._attributeList[i];\n        if (attr._namespacePrefix === \"xmlns\" && attr._value === namespace) {\n            return attr._localName;\n        }\n    }\n    /**\n     * 3. If element’s parent element is not null, then return the result of\n     * running locate a namespace prefix on that element using namespace.\n     */\n    if (element._parent && util_1.Guard.isElementNode(element._parent)) {\n        return node_locateANamespacePrefix(element._parent, namespace);\n    }\n    /**\n     * 4. Return null.\n     */\n    return null;\n}\nexports.node_locateANamespacePrefix = node_locateANamespacePrefix;\n/**\n * Searches for a namespace associated with the given namespace prefix\n * starting from the given node through its ancestors.\n *\n * @param node - a node to start searching at\n * @param prefix - namespace prefix to search for\n */\nfunction node_locateANamespace(node, prefix) {\n    if (util_1.Guard.isElementNode(node)) {\n        /**\n         * 1. If its namespace is not null and its namespace prefix is prefix,\n         * then return namespace.\n         */\n        if (node._namespace !== null && node._namespacePrefix === prefix) {\n            return node._namespace;\n        }\n        /**\n         * 2. If it has an attribute whose namespace is the XMLNS namespace,\n         * namespace prefix is \"xmlns\", and local name is prefix, or if prefix\n         * is null and it has an attribute whose namespace is the XMLNS namespace,\n         * namespace prefix is null, and local name is \"xmlns\", then return its\n         * value if it is not the empty string, and null otherwise.\n         */\n        for (var i = 0; i < node._attributeList.length; i++) {\n            var attr = node._attributeList[i];\n            if (attr._namespace === infra_1.namespace.XMLNS &&\n                attr._namespacePrefix === \"xmlns\" &&\n                attr._localName === prefix) {\n                return attr._value || null;\n            }\n            if (prefix === null && attr._namespace === infra_1.namespace.XMLNS &&\n                attr._namespacePrefix === null && attr._localName === \"xmlns\") {\n                return attr._value || null;\n            }\n        }\n        /**\n         * 3. If its parent element is null, then return null.\n         */\n        if (node.parentElement === null)\n            return null;\n        /**\n         * 4. Return the result of running locate a namespace on its parent\n         * element using prefix.\n         */\n        return node_locateANamespace(node.parentElement, prefix);\n    }\n    else if (util_1.Guard.isDocumentNode(node)) {\n        /**\n         * 1. If its document element is null, then return null.\n         * 2. Return the result of running locate a namespace on its document\n         * element using prefix.\n         */\n        if (node.documentElement === null)\n            return null;\n        return node_locateANamespace(node.documentElement, prefix);\n    }\n    else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {\n        return null;\n    }\n    else if (util_1.Guard.isAttrNode(node)) {\n        /**\n         * 1. If its element is null, then return null.\n         * 2. Return the result of running locate a namespace on its element\n         * using prefix.\n         */\n        if (node._element === null)\n            return null;\n        return node_locateANamespace(node._element, prefix);\n    }\n    else {\n        /**\n         * 1. If its parent element is null, then return null.\n         * 2. Return the result of running locate a namespace on its parent\n         * element using prefix.\n         */\n        if (!node._parent || !util_1.Guard.isElementNode(node._parent))\n            return null;\n        return node_locateANamespace(node._parent, prefix);\n    }\n}\nexports.node_locateANamespace = node_locateANamespace;\n//# sourceMappingURL=NodeAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar TraversalAlgorithm_1 = require(\"./TraversalAlgorithm\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\n/**\n * Returns the next or previous node in the subtree, or `null` if\n * there are none.\n *\n * @param iterator - the `NodeIterator` instance\n * @param forward- `true` to return the next node, or `false` to\n * return the previous node.\n */\nfunction nodeIterator_traverse(iterator, forward) {\n    /**\n     * 1. Let node be iterator’s reference.\n     * 2. Let beforeNode be iterator’s pointer before reference.\n     */\n    var node = iterator._reference;\n    var beforeNode = iterator._pointerBeforeReference;\n    /**\n     * 3. While true:\n     */\n    while (true) {\n        /**\n         * 3.1. Branch on direction:\n         */\n        if (forward) {\n            /**\n             * - next\n             */\n            if (!beforeNode) {\n                /**\n                 * If beforeNode is false, then set node to the first node following\n                 * node in iterator’s iterator collection. If there is no such node,\n                 * then return null.\n                 */\n                var nextNode = TreeAlgorithm_1.tree_getFollowingNode(iterator._root, node);\n                if (nextNode) {\n                    node = nextNode;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                /**\n                 * If beforeNode is true, then set it to false.\n                 */\n                beforeNode = false;\n            }\n        }\n        else {\n            /**\n             * - previous\n             */\n            if (beforeNode) {\n                /**\n                 * If beforeNode is true, then set node to the first node preceding\n                 * node in iterator’s iterator collection. If there is no such node,\n                 * then return null.\n                 */\n                var prevNode = TreeAlgorithm_1.tree_getPrecedingNode(iterator.root, node);\n                if (prevNode) {\n                    node = prevNode;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                /**\n                 * If beforeNode is false, then set it to true.\n                 */\n                beforeNode = true;\n            }\n        }\n        /**\n         * 3.2. Let result be the result of filtering node within iterator.\n         * 3.3. If result is FILTER_ACCEPT, then break.\n         */\n        var result = TraversalAlgorithm_1.traversal_filter(iterator, node);\n        if (result === interfaces_1.FilterResult.Accept) {\n            break;\n        }\n    }\n    /**\n     * 4. Set iterator’s reference to node.\n     * 5. Set iterator’s pointer before reference to beforeNode.\n     * 6. Return node.\n     */\n    iterator._reference = node;\n    iterator._pointerBeforeReference = beforeNode;\n    return node;\n}\nexports.nodeIterator_traverse = nodeIterator_traverse;\n/**\n * Gets the global iterator list.\n */\nfunction nodeIterator_iteratorList() {\n    return DOMImpl_1.dom.window._iteratorList;\n}\nexports.nodeIterator_iteratorList = nodeIterator_iteratorList;\n//# sourceMappingURL=NodeIteratorAlgorithm.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar infra_1 = require(\"@oozcitak/infra\");\n/**\n * Converts a whitespace separated string into an array of tokens.\n *\n * @param value - a string of whitespace separated tokens\n */\nfunction orderedSet_parse(value) {\n    /**\n     * 1. Let inputTokens be the result of splitting input on ASCII whitespace.\n     * 2. Let tokens be a new ordered set.\n     * 3. For each token in inputTokens, append token to tokens.\n     * 4. Return tokens.\n     */\n    var inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);\n    return new Set(inputTokens);\n}\nexports.orderedSet_parse = orderedSet_parse;\n/**\n * Converts an array of tokens into a space separated string.\n *\n * @param tokens - an array of token strings\n */\nfunction orderedSet_serialize(tokens) {\n    /**\n     * The ordered set serializer takes a set and returns the concatenation of\n     * set using U+0020 SPACE.\n     */\n    return __spread(tokens).join(' ');\n}\nexports.orderedSet_serialize = orderedSet_serialize;\n/**\n * Removes duplicate tokens and convert all whitespace characters\n * to space.\n *\n * @param value - a string of whitespace separated tokens\n */\nfunction orderedSet_sanitize(value) {\n    return orderedSet_serialize(orderedSet_parse(value));\n}\nexports.orderedSet_sanitize = orderedSet_sanitize;\n/**\n * Determines whether a set contains the other.\n *\n * @param set1 - a set\n * @param set1 - a set that is contained in set1\n * @param caseSensitive - whether matches are case-sensitive\n */\nfunction orderedSet_contains(set1, set2, caseSensitive) {\n    var e_1, _a, e_2, _b;\n    try {\n        for (var set2_1 = __values(set2), set2_1_1 = set2_1.next(); !set2_1_1.done; set2_1_1 = set2_1.next()) {\n            var val2 = set2_1_1.value;\n            var found = false;\n            try {\n                for (var set1_1 = (e_2 = void 0, __values(set1)), set1_1_1 = set1_1.next(); !set1_1_1.done; set1_1_1 = set1_1.next()) {\n                    var val1 = set1_1_1.value;\n                    if (caseSensitive) {\n                        if (val1 === val2) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    else {\n                        if (val1.toUpperCase() === val2.toUpperCase()) {\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (set1_1_1 && !set1_1_1.done && (_b = set1_1.return)) _b.call(set1_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            if (!found)\n                return false;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (set2_1_1 && !set2_1_1.done && (_a = set2_1.return)) _a.call(set2_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return true;\n}\nexports.orderedSet_contains = orderedSet_contains;\n//# sourceMappingURL=OrderedSetAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar CreateAlgorithm_1 = require(\"./CreateAlgorithm\");\n/**\n * Converts the given nodes or strings into a node (if `nodes` has\n * only one element) or a document fragment.\n *\n * @param nodes - the array of nodes or strings,\n * @param document - owner document\n */\nfunction parentNode_convertNodesIntoANode(nodes, document) {\n    var e_1, _a;\n    /**\n     * 1. Let node be null.\n     * 2. Replace each string in nodes with a new Text node whose data is the\n     * string and node document is document.\n     */\n    var node = null;\n    for (var i = 0; i < nodes.length; i++) {\n        var item = nodes[i];\n        if (util_1.isString(item)) {\n            var text = CreateAlgorithm_1.create_text(document, item);\n            nodes[i] = text;\n        }\n    }\n    /**\n     * 3. If nodes contains one node, set node to that node.\n     * 4. Otherwise, set node to a new DocumentFragment whose node document is\n     * document, and then append each node in nodes, if any, to it.\n     */\n    if (nodes.length === 1) {\n        node = nodes[0];\n    }\n    else {\n        node = CreateAlgorithm_1.create_documentFragment(document);\n        var ns = node;\n        try {\n            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n                var item = nodes_1_1.value;\n                ns.appendChild(item);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    /**\n     * 5. Return node.\n     */\n    return node;\n}\nexports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;\n//# sourceMappingURL=ParentNodeAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar util_1 = require(\"../util\");\nvar CreateAlgorithm_1 = require(\"./CreateAlgorithm\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar BoundaryPointAlgorithm_1 = require(\"./BoundaryPointAlgorithm\");\nvar CharacterDataAlgorithm_1 = require(\"./CharacterDataAlgorithm\");\nvar NodeAlgorithm_1 = require(\"./NodeAlgorithm\");\nvar MutationAlgorithm_1 = require(\"./MutationAlgorithm\");\nvar TextAlgorithm_1 = require(\"./TextAlgorithm\");\n/**\n * Determines if the node's start boundary point is at its end boundary\n * point.\n *\n * @param range - a range\n */\nfunction range_collapsed(range) {\n    /**\n     * A range is collapsed if its start node is its end node and its start offset is its end offset.\n     */\n    return (range._startNode === range._endNode && range._startOffset === range._endOffset);\n}\nexports.range_collapsed = range_collapsed;\n/**\n * Gets the root node of a range.\n *\n * @param range - a range\n */\nfunction range_root(range) {\n    /**\n     * The root of a live range is the root of its start node.\n     */\n    return TreeAlgorithm_1.tree_rootNode(range._startNode);\n}\nexports.range_root = range_root;\n/**\n * Determines if a node is fully contained in a range.\n *\n * @param node - a node\n * @param range - a range\n */\nfunction range_isContained(node, range) {\n    /**\n     * A node node is contained in a live range range if node’s root is range’s\n     * root, and (node, 0) is after range’s start, and (node, node’s length) is\n     * before range’s end.\n     */\n    return (TreeAlgorithm_1.tree_rootNode(node) === range_root(range) &&\n        BoundaryPointAlgorithm_1.boundaryPoint_position([node, 0], range._start) === interfaces_1.BoundaryPosition.After &&\n        BoundaryPointAlgorithm_1.boundaryPoint_position([node, TreeAlgorithm_1.tree_nodeLength(node)], range._end) === interfaces_1.BoundaryPosition.Before);\n}\nexports.range_isContained = range_isContained;\n/**\n * Determines if a node is partially contained in a range.\n *\n * @param node - a node\n * @param range - a range\n */\nfunction range_isPartiallyContained(node, range) {\n    /**\n     * A node is partially contained in a live range if it’s an inclusive\n     * ancestor of the live range’s start node but not its end node,\n     * or vice versa.\n     */\n    var startCheck = TreeAlgorithm_1.tree_isAncestorOf(range._startNode, node, true);\n    var endCheck = TreeAlgorithm_1.tree_isAncestorOf(range._endNode, node, true);\n    return (startCheck && !endCheck) || (!startCheck && endCheck);\n}\nexports.range_isPartiallyContained = range_isPartiallyContained;\n/**\n * Sets the start boundary point of a range.\n *\n * @param range - a range\n * @param node - a node\n * @param offset - an offset into node\n */\nfunction range_setTheStart(range, node, offset) {\n    /**\n     * 1. If node is a doctype, then throw an \"InvalidNodeTypeError\" DOMException.\n     * 2. If offset is greater than node’s length, then throw an \"IndexSizeError\"\n     * DOMException.\n     * 3. Let bp be the boundary point (node, offset).\n     * 4. If these steps were invoked as \"set the start\"\n     * 4.1. If bp is after the range’s end, or if range’s root is not equal to\n     * node’s root, set range’s end to bp.\n     * 4.2. Set range’s start to bp.\n     */\n    if (util_1.Guard.isDocumentTypeNode(node)) {\n        throw new DOMException_1.InvalidNodeTypeError();\n    }\n    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {\n        throw new DOMException_1.IndexSizeError();\n    }\n    var bp = [node, offset];\n    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) ||\n        BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._end) === interfaces_1.BoundaryPosition.After) {\n        range._end = bp;\n    }\n    range._start = bp;\n}\nexports.range_setTheStart = range_setTheStart;\n/**\n * Sets the end boundary point of a range.\n *\n * @param range - a range\n * @param node - a node\n * @param offset - an offset into node\n */\nfunction range_setTheEnd(range, node, offset) {\n    /**\n     * 1. If node is a doctype, then throw an \"InvalidNodeTypeError\" DOMException.\n     * 2. If offset is greater than node’s length, then throw an \"IndexSizeError\"\n     * DOMException.\n     * 3. Let bp be the boundary point (node, offset).\n     * 4. If these steps were invoked as \"set the end\"\n     * 4.1. If bp is before the range’s start, or if range’s root is not equal\n     * to node’s root, set range’s start to bp.\n     * 4.2. Set range’s end to bp.\n     */\n    if (util_1.Guard.isDocumentTypeNode(node)) {\n        throw new DOMException_1.InvalidNodeTypeError();\n    }\n    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {\n        throw new DOMException_1.IndexSizeError();\n    }\n    var bp = [node, offset];\n    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) ||\n        BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._start) === interfaces_1.BoundaryPosition.Before) {\n        range._start = bp;\n    }\n    range._end = bp;\n}\nexports.range_setTheEnd = range_setTheEnd;\n/**\n * Selects a node.\n *\n * @param range - a range\n * @param node - a node\n */\nfunction range_select(node, range) {\n    /**\n     * 1. Let parent be node’s parent.\n     * 2. If parent is null, then throw an \"InvalidNodeTypeError\" DOMException.\n     */\n    var parent = node._parent;\n    if (parent === null)\n        throw new DOMException_1.InvalidNodeTypeError();\n    /**\n     * 3. Let index be node’s index.\n     * 4. Set range’s start to boundary point (parent, index).\n     * 5. Set range’s end to boundary point (parent, index plus 1).\n     */\n    var index = TreeAlgorithm_1.tree_index(node);\n    range._start = [parent, index];\n    range._end = [parent, index + 1];\n}\nexports.range_select = range_select;\n/**\n * EXtracts the contents of range as a document fragment.\n *\n * @param range - a range\n */\nfunction range_extract(range) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    /**\n     * 1. Let fragment be a new DocumentFragment node whose node document is\n     * range’s start node’s node document.\n     * 2. If range is collapsed, then return fragment.\n     */\n    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);\n    if (range_collapsed(range))\n        return fragment;\n    /**\n     * 3. Let original start node, original start offset, original end node,\n     * and original end offset be range’s start node, start offset, end node,\n     * and end offset, respectively.\n     */\n    var originalStartNode = range._startNode;\n    var originalStartOffset = range._startOffset;\n    var originalEndNode = range._endNode;\n    var originalEndOffset = range._endOffset;\n    /**\n     * 4. If original start node is original end node, and they are a Text,\n     * ProcessingInstruction, or Comment node:\n     * 4.1. Let clone be a clone of original start node.\n     * 4.2. Set the data of clone to the result of substringing data with node\n     * original start node, offset original start offset, and count original end\n     * offset minus original start offset.\n     * 4.3. Append clone to fragment.\n     * 4.4. Replace data with node original start node, offset original start\n     * offset, count original end offset minus original start offset, and data\n     * the empty string.\n     * 4.5. Return fragment.\n     */\n    if (originalStartNode === originalEndNode &&\n        util_1.Guard.isCharacterDataNode(originalStartNode)) {\n        var clone = NodeAlgorithm_1.node_clone(originalStartNode);\n        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, '');\n        return fragment;\n    }\n    /**\n     * 5. Let common ancestor be original start node.\n     * 6. While common ancestor is not an inclusive ancestor of original end\n     * node, set common ancestor to its own parent.\n     */\n    var commonAncestor = originalStartNode;\n    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {\n        if (commonAncestor._parent === null) {\n            throw new Error(\"Parent node  is null.\");\n        }\n        commonAncestor = commonAncestor._parent;\n    }\n    /**\n     * 7. Let first partially contained child be null.\n     * 8. If original start node is not an inclusive ancestor of original end\n     * node, set first partially contained child to the first child of common\n     * ancestor that is partially contained in range.\n     */\n    var firstPartiallyContainedChild = null;\n    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {\n        try {\n            for (var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var node = _e.value;\n                if (range_isPartiallyContained(node, range)) {\n                    firstPartiallyContainedChild = node;\n                    break;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    /**\n     * 9. Let last partially contained child be null.\n     * 10. If original end node is not an inclusive ancestor of original start\n     * node, set last partially contained child to the last child of common\n     * ancestor that is partially contained in range.\n     */\n    var lastPartiallyContainedChild = null;\n    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {\n        var children = __spread(commonAncestor._children);\n        for (var i = children.length - 1; i > 0; i--) {\n            var node = children[i];\n            if (range_isPartiallyContained(node, range)) {\n                lastPartiallyContainedChild = node;\n                break;\n            }\n        }\n    }\n    /**\n     * 11. Let contained children be a list of all children of common ancestor\n     * that are contained in range, in tree order.\n     * 12. If any member of contained children is a doctype, then throw a\n     * \"HierarchyRequestError\" DOMException.\n     */\n    var containedChildren = [];\n    try {\n        for (var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var child = _g.value;\n            if (range_isContained(child, range)) {\n                if (util_1.Guard.isDocumentTypeNode(child)) {\n                    throw new DOMException_1.HierarchyRequestError();\n                }\n                containedChildren.push(child);\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    var newNode;\n    var newOffset;\n    if (TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {\n        /**\n         * 13. If original start node is an inclusive ancestor of original end node,\n         * set new node to original start node and new offset to original start\n         * offset.\n         */\n        newNode = originalStartNode;\n        newOffset = originalStartOffset;\n    }\n    else {\n        /**\n         * 14. Otherwise:\n         * 14.1. Let reference node equal original start node.\n         * 14.2. While reference node’s parent is not null and is not an inclusive\n         * ancestor of original end node, set reference node to its parent.\n         * 14.3. Set new node to the parent of reference node, and new offset to\n         * one plus reference node’s index.\n         */\n        var referenceNode = originalStartNode;\n        while (referenceNode._parent !== null &&\n            !TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent)) {\n            referenceNode = referenceNode._parent;\n        }\n        /* istanbul ignore next */\n        if (referenceNode._parent === null) {\n            /**\n             * If reference node’s parent is null, it would be the root of range,\n             * so would be an inclusive ancestor of original end node, and we could\n             * not reach this point.\n             */\n            throw new Error(\"Parent node is null.\");\n        }\n        newNode = referenceNode._parent;\n        newOffset = 1 + TreeAlgorithm_1.tree_index(referenceNode);\n    }\n    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {\n        /**\n         * 15. If first partially contained child is a Text, ProcessingInstruction,\n         * or Comment node:\n         * 15.1. Let clone be a clone of original start node.\n         * 15.2. Set the data of clone to the result of substringing data with\n         * node original start node, offset original start offset, and count\n         * original start node’s length minus original start offset.\n         * 15.3. Append clone to fragment.\n         * 15.4. Replace data with node original start node, offset original\n         * start offset, count original start node’s length minus original start\n         * offset, and data the empty string.\n         */\n        var clone = NodeAlgorithm_1.node_clone(originalStartNode);\n        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, '');\n    }\n    else if (firstPartiallyContainedChild !== null) {\n        /**\n         * 16. Otherwise, if first partially contained child is not null:\n         * 16.1. Let clone be a clone of first partially contained child.\n         * 16.2. Append clone to fragment.\n         * 16.3. Let subrange be a new live range whose start is (original start\n         * node, original start offset) and whose end is (first partially\n         * contained child, first partially contained child’s length).\n         * 16.4. Let subfragment be the result of extracting subrange.\n         * 16.5. Append subfragment to clone.\n         */\n        var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n        var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);\n        var subfragment = range_extract(subrange);\n        MutationAlgorithm_1.mutation_append(subfragment, clone);\n    }\n    try {\n        /**\n         * 17. For each contained child in contained children, append contained\n         * child to fragment.\n         */\n        for (var containedChildren_1 = __values(containedChildren), containedChildren_1_1 = containedChildren_1.next(); !containedChildren_1_1.done; containedChildren_1_1 = containedChildren_1.next()) {\n            var child = containedChildren_1_1.value;\n            MutationAlgorithm_1.mutation_append(child, fragment);\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (containedChildren_1_1 && !containedChildren_1_1.done && (_c = containedChildren_1.return)) _c.call(containedChildren_1);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {\n        /**\n         * 18. If last partially contained child is a Text, ProcessingInstruction,\n         * or Comment node:\n         * 18.1. Let clone be a clone of original end node.\n         * 18.2. Set the data of clone to the result of substringing data with\n         * node original end node, offset 0, and count original end offset.\n         * 18.3. Append clone to fragment.\n         * 18.4. Replace data with node original end node, offset 0, count\n         * original end offset, and data the empty string.\n         */\n        var clone = NodeAlgorithm_1.node_clone(originalEndNode);\n        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n        CharacterDataAlgorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, '');\n    }\n    else if (lastPartiallyContainedChild !== null) {\n        /**\n         * 19. Otherwise, if last partially contained child is not null:\n         * 19.1. Let clone be a clone of last partially contained child.\n         * 19.2. Append clone to fragment.\n         * 19.3. Let subrange be a new live range whose start is (last partially\n         * contained child, 0) and whose end is (original end node, original\n         * end offset).\n         * 19.4. Let subfragment be the result of extracting subrange.\n         * 19.5. Append subfragment to clone.\n         */\n        var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n        var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);\n        var subfragment = range_extract(subrange);\n        MutationAlgorithm_1.mutation_append(subfragment, clone);\n    }\n    /**\n     * 20. Set range’s start and end to (new node, new offset).\n     */\n    range._start = [newNode, newOffset];\n    range._end = [newNode, newOffset];\n    /**\n     * 21. Return fragment.\n     */\n    return fragment;\n}\nexports.range_extract = range_extract;\n/**\n * Clones the contents of range as a document fragment.\n *\n * @param range - a range\n */\nfunction range_cloneTheContents(range) {\n    var e_4, _a, e_5, _b, e_6, _c;\n    /**\n     * 1. Let fragment be a new DocumentFragment node whose node document\n     * is range’s start node’s node document.\n     * 2. If range is collapsed, then return fragment.\n     */\n    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);\n    if (range_collapsed(range))\n        return fragment;\n    /**\n     * 3. Let original start node, original start offset, original end node,\n     * and original end offset be range’s start node, start offset, end node,\n     * and end offset, respectively.\n     * 4. If original start node is original end node, and they are a Text,\n     * ProcessingInstruction, or Comment node:\n     * 4.1. Let clone be a clone of original start node.\n     * 4.2. Set the data of clone to the result of substringing data with node\n     * original start node, offset original start offset, and count original end\n     * offset minus original start offset.\n     * 4.3. Append clone to fragment.\n     * 4.5. Return fragment.\n     */\n    var originalStartNode = range._startNode;\n    var originalStartOffset = range._startOffset;\n    var originalEndNode = range._endNode;\n    var originalEndOffset = range._endOffset;\n    if (originalStartNode === originalEndNode &&\n        util_1.Guard.isCharacterDataNode(originalStartNode)) {\n        var clone = NodeAlgorithm_1.node_clone(originalStartNode);\n        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n    }\n    /**\n     * 5. Let common ancestor be original start node.\n     * 6. While common ancestor is not an inclusive ancestor of original end\n     * node, set common ancestor to its own parent.\n     */\n    var commonAncestor = originalStartNode;\n    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {\n        if (commonAncestor._parent === null) {\n            throw new Error(\"Parent node  is null.\");\n        }\n        commonAncestor = commonAncestor._parent;\n    }\n    /**\n     * 7. Let first partially contained child be null.\n     * 8. If original start node is not an inclusive ancestor of original end\n     * node, set first partially contained child to the first child of common\n     * ancestor that is partially contained in range.\n     */\n    var firstPartiallyContainedChild = null;\n    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {\n        try {\n            for (var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var node = _e.value;\n                if (range_isPartiallyContained(node, range)) {\n                    firstPartiallyContainedChild = node;\n                    break;\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    }\n    /**\n     * 9. Let last partially contained child be null.\n     * 10. If original end node is not an inclusive ancestor of original start\n     * node, set last partially contained child to the last child of common\n     * ancestor that is partially contained in range.\n     */\n    var lastPartiallyContainedChild = null;\n    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {\n        var children = __spread(commonAncestor._children);\n        for (var i = children.length - 1; i > 0; i--) {\n            var node = children[i];\n            if (range_isPartiallyContained(node, range)) {\n                lastPartiallyContainedChild = node;\n                break;\n            }\n        }\n    }\n    /**\n     * 11. Let contained children be a list of all children of common ancestor\n     * that are contained in range, in tree order.\n     * 12. If any member of contained children is a doctype, then throw a\n     * \"HierarchyRequestError\" DOMException.\n     */\n    var containedChildren = [];\n    try {\n        for (var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var child = _g.value;\n            if (range_isContained(child, range)) {\n                if (util_1.Guard.isDocumentTypeNode(child)) {\n                    throw new DOMException_1.HierarchyRequestError();\n                }\n                containedChildren.push(child);\n            }\n        }\n    }\n    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n    finally {\n        try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        }\n        finally { if (e_5) throw e_5.error; }\n    }\n    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {\n        /**\n         * 13. If first partially contained child is a Text, ProcessingInstruction,\n         * or Comment node:\n         * 13.1. Let clone be a clone of original start node.\n         * 13.2. Set the data of clone to the result of substringing data with\n         * node original start node, offset original start offset, and count\n         * original start node’s length minus original start offset.\n         * 13.3. Append clone to fragment.\n         */\n        var clone = NodeAlgorithm_1.node_clone(originalStartNode);\n        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n    }\n    else if (firstPartiallyContainedChild !== null) {\n        /**\n         * 14. Otherwise, if first partially contained child is not null:\n         * 14.1. Let clone be a clone of first partially contained child.\n         * 14.2. Append clone to fragment.\n         * 14.3. Let subrange be a new live range whose start is (original start\n         * node, original start offset) and whose end is (first partially\n         * contained child, first partially contained child’s length).\n         * 14.4. Let subfragment be the result of cloning the contents of\n         * subrange.\n         * 14.5. Append subfragment to clone.\n         */\n        var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n        var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);\n        var subfragment = range_cloneTheContents(subrange);\n        MutationAlgorithm_1.mutation_append(subfragment, clone);\n    }\n    try {\n        /**\n         * 15. For each contained child in contained children, append contained\n         * child to fragment.\n         * 15.1. Let clone be a clone of contained child with the clone children\n         * flag set.\n         * 15.2. Append clone to fragment.\n         */\n        for (var containedChildren_2 = __values(containedChildren), containedChildren_2_1 = containedChildren_2.next(); !containedChildren_2_1.done; containedChildren_2_1 = containedChildren_2.next()) {\n            var child = containedChildren_2_1.value;\n            var clone = NodeAlgorithm_1.node_clone(child);\n            MutationAlgorithm_1.mutation_append(clone, fragment);\n        }\n    }\n    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n    finally {\n        try {\n            if (containedChildren_2_1 && !containedChildren_2_1.done && (_c = containedChildren_2.return)) _c.call(containedChildren_2);\n        }\n        finally { if (e_6) throw e_6.error; }\n    }\n    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {\n        /**\n         * 16. If last partially contained child is a Text, ProcessingInstruction,\n         * or Comment node:\n         * 16.1. Let clone be a clone of original end node.\n         * 16.2. Set the data of clone to the result of substringing data with\n         * node original end node, offset 0, and count original end offset.\n         * 16.3. Append clone to fragment.\n         */\n        var clone = NodeAlgorithm_1.node_clone(originalEndNode);\n        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);\n        MutationAlgorithm_1.mutation_append(clone, fragment);\n    }\n    else if (lastPartiallyContainedChild !== null) {\n        /**\n         * 17. Otherwise, if last partially contained child is not null:\n         * 17.1. Let clone be a clone of last partially contained child.\n         * 17.2. Append clone to fragment.\n         * 17.3. Let subrange be a new live range whose start is (last partially\n         * contained child, 0) and whose end is (original end node, original\n         * end offset).\n         * 17.4. Let subfragment be the result of cloning the contents of subrange.\n         * 17.5. Append subfragment to clone.\n         */\n        var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);\n        fragment.append(clone);\n        var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);\n        var subfragment = range_extract(subrange);\n        MutationAlgorithm_1.mutation_append(subfragment, clone);\n    }\n    /**\n     * 18. Return fragment.\n     */\n    return fragment;\n}\nexports.range_cloneTheContents = range_cloneTheContents;\n/**\n * Inserts a node into a range at the start boundary point.\n *\n * @param node - node to insert\n * @param range - a range\n */\nfunction range_insert(node, range) {\n    var e_7, _a;\n    /**\n     * 1. If range’s start node is a ProcessingInstruction or Comment node, is a\n     * Text node whose parent is null, or is node, then throw a\n     * \"HierarchyRequestError\" DOMException.\n     */\n    if (util_1.Guard.isProcessingInstructionNode(range._startNode) ||\n        util_1.Guard.isCommentNode(range._startNode) ||\n        (util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null) ||\n        range._startNode === node) {\n        throw new DOMException_1.HierarchyRequestError();\n    }\n    /**\n     * 2. Let referenceNode be null.\n     * 3. If range’s start node is a Text node, set referenceNode to that Text\n     * node.\n     * 4. Otherwise, set referenceNode to the child of start node whose index is\n     * start offset, and null if there is no such child.\n     */\n    var referenceNode = null;\n    if (util_1.Guard.isTextNode(range._startNode)) {\n        referenceNode = range._startNode;\n    }\n    else {\n        var index = 0;\n        try {\n            for (var _b = __values(range._startNode._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var child = _c.value;\n                if (index === range._startOffset) {\n                    referenceNode = child;\n                    break;\n                }\n                index++;\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n    }\n    /**\n     * 5. Let parent be range’s start node if referenceNode is null, and\n     * referenceNode’s parent otherwise.\n     */\n    var parent;\n    if (referenceNode === null) {\n        parent = range._startNode;\n    }\n    else {\n        if (referenceNode._parent === null) {\n            throw new Error(\"Parent node is null.\");\n        }\n        parent = referenceNode._parent;\n    }\n    /**\n     * 6. Ensure pre-insertion validity of node into parent before referenceNode.\n     */\n    MutationAlgorithm_1.mutation_ensurePreInsertionValidity(node, parent, referenceNode);\n    /**\n     * 7. If range’s start node is a Text node, set referenceNode to the result\n     * of splitting it with offset range’s start offset.\n     */\n    if (util_1.Guard.isTextNode(range._startNode)) {\n        referenceNode = TextAlgorithm_1.text_split(range._startNode, range._startOffset);\n    }\n    /**\n     * 8. If node is referenceNode, set referenceNode to its next sibling.\n     */\n    if (node === referenceNode) {\n        referenceNode = node._nextSibling;\n    }\n    /**\n     * 9. If node’s parent is not null, remove node from its parent.\n     */\n    if (node._parent !== null) {\n        MutationAlgorithm_1.mutation_remove(node, node._parent);\n    }\n    /**\n     * 10. Let newOffset be parent’s length if referenceNode is null, and\n     * referenceNode’s index otherwise.\n     */\n    var newOffset = (referenceNode === null ?\n        TreeAlgorithm_1.tree_nodeLength(parent) : TreeAlgorithm_1.tree_index(referenceNode));\n    /**\n     * 11. Increase newOffset by node’s length if node is a DocumentFragment\n     * node, and one otherwise.\n     */\n    if (util_1.Guard.isDocumentFragmentNode(node)) {\n        newOffset += TreeAlgorithm_1.tree_nodeLength(node);\n    }\n    else {\n        newOffset++;\n    }\n    /**\n     * 12. Pre-insert node into parent before referenceNode.\n     */\n    MutationAlgorithm_1.mutation_preInsert(node, parent, referenceNode);\n    /**\n     * 13. If range is collapsed, then set range’s end to (parent, newOffset).\n     */\n    if (range_collapsed(range)) {\n        range._end = [parent, newOffset];\n    }\n}\nexports.range_insert = range_insert;\n/**\n * Traverses through all contained nodes of a range.\n *\n * @param range - a range\n */\nfunction range_getContainedNodes(range) {\n    var _a;\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var container = range.commonAncestorContainer;\n            var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);\n            return {\n                next: function () {\n                    while (currentNode && !range_isContained(currentNode, range)) {\n                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.range_getContainedNodes = range_getContainedNodes;\n/**\n * Traverses through all partially contained nodes of a range.\n *\n * @param range - a range\n */\nfunction range_getPartiallyContainedNodes(range) {\n    var _a;\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var container = range.commonAncestorContainer;\n            var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);\n            return {\n                next: function () {\n                    while (currentNode && !range_isPartiallyContained(currentNode, range)) {\n                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;\n//# sourceMappingURL=RangeAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMException_1 = require(\"../dom/DOMException\");\n/**\n * Matches elements with the given selectors.\n *\n * @param selectors - selectors\n * @param node - the node to match against\n */\nfunction selectors_scopeMatchASelectorsString(selectors, node) {\n    /**\n     * TODO: Selectors\n     * 1. Let s be the result of parse a selector selectors. [SELECTORS4]\n     * 2. If s is failure, then throw a \"SyntaxError\" DOMException.\n     * 3. Return the result of match a selector against a tree with s and node’s\n     * root using scoping root node. [SELECTORS4].\n     */\n    throw new DOMException_1.NotSupportedError();\n}\nexports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;\n//# sourceMappingURL=SelectorsAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar util_1 = require(\"../util\");\nvar util_2 = require(\"@oozcitak/util\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar MutationObserverAlgorithm_1 = require(\"./MutationObserverAlgorithm\");\n/**\n * Signals a slot change to the given slot.\n *\n * @param slot - a slot\n */\nfunction shadowTree_signalASlotChange(slot) {\n    /**\n     * 1. Append slot to slot’s relevant agent’s signal slots.\n     * 2. Queue a mutation observer microtask.\n     */\n    var window = DOMImpl_1.dom.window;\n    window._signalSlots.add(slot);\n    MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask();\n}\nexports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;\n/**\n * Determines whether a the shadow tree of the given element node is\n * connected to a document node.\n *\n * @param element - an element node of the shadow tree\n */\nfunction shadowTree_isConnected(element) {\n    /**\n     * An element is connected if its shadow-including root is a document.\n     */\n    return util_1.Guard.isDocumentNode(TreeAlgorithm_1.tree_rootNode(element, true));\n}\nexports.shadowTree_isConnected = shadowTree_isConnected;\n/**\n * Determines whether a slotable is assigned.\n *\n * @param slotable - a slotable\n */\nfunction shadowTree_isAssigned(slotable) {\n    /**\n     * A slotable is assigned if its assigned slot is non-null.\n     */\n    return (slotable._assignedSlot !== null);\n}\nexports.shadowTree_isAssigned = shadowTree_isAssigned;\n/**\n * Finds a slot for the given slotable.\n *\n * @param slotable - a slotable\n * @param openFlag - `true` to search open shadow tree's only\n */\nfunction shadowTree_findASlot(slotable, openFlag) {\n    if (openFlag === void 0) { openFlag = false; }\n    /**\n     * 1. If slotable’s parent is null, then return null.\n     * 2. Let shadow be slotable’s parent’s shadow root.\n     * 3. If shadow is null, then return null.\n     * 4. If the open flag is set and shadow’s mode is not \"open\", then\n     * return null.\n     * 5. Return the first slot in tree order in shadow’s descendants whose name\n     * is slotable’s name, if any, and null otherwise.\n     */\n    var node = util_1.Cast.asNode(slotable);\n    var parent = node._parent;\n    if (parent === null)\n        return null;\n    var shadow = parent._shadowRoot || null;\n    if (shadow === null)\n        return null;\n    if (openFlag && shadow._mode !== \"open\")\n        return null;\n    var child = TreeAlgorithm_1.tree_getFirstDescendantNode(shadow, false, true, function (e) { return util_1.Guard.isSlot(e); });\n    while (child !== null) {\n        if (child._name === slotable._name)\n            return child;\n        child = TreeAlgorithm_1.tree_getNextDescendantNode(shadow, child, false, true, function (e) { return util_1.Guard.isSlot(e); });\n    }\n    return null;\n}\nexports.shadowTree_findASlot = shadowTree_findASlot;\n/**\n * Finds slotables for the given slot.\n *\n * @param slot - a slot\n */\nfunction shadowTree_findSlotables(slot) {\n    var e_1, _a;\n    /**\n     * 1. Let result be an empty list.\n     * 2. If slot’s root is not a shadow root, then return result.\n     */\n    var result = [];\n    var root = TreeAlgorithm_1.tree_rootNode(slot);\n    if (!util_1.Guard.isShadowRoot(root))\n        return result;\n    /**\n     * 3. Let host be slot’s root’s host.\n     * 4. For each slotable child of host, slotable, in tree order:\n     */\n    var host = root._host;\n    try {\n        for (var _b = __values(host._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var slotable = _c.value;\n            if (util_1.Guard.isSlotable(slotable)) {\n                /**\n                 * 4.1. Let foundSlot be the result of finding a slot given slotable.\n                 * 4.2. If foundSlot is slot, then append slotable to result.\n                 */\n                var foundSlot = shadowTree_findASlot(slotable);\n                if (foundSlot === slot) {\n                    result.push(slotable);\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    /**\n     * 5. Return result.\n     */\n    return result;\n}\nexports.shadowTree_findSlotables = shadowTree_findSlotables;\n/**\n * Finds slotables for the given slot.\n *\n * @param slot - a slot\n */\nfunction shadowTree_findFlattenedSlotables(slot) {\n    var e_2, _a, e_3, _b;\n    /**\n     * 1. Let result be an empty list.\n     * 2. If slot’s root is not a shadow root, then return result.\n     */\n    var result = [];\n    var root = TreeAlgorithm_1.tree_rootNode(slot);\n    if (!util_1.Guard.isShadowRoot(root))\n        return result;\n    /**\n     * 3. Let slotables be the result of finding slotables given slot.\n     * 4. If slotables is the empty list, then append each slotable child of\n     * slot, in tree order, to slotables.\n     */\n    var slotables = shadowTree_findSlotables(slot);\n    if (util_2.isEmpty(slotables)) {\n        try {\n            for (var _c = __values(slot._children), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var slotable = _d.value;\n                if (util_1.Guard.isSlotable(slotable)) {\n                    slotables.push(slotable);\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    try {\n        /**\n         * 5. For each node in slotables:\n         */\n        for (var slotables_1 = __values(slotables), slotables_1_1 = slotables_1.next(); !slotables_1_1.done; slotables_1_1 = slotables_1.next()) {\n            var node = slotables_1_1.value;\n            /**\n             * 5.1. If node is a slot whose root is a shadow root, then:\n             */\n            if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(node))) {\n                /**\n                 * 5.1.1. Let temporaryResult be the result of finding flattened slotables given node.\n                 * 5.1.2. Append each slotable in temporaryResult, in order, to result.\n                 */\n                var temporaryResult = shadowTree_findFlattenedSlotables(node);\n                result.push.apply(result, __spread(temporaryResult));\n            }\n            else {\n                /**\n                 * 5.2. Otherwise, append node to result.\n                 */\n                result.push(node);\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (slotables_1_1 && !slotables_1_1.done && (_b = slotables_1.return)) _b.call(slotables_1);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    /**\n     * 6. Return result.\n     */\n    return result;\n}\nexports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;\n/**\n * Assigns slotables to the given slot.\n *\n * @param slot - a slot\n */\nfunction shadowTree_assignSlotables(slot) {\n    var e_4, _a;\n    /**\n     * 1. Let slotables be the result of finding slotables for slot.\n     * 2. If slotables and slot’s assigned nodes are not identical, then run\n     * signal a slot change for slot.\n     */\n    var slotables = shadowTree_findSlotables(slot);\n    if (slotables.length === slot._assignedNodes.length) {\n        var nodesIdentical = true;\n        for (var i = 0; i < slotables.length; i++) {\n            if (slotables[i] !== slot._assignedNodes[i]) {\n                nodesIdentical = false;\n                break;\n            }\n        }\n        if (!nodesIdentical) {\n            shadowTree_signalASlotChange(slot);\n        }\n    }\n    /**\n     * 3. Set slot’s assigned nodes to slotables.\n     * 4. For each slotable in slotables, set slotable’s assigned slot to slot.\n     */\n    slot._assignedNodes = slotables;\n    try {\n        for (var slotables_2 = __values(slotables), slotables_2_1 = slotables_2.next(); !slotables_2_1.done; slotables_2_1 = slotables_2.next()) {\n            var slotable = slotables_2_1.value;\n            slotable._assignedSlot = slot;\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (slotables_2_1 && !slotables_2_1.done && (_a = slotables_2.return)) _a.call(slotables_2);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n}\nexports.shadowTree_assignSlotables = shadowTree_assignSlotables;\n/**\n * Assigns slotables to all nodes of a tree.\n *\n * @param root - root node\n */\nfunction shadowTree_assignSlotablesForATree(root) {\n    /**\n     * To assign slotables for a tree, given a node root, run assign slotables\n     * for each slot slot in root’s inclusive descendants, in tree order.\n     */\n    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(root, true, false, function (e) { return util_1.Guard.isSlot(e); });\n    while (descendant !== null) {\n        shadowTree_assignSlotables(descendant);\n        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(root, descendant, true, false, function (e) { return util_1.Guard.isSlot(e); });\n    }\n}\nexports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;\n/**\n * Assigns a slot to a slotables.\n *\n * @param slotable - a slotable\n */\nfunction shadowTree_assignASlot(slotable) {\n    /**\n     * 1. Let slot be the result of finding a slot with slotable.\n     * 2. If slot is non-null, then run assign slotables for slot.\n     */\n    var slot = shadowTree_findASlot(slotable);\n    if (slot !== null) {\n        shadowTree_assignSlotables(slot);\n    }\n}\nexports.shadowTree_assignASlot = shadowTree_assignASlot;\n//# sourceMappingURL=ShadowTreeAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"../dom/DOMImpl\");\nvar util_1 = require(\"../util\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar CreateAlgorithm_1 = require(\"./CreateAlgorithm\");\nvar TreeAlgorithm_1 = require(\"./TreeAlgorithm\");\nvar CharacterDataAlgorithm_1 = require(\"./CharacterDataAlgorithm\");\nvar MutationAlgorithm_1 = require(\"./MutationAlgorithm\");\n/**\n * Returns node with its adjacent text and cdata node siblings.\n *\n * @param node - a node\n * @param self - whether to include node itself\n */\nfunction text_contiguousTextNodes(node, self) {\n    var _a;\n    if (self === void 0) { self = false; }\n    /**\n     * The contiguous Text nodes of a node node are node, node’s previous\n     * sibling Text node, if any, and its contiguous Text nodes, and node’s next\n     * sibling Text node, if any, and its contiguous Text nodes, avoiding any\n     * duplicates.\n     */\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var currentNode = node;\n            while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {\n                currentNode = currentNode._previousSibling;\n            }\n            return {\n                next: function () {\n                    if (currentNode && (!self && currentNode === node)) {\n                        if (util_1.Guard.isTextNode(currentNode._nextSibling)) {\n                            currentNode = currentNode._nextSibling;\n                        }\n                        else {\n                            currentNode = null;\n                        }\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        if (util_1.Guard.isTextNode(currentNode._nextSibling)) {\n                            currentNode = currentNode._nextSibling;\n                        }\n                        else {\n                            currentNode = null;\n                        }\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.text_contiguousTextNodes = text_contiguousTextNodes;\n/**\n * Returns node with its adjacent text node siblings.\n *\n * @param node - a node\n * @param self - whether to include node itself\n */\nfunction text_contiguousExclusiveTextNodes(node, self) {\n    var _a;\n    if (self === void 0) { self = false; }\n    /**\n     * The contiguous exclusive Text nodes of a node node are node, node’s\n     * previous sibling exclusive Text node, if any, and its contiguous\n     * exclusive Text nodes, and node’s next sibling exclusive Text node,\n     * if any, and its contiguous exclusive Text nodes, avoiding any duplicates.\n     */\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var currentNode = node;\n            while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {\n                currentNode = currentNode._previousSibling;\n            }\n            return {\n                next: function () {\n                    if (currentNode && (!self && currentNode === node)) {\n                        if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {\n                            currentNode = currentNode._nextSibling;\n                        }\n                        else {\n                            currentNode = null;\n                        }\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {\n                            currentNode = currentNode._nextSibling;\n                        }\n                        else {\n                            currentNode = null;\n                        }\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;\n/**\n * Returns the concatenation of the data of all the Text node descendants of\n * node, in tree order.\n *\n * @param node - a node\n */\nfunction text_descendantTextContent(node) {\n    /**\n     * The descendant text content of a node node is the concatenation of the\n     * data of all the Text node descendants of node, in tree order.\n     */\n    var contents = '';\n    var text = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, false, function (e) { return util_1.Guard.isTextNode(e); });\n    while (text !== null) {\n        contents += text._data;\n        text = TreeAlgorithm_1.tree_getNextDescendantNode(node, text, false, false, function (e) { return util_1.Guard.isTextNode(e); });\n    }\n    return contents;\n}\nexports.text_descendantTextContent = text_descendantTextContent;\n/**\n * Splits data at the given offset and returns the remainder as a text\n * node.\n *\n * @param node - a text node\n * @param offset - the offset at which to split the nodes.\n */\nfunction text_split(node, offset) {\n    var e_1, _a;\n    /**\n     * 1. Let length be node’s length.\n     * 2. If offset is greater than length, then throw an \"IndexSizeError\"\n     * DOMException.\n     */\n    var length = node._data.length;\n    if (offset > length) {\n        throw new DOMException_1.IndexSizeError();\n    }\n    /**\n     * 3. Let count be length minus offset.\n     * 4. Let new data be the result of substringing data with node node,\n     * offset offset, and count count.\n     * 5. Let new node be a new Text node, with the same node document as node.\n     * Set new node’s data to new data.\n     * 6. Let parent be node’s parent.\n     * 7. If parent is not null, then:\n     */\n    var count = length - offset;\n    var newData = CharacterDataAlgorithm_1.characterData_substringData(node, offset, count);\n    var newNode = CreateAlgorithm_1.create_text(node._nodeDocument, newData);\n    var parent = node._parent;\n    if (parent !== null) {\n        /**\n         * 7.1. Insert new node into parent before node’s next sibling.\n         */\n        MutationAlgorithm_1.mutation_insert(newNode, parent, node._nextSibling);\n        try {\n            /**\n             * 7.2. For each live range whose start node is node and start offset is\n             * greater than offset, set its start node to new node and decrease its\n             * start offset by offset.\n             * 7.3. For each live range whose end node is node and end offset is greater\n             * than offset, set its end node to new node and decrease its end offset\n             * by offset.\n             * 7.4. For each live range whose start node is parent and start offset is\n             * equal to the index of node plus 1, increase its start offset by 1.\n             * 7.5. For each live range whose end node is parent and end offset is equal\n             * to the index of node plus 1, increase its end offset by 1.\n             */\n            for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var range = _c.value;\n                if (range._start[0] === node && range._start[1] > offset) {\n                    range._start[0] = newNode;\n                    range._start[1] -= offset;\n                }\n                if (range._end[0] === node && range._end[1] > offset) {\n                    range._end[0] = newNode;\n                    range._end[1] -= offset;\n                }\n                var index = TreeAlgorithm_1.tree_index(node);\n                if (range._start[0] === parent && range._start[1] === index + 1) {\n                    range._start[1]++;\n                }\n                if (range._end[0] === parent && range._end[1] === index + 1) {\n                    range._end[1]++;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    /**\n     * 8. Replace data with node node, offset offset, count count, and data\n     * the empty string.\n     * 9. Return new node.\n     */\n    CharacterDataAlgorithm_1.characterData_replaceData(node, offset, count, '');\n    return newNode;\n}\nexports.text_split = text_split;\n//# sourceMappingURL=TextAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar DOMException_1 = require(\"../dom/DOMException\");\n/**\n * Applies the filter to the given node and returns the result.\n *\n * @param traverser - the `NodeIterator` or `TreeWalker` instance\n * @param node - the node to filter\n */\nfunction traversal_filter(traverser, node) {\n    /**\n     * 1. If traverser’s active flag is set, then throw an \"InvalidStateError\"\n     * DOMException.\n     */\n    if (traverser._activeFlag) {\n        throw new DOMException_1.InvalidStateError();\n    }\n    /**\n     * 2. Let n be node’s nodeType attribute value − 1.\n     */\n    var n = node._nodeType - 1;\n    /**\n     * 3. If the nth bit (where 0 is the least significant bit) of traverser’s\n     * whatToShow is not set, then return FILTER_SKIP.\n     */\n    var mask = 1 << n;\n    if ((traverser.whatToShow & mask) === 0) {\n        return interfaces_1.FilterResult.Skip;\n    }\n    /**\n     * 4. If traverser’s filter is null, then return FILTER_ACCEPT.\n     */\n    if (!traverser.filter) {\n        return interfaces_1.FilterResult.Accept;\n    }\n    /**\n     * 5. Set traverser’s active flag.\n     */\n    traverser._activeFlag = true;\n    /**\n     * 6. Let result be the return value of call a user object’s operation with\n     * traverser’s filter, \"acceptNode\", and « node ». If this throws an\n     * exception, then unset traverser’s active flag and rethrow the exception.\n     */\n    var result = interfaces_1.FilterResult.Reject;\n    try {\n        result = traverser.filter.acceptNode(node);\n    }\n    catch (err) {\n        traverser._activeFlag = false;\n        throw err;\n    }\n    /**\n     * 7. Unset traverser’s active flag.\n     * 8. Return result.\n     */\n    traverser._activeFlag = false;\n    return result;\n}\nexports.traversal_filter = traversal_filter;\n//# sourceMappingURL=TraversalAlgorithm.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar interfaces_1 = require(\"../dom/interfaces\");\n/**\n * Gets the next descendant of the given node of the tree rooted at `root`\n * in depth-first pre-order.\n *\n * @param root - root node of the tree\n * @param node - a node\n * @param shadow - whether to visit shadow tree nodes\n */\nfunction _getNextDescendantNode(root, node, shadow) {\n    if (shadow === void 0) { shadow = false; }\n    // traverse shadow tree\n    if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {\n        if (node.shadowRoot._firstChild)\n            return node.shadowRoot._firstChild;\n    }\n    // traverse child nodes\n    if (node._firstChild)\n        return node._firstChild;\n    if (node === root)\n        return null;\n    // traverse siblings\n    if (node._nextSibling)\n        return node._nextSibling;\n    // traverse parent's next sibling\n    var parent = node._parent;\n    while (parent && parent !== root) {\n        if (parent._nextSibling)\n            return parent._nextSibling;\n        parent = parent._parent;\n    }\n    return null;\n}\nfunction _emptyIterator() {\n    var _a;\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            return {\n                next: function () {\n                    return { done: true, value: null };\n                }\n            };\n        },\n        _a;\n}\n/**\n * Returns the first descendant node of the tree rooted at `node` in\n * depth-first pre-order.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param shadow - whether to visit shadow tree nodes\n * @param filter - a function to filter nodes\n */\nfunction tree_getFirstDescendantNode(node, self, shadow, filter) {\n    if (self === void 0) { self = false; }\n    if (shadow === void 0) { shadow = false; }\n    var firstNode = (self ? node : _getNextDescendantNode(node, node, shadow));\n    while (firstNode && filter && !filter(firstNode)) {\n        firstNode = _getNextDescendantNode(node, firstNode, shadow);\n    }\n    return firstNode;\n}\nexports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;\n/**\n * Returns the next descendant node of the tree rooted at `node` in\n * depth-first pre-order.\n *\n * @param node - root node of the tree\n * @param currentNode - current descendant node\n * @param self - whether to include `node` in traversal\n * @param shadow - whether to visit shadow tree nodes\n * @param filter - a function to filter nodes\n */\nfunction tree_getNextDescendantNode(node, currentNode, self, shadow, filter) {\n    if (self === void 0) { self = false; }\n    if (shadow === void 0) { shadow = false; }\n    var nextNode = _getNextDescendantNode(node, currentNode, shadow);\n    while (nextNode && filter && !filter(nextNode)) {\n        nextNode = _getNextDescendantNode(node, nextNode, shadow);\n    }\n    return nextNode;\n}\nexports.tree_getNextDescendantNode = tree_getNextDescendantNode;\n/**\n * Traverses through all descendant nodes of the tree rooted at\n * `node` in depth-first pre-order.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param shadow - whether to visit shadow tree nodes\n * @param filter - a function to filter nodes\n */\nfunction tree_getDescendantNodes(node, self, shadow, filter) {\n    var _a;\n    if (self === void 0) { self = false; }\n    if (shadow === void 0) { shadow = false; }\n    if (!self && node._children.size === 0) {\n        return _emptyIterator();\n    }\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var currentNode = (self ? node : _getNextDescendantNode(node, node, shadow));\n            return {\n                next: function () {\n                    while (currentNode && filter && !filter(currentNode)) {\n                        currentNode = _getNextDescendantNode(node, currentNode, shadow);\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        currentNode = _getNextDescendantNode(node, currentNode, shadow);\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.tree_getDescendantNodes = tree_getDescendantNodes;\n/**\n * Traverses through all descendant element nodes of the tree rooted at\n * `node` in depth-first preorder.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param shadow - whether to visit shadow tree nodes\n * @param filter - a function to filter nodes\n */\nfunction tree_getDescendantElements(node, self, shadow, filter) {\n    var _a;\n    if (self === void 0) { self = false; }\n    if (shadow === void 0) { shadow = false; }\n    if (!self && node._children.size === 0) {\n        return _emptyIterator();\n    }\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var it = tree_getDescendantNodes(node, self, shadow, function (e) { return util_1.Guard.isElementNode(e); })[Symbol.iterator]();\n            var currentNode = it.next().value;\n            return {\n                next: function () {\n                    while (currentNode && filter && !filter(currentNode)) {\n                        currentNode = it.next().value;\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        currentNode = it.next().value;\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.tree_getDescendantElements = tree_getDescendantElements;\n/**\n * Traverses through all sibling nodes of `node`.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param filter - a function to filter nodes\n */\nfunction tree_getSiblingNodes(node, self, filter) {\n    var _a;\n    if (self === void 0) { self = false; }\n    if (!node._parent || node._parent._children.size === 0) {\n        return _emptyIterator();\n    }\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var currentNode = node._parent ? node._parent._firstChild : null;\n            return {\n                next: function () {\n                    while (currentNode && (filter && !filter(currentNode) || (!self && currentNode === node))) {\n                        currentNode = currentNode._nextSibling;\n                    }\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        currentNode = currentNode._nextSibling;\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.tree_getSiblingNodes = tree_getSiblingNodes;\n/**\n * Gets the first ancestor of `node` in reverse tree order.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param filter - a function to filter nodes\n */\nfunction tree_getFirstAncestorNode(node, self, filter) {\n    if (self === void 0) { self = false; }\n    var firstNode = self ? node : node._parent;\n    while (firstNode && filter && !filter(firstNode)) {\n        firstNode = firstNode._parent;\n    }\n    return firstNode;\n}\nexports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;\n/**\n * Gets the first ancestor of `node` in reverse tree order.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param filter - a function to filter nodes\n */\nfunction tree_getNextAncestorNode(node, currentNode, self, filter) {\n    if (self === void 0) { self = false; }\n    var nextNode = currentNode._parent;\n    while (nextNode && filter && !filter(nextNode)) {\n        nextNode = nextNode._parent;\n    }\n    return nextNode;\n}\nexports.tree_getNextAncestorNode = tree_getNextAncestorNode;\n/**\n * Traverses through all ancestor nodes `node` in reverse tree order.\n *\n * @param node - root node of the tree\n * @param self - whether to include `node` in traversal\n * @param filter - a function to filter nodes\n */\nfunction tree_getAncestorNodes(node, self, filter) {\n    var _a;\n    if (self === void 0) { self = false; }\n    if (!self && !node._parent) {\n        return _emptyIterator();\n    }\n    return _a = {},\n        _a[Symbol.iterator] = function () {\n            var currentNode = tree_getFirstAncestorNode(node, self, filter);\n            return {\n                next: function () {\n                    if (currentNode === null) {\n                        return { done: true, value: null };\n                    }\n                    else {\n                        var result = { done: false, value: currentNode };\n                        currentNode = tree_getNextAncestorNode(node, currentNode, self, filter);\n                        return result;\n                    }\n                }\n            };\n        },\n        _a;\n}\nexports.tree_getAncestorNodes = tree_getAncestorNodes;\n/**\n * Returns the common ancestor of the given nodes.\n *\n * @param nodeA - a node\n * @param nodeB - a node\n */\nfunction tree_getCommonAncestor(nodeA, nodeB) {\n    if (nodeA === nodeB) {\n        return nodeA._parent;\n    }\n    // lists of parent nodes\n    var parentsA = [];\n    var parentsB = [];\n    var pA = tree_getFirstAncestorNode(nodeA, true);\n    while (pA !== null) {\n        parentsA.push(pA);\n        pA = tree_getNextAncestorNode(nodeA, pA, true);\n    }\n    var pB = tree_getFirstAncestorNode(nodeB, true);\n    while (pB !== null) {\n        parentsB.push(pB);\n        pB = tree_getNextAncestorNode(nodeB, pB, true);\n    }\n    // walk through parents backwards until they differ\n    var pos1 = parentsA.length;\n    var pos2 = parentsB.length;\n    var parent = null;\n    for (var i = Math.min(pos1, pos2); i > 0; i--) {\n        var parent1 = parentsA[--pos1];\n        var parent2 = parentsB[--pos2];\n        if (parent1 !== parent2) {\n            break;\n        }\n        parent = parent1;\n    }\n    return parent;\n}\nexports.tree_getCommonAncestor = tree_getCommonAncestor;\n/**\n * Returns the node following `node` in depth-first preorder.\n *\n * @param root - root of the subtree\n * @param node - a node\n */\nfunction tree_getFollowingNode(root, node) {\n    if (node._firstChild) {\n        return node._firstChild;\n    }\n    else if (node._nextSibling) {\n        return node._nextSibling;\n    }\n    else {\n        while (true) {\n            var parent = node._parent;\n            if (parent === null || parent === root) {\n                return null;\n            }\n            else if (parent._nextSibling) {\n                return parent._nextSibling;\n            }\n            else {\n                node = parent;\n            }\n        }\n    }\n}\nexports.tree_getFollowingNode = tree_getFollowingNode;\n/**\n * Returns the node preceding `node` in depth-first preorder.\n *\n * @param root - root of the subtree\n * @param node - a node\n */\nfunction tree_getPrecedingNode(root, node) {\n    if (node === root) {\n        return null;\n    }\n    if (node._previousSibling) {\n        node = node._previousSibling;\n        if (node._lastChild) {\n            return node._lastChild;\n        }\n        else {\n            return node;\n        }\n    }\n    else {\n        return node._parent;\n    }\n}\nexports.tree_getPrecedingNode = tree_getPrecedingNode;\n/**\n * Determines if the node tree is constrained. A node tree is\n * constrained as follows, expressed as a relationship between the\n * type of node and its allowed children:\n *  - Document (In tree order)\n *    * Zero or more nodes each of which is ProcessingInstruction\n *      or Comment.\n *    * Optionally one DocumentType node.\n *    * Zero or more nodes each of which is ProcessingInstruction\n *      or Comment.\n *    * Optionally one Element node.\n *    * Zero or more nodes each of which is ProcessingInstruction\n *      or Comment.\n *  - DocumentFragment, Element\n *    * Zero or more nodes each of which is Element, Text,\n *      ProcessingInstruction, or Comment.\n *  - DocumentType, Text, ProcessingInstruction, Comment\n *    * None.\n *\n * @param node - the root of the tree\n */\nfunction tree_isConstrained(node) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    switch (node._nodeType) {\n        case interfaces_1.NodeType.Document:\n            var hasDocType = false;\n            var hasElement = false;\n            try {\n                for (var _d = __values(node._children), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var childNode = _e.value;\n                    switch (childNode._nodeType) {\n                        case interfaces_1.NodeType.ProcessingInstruction:\n                        case interfaces_1.NodeType.Comment:\n                            break;\n                        case interfaces_1.NodeType.DocumentType:\n                            if (hasDocType || hasElement)\n                                return false;\n                            hasDocType = true;\n                            break;\n                        case interfaces_1.NodeType.Element:\n                            if (hasElement)\n                                return false;\n                            hasElement = true;\n                            break;\n                        default:\n                            return false;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            break;\n        case interfaces_1.NodeType.DocumentFragment:\n        case interfaces_1.NodeType.Element:\n            try {\n                for (var _f = __values(node._children), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var childNode = _g.value;\n                    switch (childNode._nodeType) {\n                        case interfaces_1.NodeType.Element:\n                        case interfaces_1.NodeType.Text:\n                        case interfaces_1.NodeType.ProcessingInstruction:\n                        case interfaces_1.NodeType.CData:\n                        case interfaces_1.NodeType.Comment:\n                            break;\n                        default:\n                            return false;\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            break;\n        case interfaces_1.NodeType.DocumentType:\n        case interfaces_1.NodeType.Text:\n        case interfaces_1.NodeType.ProcessingInstruction:\n        case interfaces_1.NodeType.CData:\n        case interfaces_1.NodeType.Comment:\n            return (!node.hasChildNodes());\n    }\n    try {\n        for (var _h = __values(node._children), _j = _h.next(); !_j.done; _j = _h.next()) {\n            var childNode = _j.value;\n            // recursively check child nodes\n            if (!tree_isConstrained(childNode))\n                return false;\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return true;\n}\nexports.tree_isConstrained = tree_isConstrained;\n/**\n * Returns the length of a node.\n *\n * @param node - a node to check\n */\nfunction tree_nodeLength(node) {\n    /**\n        * To determine the length of a node node, switch on node:\n        * - DocumentType\n        * Zero.\n        * - Text\n        * - ProcessingInstruction\n        * - Comment\n        * Its data’s length.\n        * - Any other node\n        * Its number of children.\n        */\n    if (util_1.Guard.isDocumentTypeNode(node)) {\n        return 0;\n    }\n    else if (util_1.Guard.isCharacterDataNode(node)) {\n        return node._data.length;\n    }\n    else {\n        return node._children.size;\n    }\n}\nexports.tree_nodeLength = tree_nodeLength;\n/**\n * Determines if a node is empty.\n *\n * @param node - a node to check\n */\nfunction tree_isEmpty(node) {\n    /**\n        * A node is considered empty if its length is zero.\n        */\n    return (tree_nodeLength(node) === 0);\n}\nexports.tree_isEmpty = tree_isEmpty;\n/**\n * Returns the root node of a tree. The root of an object is itself,\n * if its parent is `null`, or else it is the root of its parent.\n * The root of a tree is any object participating in that tree\n * whose parent is `null`.\n *\n * @param node - a node of the tree\n * @param shadow - `true` to return shadow-including root, otherwise\n * `false`\n */\nfunction tree_rootNode(node, shadow) {\n    if (shadow === void 0) { shadow = false; }\n    /**\n        * The root of an object is itself, if its parent is null, or else it is the\n        * root of its parent. The root of a tree is any object participating in\n        * that tree whose parent is null.\n        */\n    if (shadow) {\n        var root = tree_rootNode(node, false);\n        if (util_1.Guard.isShadowRoot(root))\n            return tree_rootNode(root._host, true);\n        else\n            return root;\n    }\n    else {\n        if (!node._parent)\n            return node;\n        else\n            return tree_rootNode(node._parent);\n    }\n}\nexports.tree_rootNode = tree_rootNode;\n/**\n * Determines whether `other` is a descendant of `node`. An object\n * A is called a descendant of an object B, if either A is a child\n * of B or A is a child of an object C that is a descendant of B.\n *\n * @param node - a node\n * @param other - the node to check\n * @param self - if `true`, traversal includes `node` itself\n * @param shadow - if `true`, traversal includes the\n * node's and its descendant's shadow trees as well.\n */\nfunction tree_isDescendantOf(node, other, self, shadow) {\n    if (self === void 0) { self = false; }\n    if (shadow === void 0) { shadow = false; }\n    /**\n        * An object A is called a descendant of an object B, if either A is a\n        * child of B or A is a child of an object C that is a descendant of B.\n        *\n        * An inclusive descendant is an object or one of its descendants.\n    */\n    var child = tree_getFirstDescendantNode(node, self, shadow);\n    while (child !== null) {\n        if (child === other) {\n            return true;\n        }\n        child = tree_getNextDescendantNode(node, child, self, shadow);\n    }\n    return false;\n}\nexports.tree_isDescendantOf = tree_isDescendantOf;\n/**\n * Determines whether `other` is an ancestor of `node`. An object A\n * is called an ancestor of an object B if and only if B is a\n * descendant of A.\n *\n * @param node - a node\n * @param other - the node to check\n * @param self - if `true`, traversal includes `node` itself\n * @param shadow - if `true`, traversal includes the\n * node's and its descendant's shadow trees as well.\n */\nfunction tree_isAncestorOf(node, other, self, shadow) {\n    if (self === void 0) { self = false; }\n    if (shadow === void 0) { shadow = false; }\n    var ancestor = self ? node : shadow && util_1.Guard.isShadowRoot(node) ?\n        node._host : node._parent;\n    while (ancestor !== null) {\n        if (ancestor === other)\n            return true;\n        ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ?\n            ancestor._host : ancestor._parent;\n    }\n    return false;\n}\nexports.tree_isAncestorOf = tree_isAncestorOf;\n/**\n * Determines whether `other` is a host-including ancestor of `node`. An\n * object A is a host-including inclusive ancestor of an object B, if either\n * A is an inclusive ancestor of B, or if B’s root has a non-null host and\n * A is a host-including inclusive ancestor of B’s root’s host.\n *\n * @param node - a node\n * @param other - the node to check\n * @param self - if `true`, traversal includes `node` itself\n */\nfunction tree_isHostIncludingAncestorOf(node, other, self) {\n    if (self === void 0) { self = false; }\n    if (tree_isAncestorOf(node, other, self))\n        return true;\n    var root = tree_rootNode(node);\n    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null &&\n        tree_isHostIncludingAncestorOf(root._host, other, self))\n        return true;\n    return false;\n}\nexports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;\n/**\n * Determines whether `other` is a sibling of `node`. An object A is\n * called a sibling of an object B, if and only if B and A share\n * the same non-null parent.\n *\n * @param node - a node\n * @param other - the node to check\n * @param self - if `true`, traversal includes `node` itself\n */\nfunction tree_isSiblingOf(node, other, self) {\n    if (self === void 0) { self = false; }\n    /**\n        * An object A is called a sibling of an object B, if and only if B and A\n        * share the same non-null parent.\n        *\n        * An inclusive sibling is an object or one of its siblings.\n        */\n    if (node === other) {\n        if (self)\n            return true;\n    }\n    else {\n        return (node._parent !== null && node._parent === other._parent);\n    }\n    return false;\n}\nexports.tree_isSiblingOf = tree_isSiblingOf;\n/**\n * Determines whether `other` is preceding `node`. An object A is\n * preceding an object B if A and B are in the same tree and A comes\n * before B in tree order.\n *\n * @param node - a node\n * @param other - the node to check\n */\nfunction tree_isPreceding(node, other) {\n    /**\n        * An object A is preceding an object B if A and B are in the same tree and\n        * A comes before B in tree order.\n        */\n    var nodePos = tree_treePosition(node);\n    var otherPos = tree_treePosition(other);\n    if (nodePos === -1 || otherPos === -1)\n        return false;\n    else if (tree_rootNode(node) !== tree_rootNode(other))\n        return false;\n    else\n        return otherPos < nodePos;\n}\nexports.tree_isPreceding = tree_isPreceding;\n/**\n * Determines whether `other` is following `node`. An object A is\n * following an object B if A and B are in the same tree and A comes\n * after B in tree order.\n *\n * @param node - a node\n * @param other - the node to check\n */\nfunction tree_isFollowing(node, other) {\n    /**\n        * An object A is following an object B if A and B are in the same tree and\n        * A comes after B in tree order.\n        */\n    var nodePos = tree_treePosition(node);\n    var otherPos = tree_treePosition(other);\n    if (nodePos === -1 || otherPos === -1)\n        return false;\n    else if (tree_rootNode(node) !== tree_rootNode(other))\n        return false;\n    else\n        return otherPos > nodePos;\n}\nexports.tree_isFollowing = tree_isFollowing;\n/**\n * Determines whether `other` is the parent node of `node`.\n *\n * @param node - a node\n * @param other - the node to check\n */\nfunction tree_isParentOf(node, other) {\n    /**\n        * An object that participates in a tree has a parent, which is either\n        * null or an object, and has children, which is an ordered set of objects.\n        * An object A whose parent is object B is a child of B.\n        */\n    return (node._parent === other);\n}\nexports.tree_isParentOf = tree_isParentOf;\n/**\n * Determines whether `other` is a child node of `node`.\n *\n * @param node - a node\n * @param other - the node to check\n */\nfunction tree_isChildOf(node, other) {\n    /**\n        * An object that participates in a tree has a parent, which is either\n        * null or an object, and has children, which is an ordered set of objects.\n        * An object A whose parent is object B is a child of B.\n        */\n    return (other._parent === node);\n}\nexports.tree_isChildOf = tree_isChildOf;\n/**\n * Returns the previous sibling node of `node` or null if it has no\n * preceding sibling.\n *\n * @param node\n */\nfunction tree_previousSibling(node) {\n    /**\n        * The previous sibling of an object is its first preceding sibling or null\n        * if it has no preceding sibling.\n        */\n    return node._previousSibling;\n}\nexports.tree_previousSibling = tree_previousSibling;\n/**\n * Returns the next sibling node of `node` or null if it has no\n * following sibling.\n *\n * @param node\n */\nfunction tree_nextSibling(node) {\n    /**\n        * The next sibling of an object is its first following sibling or null\n        * if it has no following sibling.\n        */\n    return node._nextSibling;\n}\nexports.tree_nextSibling = tree_nextSibling;\n/**\n * Returns the first child node of `node` or null if it has no\n * children.\n *\n * @param node\n */\nfunction tree_firstChild(node) {\n    /**\n        * The first child of an object is its first child or null if it has no\n        * children.\n        */\n    return node._firstChild;\n}\nexports.tree_firstChild = tree_firstChild;\n/**\n * Returns the last child node of `node` or null if it has no\n * children.\n *\n * @param node\n */\nfunction tree_lastChild(node) {\n    /**\n        * The last child of an object is its last child or null if it has no\n        * children.\n        */\n    return node._lastChild;\n}\nexports.tree_lastChild = tree_lastChild;\n/**\n * Returns the zero-based index of `node` when counted preorder in\n * the tree rooted at `root`. Returns `-1` if `node` is not in\n * the tree.\n *\n * @param node - the node to get the index of\n */\nfunction tree_treePosition(node) {\n    var root = tree_rootNode(node);\n    var pos = 0;\n    var childNode = tree_getFirstDescendantNode(root);\n    while (childNode !== null) {\n        pos++;\n        if (childNode === node)\n            return pos;\n        childNode = tree_getNextDescendantNode(root, childNode);\n    }\n    return -1;\n}\nexports.tree_treePosition = tree_treePosition;\n/**\n * Determines the index of `node`. The index of an object is its number of\n * preceding siblings, or 0 if it has none.\n *\n * @param node - a node\n * @param other - the node to check\n */\nfunction tree_index(node) {\n    /**\n        * The index of an object is its number of preceding siblings, or 0 if it\n        * has none.\n        */\n    var n = 0;\n    while (node._previousSibling !== null) {\n        n++;\n        node = node._previousSibling;\n    }\n    return n;\n}\nexports.tree_index = tree_index;\n/**\n * Retargets an object against another object.\n *\n * @param a - an object to retarget\n * @param b - an object to retarget against\n */\nfunction tree_retarget(a, b) {\n    /**\n        * To retarget an object A against an object B, repeat these steps until\n        * they return an object:\n        * 1. If one of the following is true\n        * - A is not a node\n        * - A's root is not a shadow root\n        * - B is a node and A's root is a shadow-including inclusive ancestor\n        * of B\n        * then return A.\n        * 2. Set A to A's root's host.\n        */\n    while (true) {\n        if (!a || !util_1.Guard.isNode(a)) {\n            return a;\n        }\n        var rootOfA = tree_rootNode(a);\n        if (!util_1.Guard.isShadowRoot(rootOfA)) {\n            return a;\n        }\n        if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {\n            return a;\n        }\n        a = rootOfA.host;\n    }\n}\nexports.tree_retarget = tree_retarget;\n//# sourceMappingURL=TreeAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar TraversalAlgorithm_1 = require(\"./TraversalAlgorithm\");\n/**\n * Returns the first or last child node, or `null` if there are none.\n *\n * @param walker - the `TreeWalker` instance\n * @param first - `true` to return the first child node, or `false` to\n * return the last child node.\n */\nfunction treeWalker_traverseChildren(walker, first) {\n    /**\n     * 1. Let node be walker’s current.\n     * 2. Set node to node’s first child if type is first, and node’s last child\n     * if type is last.\n     * 3. While node is non-null:\n     */\n    var node = (first ? walker._current._firstChild : walker._current._lastChild);\n    while (node !== null) {\n        /**\n         * 3.1. Let result be the result of filtering node within walker.\n         */\n        var result = TraversalAlgorithm_1.traversal_filter(walker, node);\n        if (result === interfaces_1.FilterResult.Accept) {\n            /**\n             * 3.2. If result is FILTER_ACCEPT, then set walker’s current to node and\n             * return node.\n             */\n            walker._current = node;\n            return node;\n        }\n        else if (result === interfaces_1.FilterResult.Skip) {\n            /**\n             * 3.3. If result is FILTER_SKIP, then:\n             * 3.3.1. Let child be node’s first child if type is first, and node’s\n             * last child if type is last.\n             * 3.3.2. If child is non-null, then set node to child and continue.\n             */\n            var child = (first ? node._firstChild : node._lastChild);\n            if (child !== null) {\n                node = child;\n                continue;\n            }\n        }\n        /**\n         * 3.4. While node is non-null:\n         */\n        while (node !== null) {\n            /**\n             * 3.4.1. Let sibling be node’s next sibling if type is first, and\n             * node’s previous sibling if type is last.\n             * 3.4.2. If sibling is non-null, then set node to sibling and break.\n             */\n            var sibling = (first ? node._nextSibling : node._previousSibling);\n            if (sibling !== null) {\n                node = sibling;\n                break;\n            }\n            /**\n             * 3.4.3. Let parent be node’s parent.\n             * 3.4.4. If parent is null, walker’s root, or walker’s current, then\n             * return null.\n             */\n            var parent = node._parent;\n            if (parent === null || parent === walker._root || parent === walker._current) {\n                return null;\n            }\n            /**\n             * 3.4.5. Set node to parent.\n             */\n            node = parent;\n        }\n    }\n    /**\n     * 5. Return null\n     */\n    return null;\n}\nexports.treeWalker_traverseChildren = treeWalker_traverseChildren;\n/**\n * Returns the next or previous sibling node, or `null` if there are none.\n *\n * @param walker - the `TreeWalker` instance\n * @param next - `true` to return the next sibling node, or `false` to\n * return the previous sibling node.\n */\nfunction treeWalker_traverseSiblings(walker, next) {\n    /**\n     * 1. Let node be walker’s current.\n     * 2. If node is root, then return null.\n     * 3. While node is non-null:\n     */\n    var node = walker._current;\n    if (node === walker._root)\n        return null;\n    while (true) {\n        /**\n         * 3.1. Let sibling be node’s next sibling if type is next, and node’s\n         * previous sibling if type is previous.\n         * 3.2. While sibling is non-null:\n         */\n        var sibling = (next ? node._nextSibling : node._previousSibling);\n        while (sibling !== null) {\n            /**\n             * 3.2.1. Set node to sibling.\n             * 3.2.2. Let result be the result of filtering node within walker.\n             * 3.2.3. If result is FILTER_ACCEPT, then set walker’s current to node\n             * and return node.\n             */\n            node = sibling;\n            var result = TraversalAlgorithm_1.traversal_filter(walker, node);\n            if (result === interfaces_1.FilterResult.Accept) {\n                walker._current = node;\n                return node;\n            }\n            /**\n             * 3.2.4. Set sibling to node’s first child if type is next, and node’s\n             * last child if type is previous.\n             * 3.2.5. If result is FILTER_REJECT or sibling is null, then set\n             * sibling to node’s next sibling if type is next, and node’s previous\n             * sibling if type is previous.\n             */\n            sibling = (next ? node._firstChild : node._lastChild);\n            if (result === interfaces_1.FilterResult.Reject || sibling === null) {\n                sibling = (next ? node._nextSibling : node._previousSibling);\n            }\n        }\n        /**\n         * 3.3. Set node to node’s parent.\n         * 3.4. If node is null or walker’s root, then return null.\n         */\n        node = node._parent;\n        if (node === null || node === walker._root) {\n            return null;\n        }\n        /**\n         * 3.5. If the return value of filtering node within walker is FILTER_ACCEPT,\n         * then return null.\n         */\n        if (TraversalAlgorithm_1.traversal_filter(walker, node) === interfaces_1.FilterResult.Accept) {\n            return null;\n        }\n    }\n}\nexports.treeWalker_traverseSiblings = treeWalker_traverseSiblings;\n//# sourceMappingURL=TreeWalkerAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines a WebIDL `Const` property on the given object.\n *\n * @param o - object on which to add the property\n * @param name - property name\n * @param value - property value\n */\nfunction idl_defineConst(o, name, value) {\n    Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value: value });\n}\nexports.idl_defineConst = idl_defineConst;\n//# sourceMappingURL=WebIDLAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Determines if the given string is valid for a `\"Name\"` construct.\n *\n * @param name - name string to test\n */\nfunction xml_isName(name) {\n    for (var i = 0; i < name.length; i++) {\n        var n = name.charCodeAt(i);\n        // NameStartChar\n        if ((n >= 97 && n <= 122) || // [a-z]\n            (n >= 65 && n <= 90) || // [A-Z]\n            n === 58 || n === 95 || // ':' or '_'\n            (n >= 0xC0 && n <= 0xD6) ||\n            (n >= 0xD8 && n <= 0xF6) ||\n            (n >= 0xF8 && n <= 0x2FF) ||\n            (n >= 0x370 && n <= 0x37D) ||\n            (n >= 0x37F && n <= 0x1FFF) ||\n            (n >= 0x200C && n <= 0x200D) ||\n            (n >= 0x2070 && n <= 0x218F) ||\n            (n >= 0x2C00 && n <= 0x2FEF) ||\n            (n >= 0x3001 && n <= 0xD7FF) ||\n            (n >= 0xF900 && n <= 0xFDCF) ||\n            (n >= 0xFDF0 && n <= 0xFFFD)) {\n            continue;\n        }\n        else if (i !== 0 &&\n            (n === 45 || n === 46 || // '-' or '.'\n                (n >= 48 && n <= 57) || // [0-9]\n                (n === 0xB7) ||\n                (n >= 0x0300 && n <= 0x036F) ||\n                (n >= 0x203F && n <= 0x2040))) {\n            continue;\n        }\n        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {\n            var n2 = name.charCodeAt(i + 1);\n            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {\n                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;\n                i++;\n                if (n >= 0x10000 && n <= 0xEFFFF) {\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    return true;\n}\nexports.xml_isName = xml_isName;\n/**\n * Determines if the given string is valid for a `\"QName\"` construct.\n *\n * @param name - name string to test\n */\nfunction xml_isQName(name) {\n    var colonFound = false;\n    for (var i = 0; i < name.length; i++) {\n        var n = name.charCodeAt(i);\n        // NameStartChar\n        if ((n >= 97 && n <= 122) || // [a-z]\n            (n >= 65 && n <= 90) || // [A-Z]\n            n === 95 || // '_'\n            (n >= 0xC0 && n <= 0xD6) ||\n            (n >= 0xD8 && n <= 0xF6) ||\n            (n >= 0xF8 && n <= 0x2FF) ||\n            (n >= 0x370 && n <= 0x37D) ||\n            (n >= 0x37F && n <= 0x1FFF) ||\n            (n >= 0x200C && n <= 0x200D) ||\n            (n >= 0x2070 && n <= 0x218F) ||\n            (n >= 0x2C00 && n <= 0x2FEF) ||\n            (n >= 0x3001 && n <= 0xD7FF) ||\n            (n >= 0xF900 && n <= 0xFDCF) ||\n            (n >= 0xFDF0 && n <= 0xFFFD)) {\n            continue;\n        }\n        else if (i !== 0 &&\n            (n === 45 || n === 46 || // '-' or '.'\n                (n >= 48 && n <= 57) || // [0-9]\n                (n === 0xB7) ||\n                (n >= 0x0300 && n <= 0x036F) ||\n                (n >= 0x203F && n <= 0x2040))) {\n            continue;\n        }\n        else if (i !== 0 && n === 58) { // :\n            if (colonFound)\n                return false; // multiple colons in qname\n            if (i === name.length - 1)\n                return false; // colon at the end of qname\n            colonFound = true;\n            continue;\n        }\n        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {\n            var n2 = name.charCodeAt(i + 1);\n            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {\n                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;\n                i++;\n                if (n >= 0x10000 && n <= 0xEFFFF) {\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    return true;\n}\nexports.xml_isQName = xml_isQName;\n/**\n * Determines if the given string contains legal characters.\n *\n * @param chars - sequence of characters to test\n */\nfunction xml_isLegalChar(chars) {\n    for (var i = 0; i < chars.length; i++) {\n        var n = chars.charCodeAt(i);\n        // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n        if (n === 0x9 || n === 0xA || n === 0xD ||\n            (n >= 0x20 && n <= 0xD7FF) ||\n            (n >= 0xE000 && n <= 0xFFFD)) {\n            continue;\n        }\n        if (n >= 0xD800 && n <= 0xDBFF && i < chars.length - 1) {\n            var n2 = chars.charCodeAt(i + 1);\n            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {\n                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;\n                i++;\n                if (n >= 0x10000 && n <= 0x10FFFF) {\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    return true;\n}\nexports.xml_isLegalChar = xml_isLegalChar;\n/**\n * Determines if the given string contains legal characters for a public\n * identifier.\n *\n * @param chars - sequence of characters to test\n */\nfunction xml_isPubidChar(chars) {\n    for (var i = 0; i < chars.length; i++) {\n        // PubId chars are all in the ASCII range, no need to check surrogates\n        var n = chars.charCodeAt(i);\n        // #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\n        if ((n >= 97 && n <= 122) || // [a-z]\n            (n >= 65 && n <= 90) || // [A-Z]\n            (n >= 39 && n <= 59) || // ['()*+,-./] | [0-9] | [:;]\n            n === 0x20 || n === 0xD || n === 0xA || // #x20 | #xD | #xA\n            (n >= 35 && n <= 37) || // [#$%]\n            n === 33 || // !\n            n === 61 || n === 63 || n === 64 || n === 95) { // [=?@_]\n            continue;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexports.xml_isPubidChar = xml_isPubidChar;\n//# sourceMappingURL=XMLAlgorithm.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./AbortAlgorithm\"));\n__export(require(\"./AttrAlgorithm\"));\n__export(require(\"./BoundaryPointAlgorithm\"));\n__export(require(\"./CharacterDataAlgorithm\"));\n__export(require(\"./CreateAlgorithm\"));\n__export(require(\"./CustomElementAlgorithm\"));\n__export(require(\"./DocumentAlgorithm\"));\n__export(require(\"./DOMAlgorithm\"));\n__export(require(\"./DOMTokenListAlgorithm\"));\n__export(require(\"./ElementAlgorithm\"));\n__export(require(\"./EventAlgorithm\"));\n__export(require(\"./EventTargetAlgorithm\"));\n__export(require(\"./MutationAlgorithm\"));\n__export(require(\"./MutationObserverAlgorithm\"));\n__export(require(\"./NamespaceAlgorithm\"));\n__export(require(\"./NodeAlgorithm\"));\n__export(require(\"./NodeIteratorAlgorithm\"));\n__export(require(\"./OrderedSetAlgorithm\"));\n__export(require(\"./ParentNodeAlgorithm\"));\n__export(require(\"./RangeAlgorithm\"));\n__export(require(\"./SelectorsAlgorithm\"));\n__export(require(\"./ShadowTreeAlgorithm\"));\n__export(require(\"./TextAlgorithm\"));\n__export(require(\"./TraversalAlgorithm\"));\n__export(require(\"./TreeAlgorithm\"));\n__export(require(\"./TreeWalkerAlgorithm\"));\n__export(require(\"./WebIDLAlgorithm\"));\n__export(require(\"./XMLAlgorithm\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a controller that allows to abort DOM requests.\n */\nvar AbortControllerImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `AbortController`.\n     */\n    function AbortControllerImpl() {\n        /**\n         * 1. Let signal be a new AbortSignal object.\n         * 2. Let controller be a new AbortController object whose signal is signal.\n         * 3. Return controller.\n         */\n        this._signal = algorithm_1.create_abortSignal();\n    }\n    Object.defineProperty(AbortControllerImpl.prototype, \"signal\", {\n        /** @inheritdoc */\n        get: function () { return this._signal; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    AbortControllerImpl.prototype.abort = function () {\n        algorithm_1.abort_signalAbort(this._signal);\n    };\n    return AbortControllerImpl;\n}());\nexports.AbortControllerImpl = AbortControllerImpl;\n//# sourceMappingURL=AbortControllerImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventTargetImpl_1 = require(\"./EventTargetImpl\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a signal object that communicates with a DOM request and abort\n * it through an AbortController.\n */\nvar AbortSignalImpl = /** @class */ (function (_super) {\n    __extends(AbortSignalImpl, _super);\n    /**\n     * Initializes a new instance of `AbortSignal`.\n     */\n    function AbortSignalImpl() {\n        var _this = _super.call(this) || this;\n        _this._abortedFlag = false;\n        _this._abortAlgorithms = new Set();\n        return _this;\n    }\n    Object.defineProperty(AbortSignalImpl.prototype, \"aborted\", {\n        /** @inheritdoc */\n        get: function () { return this._abortedFlag; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbortSignalImpl.prototype, \"onabort\", {\n        /** @inheritdoc */\n        get: function () {\n            return algorithm_1.event_getterEventHandlerIDLAttribute(this, \"onabort\");\n        },\n        set: function (val) {\n            algorithm_1.event_setterEventHandlerIDLAttribute(this, \"onabort\", val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new `AbortSignal`.\n     */\n    AbortSignalImpl._create = function () {\n        return new AbortSignalImpl();\n    };\n    return AbortSignalImpl;\n}(EventTargetImpl_1.EventTargetImpl));\nexports.AbortSignalImpl = AbortSignalImpl;\n//# sourceMappingURL=AbortSignalImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents an abstract range with a start and end boundary point.\n */\nvar AbstractRangeImpl = /** @class */ (function () {\n    function AbstractRangeImpl() {\n    }\n    Object.defineProperty(AbstractRangeImpl.prototype, \"_startNode\", {\n        get: function () { return this._start[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"_startOffset\", {\n        get: function () { return this._start[1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"_endNode\", {\n        get: function () { return this._end[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"_endOffset\", {\n        get: function () { return this._end[1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"_collapsed\", {\n        get: function () {\n            return (this._start[0] === this._end[0] &&\n                this._start[1] === this._end[1]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"startContainer\", {\n        /** @inheritdoc */\n        get: function () { return this._startNode; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"startOffset\", {\n        /** @inheritdoc */\n        get: function () { return this._startOffset; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"endContainer\", {\n        /** @inheritdoc */\n        get: function () { return this._endNode; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"endOffset\", {\n        /** @inheritdoc */\n        get: function () { return this._endOffset; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractRangeImpl.prototype, \"collapsed\", {\n        /** @inheritdoc */\n        get: function () { return this._collapsed; },\n        enumerable: true,\n        configurable: true\n    });\n    return AbstractRangeImpl;\n}());\nexports.AbstractRangeImpl = AbstractRangeImpl;\n//# sourceMappingURL=AbstractRangeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar NodeImpl_1 = require(\"./NodeImpl\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents an attribute of an element node.\n */\nvar AttrImpl = /** @class */ (function (_super) {\n    __extends(AttrImpl, _super);\n    /**\n     * Initializes a new instance of `Attr`.\n     *\n     * @param localName - local name\n     */\n    function AttrImpl(localName) {\n        var _this = _super.call(this) || this;\n        _this._namespace = null;\n        _this._namespacePrefix = null;\n        _this._element = null;\n        _this._value = '';\n        _this._localName = localName;\n        return _this;\n    }\n    Object.defineProperty(AttrImpl.prototype, \"ownerElement\", {\n        /** @inheritdoc */\n        get: function () { return this._element; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttrImpl.prototype, \"namespaceURI\", {\n        /** @inheritdoc */\n        get: function () { return this._namespace; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttrImpl.prototype, \"prefix\", {\n        /** @inheritdoc */\n        get: function () { return this._namespacePrefix; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttrImpl.prototype, \"localName\", {\n        /** @inheritdoc */\n        get: function () { return this._localName; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttrImpl.prototype, \"name\", {\n        /** @inheritdoc */\n        get: function () { return this._qualifiedName; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttrImpl.prototype, \"value\", {\n        /** @inheritdoc */\n        get: function () { return this._value; },\n        set: function (value) {\n            /**\n             * The value attribute’s setter must set an existing attribute value with\n             * context object and the given value.\n             */\n            algorithm_1.attr_setAnExistingAttributeValue(this, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AttrImpl.prototype, \"_qualifiedName\", {\n        /**\n         * Returns the qualified name.\n         */\n        get: function () {\n            /**\n             * An attribute’s qualified name is its local name if its namespace prefix\n             * is null, and its namespace prefix, followed by \":\", followed by its\n             * local name, otherwise.\n             */\n            return (this._namespacePrefix !== null ?\n                this._namespacePrefix + ':' + this._localName :\n                this._localName);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates an `Attr`.\n     *\n     * @param document - owner document\n     * @param localName - local name\n     */\n    AttrImpl._create = function (document, localName) {\n        var node = new AttrImpl(localName);\n        node._nodeDocument = document;\n        return node;\n    };\n    return AttrImpl;\n}(NodeImpl_1.NodeImpl));\nexports.AttrImpl = AttrImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, \"_nodeType\", interfaces_1.NodeType.Attribute);\nWebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, \"specified\", true);\n//# sourceMappingURL=AttrImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TextImpl_1 = require(\"./TextImpl\");\nvar interfaces_1 = require(\"./interfaces\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a CDATA node.\n */\nvar CDATASectionImpl = /** @class */ (function (_super) {\n    __extends(CDATASectionImpl, _super);\n    /**\n     * Initializes a new instance of `CDATASection`.\n     *\n     * @param data - node contents\n     */\n    function CDATASectionImpl(data) {\n        return _super.call(this, data) || this;\n    }\n    /**\n     * Creates a new `CDATASection`.\n     *\n     * @param document - owner document\n     * @param data - node contents\n     */\n    CDATASectionImpl._create = function (document, data) {\n        if (data === void 0) { data = ''; }\n        var node = new CDATASectionImpl(data);\n        node._nodeDocument = document;\n        return node;\n    };\n    return CDATASectionImpl;\n}(TextImpl_1.TextImpl));\nexports.CDATASectionImpl = CDATASectionImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(CDATASectionImpl.prototype, \"_nodeType\", interfaces_1.NodeType.CData);\n//# sourceMappingURL=CDATASectionImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NodeImpl_1 = require(\"./NodeImpl\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a generic text node.\n */\nvar CharacterDataImpl = /** @class */ (function (_super) {\n    __extends(CharacterDataImpl, _super);\n    /**\n     * Initializes a new instance of `CharacterData`.\n     *\n     * @param data - the text content\n     */\n    function CharacterDataImpl(data) {\n        var _this = _super.call(this) || this;\n        _this._data = data;\n        return _this;\n    }\n    Object.defineProperty(CharacterDataImpl.prototype, \"data\", {\n        /** @inheritdoc */\n        get: function () { return this._data; },\n        set: function (value) {\n            algorithm_1.characterData_replaceData(this, 0, this._data.length, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterDataImpl.prototype, \"length\", {\n        /** @inheritdoc */\n        get: function () { return this._data.length; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    CharacterDataImpl.prototype.substringData = function (offset, count) {\n        /**\n         * The substringData(offset, count) method, when invoked, must return the\n         * result of running substring data with node context object, offset offset, and count count.\n         */\n        return algorithm_1.characterData_substringData(this, offset, count);\n    };\n    /** @inheritdoc */\n    CharacterDataImpl.prototype.appendData = function (data) {\n        /**\n         * The appendData(data) method, when invoked, must replace data with node\n         * context object, offset context object’s length, count 0, and data data.\n         */\n        return algorithm_1.characterData_replaceData(this, this._data.length, 0, data);\n    };\n    /** @inheritdoc */\n    CharacterDataImpl.prototype.insertData = function (offset, data) {\n        /**\n         * The insertData(offset, data) method, when invoked, must replace data with\n         * node context object, offset offset, count 0, and data data.\n         */\n        algorithm_1.characterData_replaceData(this, offset, 0, data);\n    };\n    /** @inheritdoc */\n    CharacterDataImpl.prototype.deleteData = function (offset, count) {\n        /**\n         * The deleteData(offset, count) method, when invoked, must replace data\n         * with node context object, offset offset, count count, and data the\n         * empty string.\n         */\n        algorithm_1.characterData_replaceData(this, offset, count, '');\n    };\n    /** @inheritdoc */\n    CharacterDataImpl.prototype.replaceData = function (offset, count, data) {\n        /**\n         * The replaceData(offset, count, data) method, when invoked, must replace\n         * data with node context object, offset offset, count count, and data data.\n         */\n        algorithm_1.characterData_replaceData(this, offset, count, data);\n    };\n    Object.defineProperty(CharacterDataImpl.prototype, \"previousElementSibling\", {\n        // MIXIN: NonDocumentTypeChildNode\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: NonDocumentTypeChildNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterDataImpl.prototype, \"nextElementSibling\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: NonDocumentTypeChildNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    // MIXIN: ChildNode\n    /* istanbul ignore next */\n    CharacterDataImpl.prototype.before = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    CharacterDataImpl.prototype.after = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    CharacterDataImpl.prototype.replaceWith = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    CharacterDataImpl.prototype.remove = function () { throw new Error(\"Mixin: ChildNode not implemented.\"); };\n    return CharacterDataImpl;\n}(NodeImpl_1.NodeImpl));\nexports.CharacterDataImpl = CharacterDataImpl;\n//# sourceMappingURL=CharacterDataImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a mixin that extends child nodes that can have siblings\n * including doctypes. This mixin is implemented by {@link Element},\n * {@link CharacterData} and {@link DocumentType}.\n */\nvar ChildNodeImpl = /** @class */ (function () {\n    function ChildNodeImpl() {\n    }\n    /** @inheritdoc */\n    ChildNodeImpl.prototype.before = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        /**\n         * 1. Let parent be context object’s parent.\n         * 2. If parent is null, then return.\n         */\n        var context = util_1.Cast.asNode(this);\n        var parent = context._parent;\n        if (parent === null)\n            return;\n        /**\n         * 3. Let viablePreviousSibling be context object’s first preceding\n         * sibling not in nodes, and null otherwise.\n         */\n        var viablePreviousSibling = context._previousSibling;\n        var flag = true;\n        while (flag && viablePreviousSibling) {\n            flag = false;\n            for (var i = 0; i < nodes.length; i++) {\n                var child = nodes[i];\n                if (child === viablePreviousSibling) {\n                    viablePreviousSibling = viablePreviousSibling._previousSibling;\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        /**\n         * 4. Let node be the result of converting nodes into a node, given nodes\n         * and context object’s node document.\n         */\n        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);\n        /**\n         * 5. If viablePreviousSibling is null, set it to parent’s first child,\n         * and to viablePreviousSibling’s next sibling otherwise.\n         */\n        if (viablePreviousSibling === null)\n            viablePreviousSibling = parent._firstChild;\n        else\n            viablePreviousSibling = viablePreviousSibling._nextSibling;\n        /**\n         * 6. Pre-insert node into parent before viablePreviousSibling.\n         */\n        algorithm_1.mutation_preInsert(node, parent, viablePreviousSibling);\n    };\n    /** @inheritdoc */\n    ChildNodeImpl.prototype.after = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        /**\n         * 1. Let parent be context object’s parent.\n         * 2. If parent is null, then return.\n         */\n        var context = util_1.Cast.asNode(this);\n        var parent = context._parent;\n        if (!parent)\n            return;\n        /**\n         * 3. Let viableNextSibling be context object’s first following sibling not\n         * in nodes, and null otherwise.\n         */\n        var viableNextSibling = context._nextSibling;\n        var flag = true;\n        while (flag && viableNextSibling) {\n            flag = false;\n            for (var i = 0; i < nodes.length; i++) {\n                var child = nodes[i];\n                if (child === viableNextSibling) {\n                    viableNextSibling = viableNextSibling._nextSibling;\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        /**\n         * 4. Let node be the result of converting nodes into a node, given nodes\n         * and context object’s node document.\n         */\n        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);\n        /**\n         * 5. Pre-insert node into parent before viableNextSibling.\n         */\n        algorithm_1.mutation_preInsert(node, parent, viableNextSibling);\n    };\n    /** @inheritdoc */\n    ChildNodeImpl.prototype.replaceWith = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        /**\n         * 1. Let parent be context object’s parent.\n         * 2. If parent is null, then return.\n         */\n        var context = util_1.Cast.asNode(this);\n        var parent = context._parent;\n        if (!parent)\n            return;\n        /**\n         * 3. Let viableNextSibling be context object’s first following sibling not\n         * in nodes, and null otherwise.\n         */\n        var viableNextSibling = context._nextSibling;\n        var flag = true;\n        while (flag && viableNextSibling) {\n            flag = false;\n            for (var i = 0; i < nodes.length; i++) {\n                var child = nodes[i];\n                if (child === viableNextSibling) {\n                    viableNextSibling = viableNextSibling._nextSibling;\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        /**\n         * 4. Let node be the result of converting nodes into a node, given nodes\n         * and context object’s node document.\n         */\n        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);\n        /**\n         * 5. If context object’s parent is parent, replace the context object with\n         * node within parent.\n         * _Note:_ Context object could have been inserted into node.\n         * 6. Otherwise, pre-insert node into parent before viableNextSibling.\n         */\n        if (context._parent === parent)\n            algorithm_1.mutation_replace(context, node, parent);\n        else\n            algorithm_1.mutation_preInsert(node, parent, viableNextSibling);\n    };\n    /** @inheritdoc */\n    ChildNodeImpl.prototype.remove = function () {\n        /**\n         * 1. If context object’s parent is null, then return.\n         * 2. Remove the context object from context object’s parent.\n         */\n        var context = util_1.Cast.asNode(this);\n        var parent = context._parent;\n        if (!parent)\n            return;\n        algorithm_1.mutation_remove(context, parent);\n    };\n    return ChildNodeImpl;\n}());\nexports.ChildNodeImpl = ChildNodeImpl;\n//# sourceMappingURL=ChildNodeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar CharacterDataImpl_1 = require(\"./CharacterDataImpl\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a comment node.\n */\nvar CommentImpl = /** @class */ (function (_super) {\n    __extends(CommentImpl, _super);\n    /**\n     * Initializes a new instance of `Comment`.\n     *\n     * @param data - the text content\n     */\n    function CommentImpl(data) {\n        if (data === void 0) { data = ''; }\n        return _super.call(this, data) || this;\n    }\n    /**\n     * Creates a new `Comment`.\n     *\n     * @param document - owner document\n     * @param data - node contents\n     */\n    CommentImpl._create = function (document, data) {\n        if (data === void 0) { data = ''; }\n        var node = new CommentImpl(data);\n        node._nodeDocument = document;\n        return node;\n    };\n    return CommentImpl;\n}(CharacterDataImpl_1.CharacterDataImpl));\nexports.CommentImpl = CommentImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(CommentImpl.prototype, \"_nodeType\", interfaces_1.NodeType.Comment);\n//# sourceMappingURL=CommentImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventImpl_1 = require(\"./EventImpl\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents and event that carries custom data.\n */\nvar CustomEventImpl = /** @class */ (function (_super) {\n    __extends(CustomEventImpl, _super);\n    /**\n     * Initializes a new instance of `CustomEvent`.\n     */\n    function CustomEventImpl(type, eventInit) {\n        var _this = _super.call(this, type, eventInit) || this;\n        _this._detail = null;\n        _this._detail = (eventInit && eventInit.detail) || null;\n        return _this;\n    }\n    Object.defineProperty(CustomEventImpl.prototype, \"detail\", {\n        /** @inheritdoc */\n        get: function () { return this._detail; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    CustomEventImpl.prototype.initCustomEvent = function (type, bubbles, cancelable, detail) {\n        if (bubbles === void 0) { bubbles = false; }\n        if (cancelable === void 0) { cancelable = false; }\n        if (detail === void 0) { detail = null; }\n        /**\n         * 1. If the context object’s dispatch flag is set, then return.\n         */\n        if (this._dispatchFlag)\n            return;\n        /**\n         * 2. Initialize the context object with type, bubbles, and cancelable.\n         */\n        algorithm_1.event_initialize(this, type, bubbles, cancelable);\n        /**\n         * 3. Set the context object’s detail attribute to detail.\n         */\n        this._detail = detail;\n    };\n    return CustomEventImpl;\n}(EventImpl_1.EventImpl));\nexports.CustomEventImpl = CustomEventImpl;\n//# sourceMappingURL=CustomEventImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents the base class of `Error` objects used by this module.\n */\nvar DOMException = /** @class */ (function (_super) {\n    __extends(DOMException, _super);\n    /**\n     *\n     * @param name - message name\n     * @param message - error message\n     */\n    function DOMException(name, message) {\n        if (message === void 0) { message = \"\"; }\n        var _this = _super.call(this, message) || this;\n        _this.name = name;\n        return _this;\n    }\n    return DOMException;\n}(Error));\nexports.DOMException = DOMException;\nvar DOMStringSizeError = /** @class */ (function (_super) {\n    __extends(DOMStringSizeError, _super);\n    /**\n    * @param message - error message\n    */\n    function DOMStringSizeError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"DOMStringSizeError\", message) || this;\n    }\n    return DOMStringSizeError;\n}(DOMException));\nexports.DOMStringSizeError = DOMStringSizeError;\nvar WrongDocumentError = /** @class */ (function (_super) {\n    __extends(WrongDocumentError, _super);\n    /**\n    * @param message - error message\n    */\n    function WrongDocumentError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"WrongDocumentError\", \"The object is in the wrong document. \" + message) || this;\n    }\n    return WrongDocumentError;\n}(DOMException));\nexports.WrongDocumentError = WrongDocumentError;\nvar NoDataAllowedError = /** @class */ (function (_super) {\n    __extends(NoDataAllowedError, _super);\n    /**\n    * @param message - error message\n    */\n    function NoDataAllowedError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NoDataAllowedError\", message) || this;\n    }\n    return NoDataAllowedError;\n}(DOMException));\nexports.NoDataAllowedError = NoDataAllowedError;\nvar NoModificationAllowedError = /** @class */ (function (_super) {\n    __extends(NoModificationAllowedError, _super);\n    /**\n    * @param message - error message\n    */\n    function NoModificationAllowedError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NoModificationAllowedError\", \"The object can not be modified. \" + message) || this;\n    }\n    return NoModificationAllowedError;\n}(DOMException));\nexports.NoModificationAllowedError = NoModificationAllowedError;\nvar NotSupportedError = /** @class */ (function (_super) {\n    __extends(NotSupportedError, _super);\n    /**\n    * @param message - error message\n    */\n    function NotSupportedError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NotSupportedError\", \"The operation is not supported. \" + message) || this;\n    }\n    return NotSupportedError;\n}(DOMException));\nexports.NotSupportedError = NotSupportedError;\nvar InUseAttributeError = /** @class */ (function (_super) {\n    __extends(InUseAttributeError, _super);\n    /**\n    * @param message - error message\n    */\n    function InUseAttributeError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"InUseAttributeError\", message) || this;\n    }\n    return InUseAttributeError;\n}(DOMException));\nexports.InUseAttributeError = InUseAttributeError;\nvar InvalidStateError = /** @class */ (function (_super) {\n    __extends(InvalidStateError, _super);\n    /**\n    * @param message - error message\n    */\n    function InvalidStateError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"InvalidStateError\", \"The object is in an invalid state. \" + message) || this;\n    }\n    return InvalidStateError;\n}(DOMException));\nexports.InvalidStateError = InvalidStateError;\nvar InvalidModificationError = /** @class */ (function (_super) {\n    __extends(InvalidModificationError, _super);\n    /**\n    * @param message - error message\n    */\n    function InvalidModificationError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"InvalidModificationError\", \"The object can not be modified in this way. \" + message) || this;\n    }\n    return InvalidModificationError;\n}(DOMException));\nexports.InvalidModificationError = InvalidModificationError;\nvar NamespaceError = /** @class */ (function (_super) {\n    __extends(NamespaceError, _super);\n    /**\n    * @param message - error message\n    */\n    function NamespaceError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NamespaceError\", \"The operation is not allowed by Namespaces in XML. [XMLNS] \" + message) || this;\n    }\n    return NamespaceError;\n}(DOMException));\nexports.NamespaceError = NamespaceError;\nvar InvalidAccessError = /** @class */ (function (_super) {\n    __extends(InvalidAccessError, _super);\n    /**\n    * @param message - error message\n    */\n    function InvalidAccessError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"InvalidAccessError\", \"The object does not support the operation or argument. \" + message) || this;\n    }\n    return InvalidAccessError;\n}(DOMException));\nexports.InvalidAccessError = InvalidAccessError;\nvar ValidationError = /** @class */ (function (_super) {\n    __extends(ValidationError, _super);\n    /**\n    * @param message - error message\n    */\n    function ValidationError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"ValidationError\", message) || this;\n    }\n    return ValidationError;\n}(DOMException));\nexports.ValidationError = ValidationError;\nvar TypeMismatchError = /** @class */ (function (_super) {\n    __extends(TypeMismatchError, _super);\n    /**\n    * @param message - error message\n    */\n    function TypeMismatchError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"TypeMismatchError\", message) || this;\n    }\n    return TypeMismatchError;\n}(DOMException));\nexports.TypeMismatchError = TypeMismatchError;\nvar SecurityError = /** @class */ (function (_super) {\n    __extends(SecurityError, _super);\n    /**\n    * @param message - error message\n    */\n    function SecurityError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"SecurityError\", \"The operation is insecure. \" + message) || this;\n    }\n    return SecurityError;\n}(DOMException));\nexports.SecurityError = SecurityError;\nvar NetworkError = /** @class */ (function (_super) {\n    __extends(NetworkError, _super);\n    /**\n    * @param message - error message\n    */\n    function NetworkError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NetworkError\", \"A network error occurred. \" + message) || this;\n    }\n    return NetworkError;\n}(DOMException));\nexports.NetworkError = NetworkError;\nvar AbortError = /** @class */ (function (_super) {\n    __extends(AbortError, _super);\n    /**\n    * @param message - error message\n    */\n    function AbortError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"AbortError\", \"The operation was aborted. \" + message) || this;\n    }\n    return AbortError;\n}(DOMException));\nexports.AbortError = AbortError;\nvar URLMismatchError = /** @class */ (function (_super) {\n    __extends(URLMismatchError, _super);\n    /**\n    * @param message - error message\n    */\n    function URLMismatchError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"URLMismatchError\", \"The given URL does not match another URL. \" + message) || this;\n    }\n    return URLMismatchError;\n}(DOMException));\nexports.URLMismatchError = URLMismatchError;\nvar QuotaExceededError = /** @class */ (function (_super) {\n    __extends(QuotaExceededError, _super);\n    /**\n    * @param message - error message\n    */\n    function QuotaExceededError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"QuotaExceededError\", \"The quota has been exceeded. \" + message) || this;\n    }\n    return QuotaExceededError;\n}(DOMException));\nexports.QuotaExceededError = QuotaExceededError;\nvar TimeoutError = /** @class */ (function (_super) {\n    __extends(TimeoutError, _super);\n    /**\n    * @param message - error message\n    */\n    function TimeoutError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"TimeoutError\", \"The operation timed out. \" + message) || this;\n    }\n    return TimeoutError;\n}(DOMException));\nexports.TimeoutError = TimeoutError;\nvar InvalidNodeTypeError = /** @class */ (function (_super) {\n    __extends(InvalidNodeTypeError, _super);\n    /**\n    * @param message - error message\n    */\n    function InvalidNodeTypeError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"InvalidNodeTypeError\", \"The supplied node is incorrect or has an incorrect ancestor for this operation. \" + message) || this;\n    }\n    return InvalidNodeTypeError;\n}(DOMException));\nexports.InvalidNodeTypeError = InvalidNodeTypeError;\nvar DataCloneError = /** @class */ (function (_super) {\n    __extends(DataCloneError, _super);\n    /**\n    * @param message - error message\n    */\n    function DataCloneError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"DataCloneError\", \"The object can not be cloned. \" + message) || this;\n    }\n    return DataCloneError;\n}(DOMException));\nexports.DataCloneError = DataCloneError;\nvar NotImplementedError = /** @class */ (function (_super) {\n    __extends(NotImplementedError, _super);\n    /**\n    * @param message - error message\n    */\n    function NotImplementedError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NotImplementedError\", \"The DOM method is not implemented by this module. \" + message) || this;\n    }\n    return NotImplementedError;\n}(DOMException));\nexports.NotImplementedError = NotImplementedError;\nvar HierarchyRequestError = /** @class */ (function (_super) {\n    __extends(HierarchyRequestError, _super);\n    /**\n     * @param message - error message\n     */\n    function HierarchyRequestError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"HierarchyRequestError\", \"The operation would yield an incorrect node tree. \" + message) || this;\n    }\n    return HierarchyRequestError;\n}(DOMException));\nexports.HierarchyRequestError = HierarchyRequestError;\nvar NotFoundError = /** @class */ (function (_super) {\n    __extends(NotFoundError, _super);\n    /**\n     * @param message - error message\n     */\n    function NotFoundError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"NotFoundError\", \"The object can not be found here. \" + message) || this;\n    }\n    return NotFoundError;\n}(DOMException));\nexports.NotFoundError = NotFoundError;\nvar IndexSizeError = /** @class */ (function (_super) {\n    __extends(IndexSizeError, _super);\n    /**\n     * @param message - error message\n     */\n    function IndexSizeError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"IndexSizeError\", \"The index is not in the allowed range. \" + message) || this;\n    }\n    return IndexSizeError;\n}(DOMException));\nexports.IndexSizeError = IndexSizeError;\nvar SyntaxError = /** @class */ (function (_super) {\n    __extends(SyntaxError, _super);\n    /**\n     * @param message - error message\n     */\n    function SyntaxError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"SyntaxError\", \"The string did not match the expected pattern. \" + message) || this;\n    }\n    return SyntaxError;\n}(DOMException));\nexports.SyntaxError = SyntaxError;\nvar InvalidCharacterError = /** @class */ (function (_super) {\n    __extends(InvalidCharacterError, _super);\n    /**\n     * @param message - error message\n     */\n    function InvalidCharacterError(message) {\n        if (message === void 0) { message = \"\"; }\n        return _super.call(this, \"InvalidCharacterError\", \"The string contains invalid characters. \" + message) || this;\n    }\n    return InvalidCharacterError;\n}(DOMException));\nexports.InvalidCharacterError = InvalidCharacterError;\n//# sourceMappingURL=DOMException.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar CreateAlgorithm_1 = require(\"../algorithm/CreateAlgorithm\");\n/**\n * Represents an object implementing DOM algorithms.\n */\nvar DOMImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `DOM`.\n     */\n    function DOMImpl() {\n        this._features = {\n            mutationObservers: true,\n            customElements: true,\n            slots: true,\n            steps: true\n        };\n        this._window = null;\n        this._compareCache = new util_1.CompareCache();\n        this._rangeList = new util_1.FixedSizeSet();\n    }\n    /**\n     * Sets DOM algorithm features.\n     *\n     * @param features - DOM features supported by algorithms. All features are\n     * enabled by default unless explicity disabled.\n     */\n    DOMImpl.prototype.setFeatures = function (features) {\n        if (features === undefined)\n            features = true;\n        if (util_1.isObject(features)) {\n            for (var key in features) {\n                this._features[key] = features[key] || false;\n            }\n        }\n        else {\n            // enable/disable all features\n            for (var key in this._features) {\n                this._features[key] = features;\n            }\n        }\n    };\n    Object.defineProperty(DOMImpl.prototype, \"features\", {\n        /**\n         * Gets DOM algorithm features.\n         */\n        get: function () { return this._features; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DOMImpl.prototype, \"window\", {\n        /**\n         * Gets the DOM window.\n         */\n        get: function () {\n            if (this._window === null) {\n                this._window = CreateAlgorithm_1.create_window();\n            }\n            return this._window;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DOMImpl.prototype, \"compareCache\", {\n        /**\n         * Gets the global node compare cache.\n         */\n        get: function () { return this._compareCache; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DOMImpl.prototype, \"rangeList\", {\n        /**\n         * Gets the global range list.\n         */\n        get: function () { return this._rangeList; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DOMImpl, \"instance\", {\n        /**\n         * Returns the instance of `DOM`.\n         */\n        get: function () {\n            if (!DOMImpl._instance) {\n                DOMImpl._instance = new DOMImpl();\n            }\n            return DOMImpl._instance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return DOMImpl;\n}());\n/**\n * Represents an object implementing DOM algorithms.\n */\nexports.dom = DOMImpl.instance;\n//# sourceMappingURL=DOMImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents an object providing methods which are not dependent on\n * any particular document.\n */\nvar DOMImplementationImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `DOMImplementation`.\n     *\n     * @param document - the associated document\n     */\n    function DOMImplementationImpl(document) {\n        this._associatedDocument = document || DOMImpl_1.dom.window.document;\n    }\n    /** @inheritdoc */\n    DOMImplementationImpl.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {\n        /**\n         * 1. Validate qualifiedName.\n         * 2. Return a new doctype, with qualifiedName as its name, publicId as its\n         * public ID, and systemId as its system ID, and with its node document set\n         * to the associated document of the context object.\n         */\n        algorithm_1.namespace_validate(qualifiedName);\n        return algorithm_1.create_documentType(this._associatedDocument, qualifiedName, publicId, systemId);\n    };\n    /** @inheritdoc */\n    DOMImplementationImpl.prototype.createDocument = function (namespace, qualifiedName, doctype) {\n        if (doctype === void 0) { doctype = null; }\n        /**\n         * 1. Let document be a new XMLDocument.\n         */\n        var document = algorithm_1.create_xmlDocument();\n        /**\n         * 2. Let element be null.\n         * 3. If qualifiedName is not the empty string, then set element to\n         * the result of running the internal createElementNS steps, given document,\n         * namespace, qualifiedName, and an empty dictionary.\n         */\n        var element = null;\n        if (qualifiedName) {\n            element = algorithm_1.document_internalCreateElementNS(document, namespace, qualifiedName);\n        }\n        /**\n         * 4. If doctype is non-null, append doctype to document.\n         * 5. If element is non-null, append element to document.\n         */\n        if (doctype)\n            document.appendChild(doctype);\n        if (element)\n            document.appendChild(element);\n        /**\n         * 6. document’s origin is context object’s associated document’s origin.\n         */\n        document._origin = this._associatedDocument._origin;\n        /**\n         * 7. document’s content type is determined by namespace:\n         * - HTML namespace\n         * application/xhtml+xml\n         * - SVG namespace\n         * image/svg+xml\n         * - Any other namespace\n         * application/xml\n         */\n        if (namespace === infra_1.namespace.HTML)\n            document._contentType = \"application/xhtml+xml\";\n        else if (namespace === infra_1.namespace.SVG)\n            document._contentType = \"image/svg+xml\";\n        else\n            document._contentType = \"application/xml\";\n        /**\n         * 8. Return document.\n         */\n        return document;\n    };\n    /** @inheritdoc */\n    DOMImplementationImpl.prototype.createHTMLDocument = function (title) {\n        /**\n         * 1. Let doc be a new document that is an HTML document.\n         * 2. Set doc’s content type to \"text/html\".\n         */\n        var doc = algorithm_1.create_document();\n        doc._type = \"html\";\n        doc._contentType = \"text/html\";\n        /**\n         * 3. Append a new doctype, with \"html\" as its name and with its node\n         * document set to doc, to doc.\n         */\n        doc.appendChild(algorithm_1.create_documentType(doc, \"html\", \"\", \"\"));\n        /**\n         * 4. Append the result of creating an element given doc, html, and the\n         * HTML namespace, to doc.\n         */\n        var htmlElement = algorithm_1.element_createAnElement(doc, \"html\", infra_1.namespace.HTML);\n        doc.appendChild(htmlElement);\n        /**\n         * 5. Append the result of creating an element given doc, head, and the\n         * HTML namespace, to the html element created earlier.\n         */\n        var headElement = algorithm_1.element_createAnElement(doc, \"head\", infra_1.namespace.HTML);\n        htmlElement.appendChild(headElement);\n        /**\n         * 6. If title is given:\n         * 6.1. Append the result of creating an element given doc, title, and\n         * the HTML namespace, to the head element created earlier.\n         * 6.2. Append a new Text node, with its data set to title (which could\n         * be the empty string) and its node document set to doc, to the title\n         * element created earlier.\n         */\n        if (title !== undefined) {\n            var titleElement = algorithm_1.element_createAnElement(doc, \"title\", infra_1.namespace.HTML);\n            headElement.appendChild(titleElement);\n            var textElement = algorithm_1.create_text(doc, title);\n            titleElement.appendChild(textElement);\n        }\n        /**\n         * 7. Append the result of creating an element given doc, body, and the\n         * HTML namespace, to the html element created earlier.\n         */\n        var bodyElement = algorithm_1.element_createAnElement(doc, \"body\", infra_1.namespace.HTML);\n        htmlElement.appendChild(bodyElement);\n        /**\n         * 8. doc’s origin is context object’s associated document’s origin.\n         */\n        doc._origin = this._associatedDocument._origin;\n        /**\n         * 9. Return doc.\n         */\n        return doc;\n    };\n    /** @inheritdoc */\n    DOMImplementationImpl.prototype.hasFeature = function () { return true; };\n    /**\n     * Creates a new `DOMImplementation`.\n     *\n     * @param document - owner document\n     */\n    DOMImplementationImpl._create = function (document) {\n        return new DOMImplementationImpl(document);\n    };\n    return DOMImplementationImpl;\n}());\nexports.DOMImplementationImpl = DOMImplementationImpl;\nWebIDLAlgorithm_1.idl_defineConst(DOMImplementationImpl.prototype, \"_ID\", \"@oozcitak/dom\");\n//# sourceMappingURL=DOMImplementationImpl.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar DOMException_1 = require(\"./DOMException\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a token set.\n */\nvar DOMTokenListImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `DOMTokenList`.\n     *\n     * @param element - associated element\n     * @param attribute - associated attribute\n     */\n    function DOMTokenListImpl(element, attribute) {\n        /**\n         * 1. Let element be associated element.\n         * 2. Let localName be associated attribute’s local name.\n         * 3. Let value be the result of getting an attribute value given element\n         * and localName.\n         * 4. Run the attribute change steps for element, localName, value, value,\n         * and null.\n         */\n        this._element = element;\n        this._attribute = attribute;\n        this._tokenSet = new Set();\n        var localName = attribute._localName;\n        var value = algorithm_1.element_getAnAttributeValue(element, localName);\n        // define a closure to be called when the associated attribute's value changes\n        var thisObj = this;\n        function updateTokenSet(element, localName, oldValue, value, namespace) {\n            /**\n             * 1. If localName is associated attribute’s local name, namespace is null,\n             * and value is null, then empty token set.\n             * 2. Otherwise, if localName is associated attribute’s local name,\n             * namespace is null, then set token set to value, parsed.\n             */\n            if (localName === thisObj._attribute._localName && namespace === null) {\n                if (!value)\n                    thisObj._tokenSet.clear();\n                else\n                    thisObj._tokenSet = algorithm_1.orderedSet_parse(value);\n            }\n        }\n        // add the closure to the associated element's attribute change steps\n        this._element._attributeChangeSteps.push(updateTokenSet);\n        if (DOMImpl_1.dom.features.steps) {\n            algorithm_1.dom_runAttributeChangeSteps(element, localName, value, value, null);\n        }\n    }\n    Object.defineProperty(DOMTokenListImpl.prototype, \"length\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The length attribute' getter must return context object’s token set’s\n             * size.\n             */\n            return this._tokenSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.item = function (index) {\n        var e_1, _a;\n        /**\n         * 1. If index is equal to or greater than context object’s token set’s\n         * size, then return null.\n         * 2. Return context object’s token set[index].\n         */\n        var i = 0;\n        try {\n            for (var _b = __values(this._tokenSet), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var token = _c.value;\n                if (i === index)\n                    return token;\n                i++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return null;\n    };\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.contains = function (token) {\n        /**\n         * The contains(token) method, when invoked, must return true if context\n         * object’s token set[token] exists, and false otherwise.\n         */\n        return this._tokenSet.has(token);\n    };\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.add = function () {\n        var e_2, _a;\n        var tokens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tokens[_i] = arguments[_i];\n        }\n        try {\n            /**\n             * 1. For each token in tokens:\n             * 1.1. If token is the empty string, then throw a \"SyntaxError\"\n             * DOMException.\n             * 1.2. If token contains any ASCII whitespace, then throw an\n             * \"InvalidCharacterError\" DOMException.\n             * 2. For each token in tokens, append token to context object’s token set.\n             * 3. Run the update steps.\n             */\n            for (var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {\n                var token = tokens_1_1.value;\n                if (token === '') {\n                    throw new DOMException_1.SyntaxError(\"Cannot add an empty token.\");\n                }\n                else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {\n                    throw new DOMException_1.InvalidCharacterError(\"Token cannot contain whitespace.\");\n                }\n                else {\n                    this._tokenSet.add(token);\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return)) _a.call(tokens_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        algorithm_1.tokenList_updateSteps(this);\n    };\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.remove = function () {\n        var e_3, _a;\n        var tokens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tokens[_i] = arguments[_i];\n        }\n        try {\n            /**\n             * 1. For each token in tokens:\n             * 1.1. If token is the empty string, then throw a \"SyntaxError\"\n             * DOMException.\n             * 1.2. If token contains any ASCII whitespace, then throw an\n             * \"InvalidCharacterError\" DOMException.\n             * 2. For each token in tokens, remove token from context object’s token set.\n             * 3. Run the update steps.\n             */\n            for (var tokens_2 = __values(tokens), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {\n                var token = tokens_2_1.value;\n                if (token === '') {\n                    throw new DOMException_1.SyntaxError(\"Cannot remove an empty token.\");\n                }\n                else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {\n                    throw new DOMException_1.InvalidCharacterError(\"Token cannot contain whitespace.\");\n                }\n                else {\n                    this._tokenSet.delete(token);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (tokens_2_1 && !tokens_2_1.done && (_a = tokens_2.return)) _a.call(tokens_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        algorithm_1.tokenList_updateSteps(this);\n    };\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.toggle = function (token, force) {\n        if (force === void 0) { force = undefined; }\n        /**\n         * 1. If token is the empty string, then throw a \"SyntaxError\" DOMException.\n         * 2. If token contains any ASCII whitespace, then throw an\n         * \"InvalidCharacterError\" DOMException.\n         */\n        if (token === '') {\n            throw new DOMException_1.SyntaxError(\"Cannot toggle an empty token.\");\n        }\n        else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {\n            throw new DOMException_1.InvalidCharacterError(\"Token cannot contain whitespace.\");\n        }\n        /**\n         * 3. If context object’s token set[token] exists, then:\n         */\n        if (this._tokenSet.has(token)) {\n            /**\n             * 3.1. If force is either not given or is false, then remove token from\n             * context object’s token set, run the update steps and return false.\n             * 3.2. Return true.\n             */\n            if (force === undefined || force === false) {\n                this._tokenSet.delete(token);\n                algorithm_1.tokenList_updateSteps(this);\n                return false;\n            }\n            return true;\n        }\n        /**\n         * 4. Otherwise, if force not given or is true, append token to context\n         * object’s token set, run the update steps, and return true.\n         */\n        if (force === undefined || force === true) {\n            this._tokenSet.add(token);\n            algorithm_1.tokenList_updateSteps(this);\n            return true;\n        }\n        /**\n         * 5. Return false.\n         */\n        return false;\n    };\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.replace = function (token, newToken) {\n        /**\n         * 1. If either token or newToken is the empty string, then throw a\n         * \"SyntaxError\" DOMException.\n         * 2. If either token or newToken contains any ASCII whitespace, then throw\n         * an \"InvalidCharacterError\" DOMException.\n         */\n        if (token === '' || newToken === '') {\n            throw new DOMException_1.SyntaxError(\"Cannot replace an empty token.\");\n        }\n        else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {\n            throw new DOMException_1.InvalidCharacterError(\"Token cannot contain whitespace.\");\n        }\n        /**\n         * 3. If context object’s token set does not contain token, then return\n         * false.\n         */\n        if (!this._tokenSet.has(token))\n            return false;\n        /**\n         * 4. Replace token in context object’s token set with newToken.\n         * 5. Run the update steps.\n         * 6. Return true.\n         */\n        infra_1.set.replace(this._tokenSet, token, newToken);\n        algorithm_1.tokenList_updateSteps(this);\n        return true;\n    };\n    /** @inheritdoc */\n    DOMTokenListImpl.prototype.supports = function (token) {\n        /**\n         * 1. Let result be the return value of validation steps called with token.\n         * 2. Return result.\n         */\n        return algorithm_1.tokenList_validationSteps(this, token);\n    };\n    Object.defineProperty(DOMTokenListImpl.prototype, \"value\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The value attribute must return the result of running context object’s\n             * serialize steps.\n             */\n            return algorithm_1.tokenList_serializeSteps(this);\n        },\n        set: function (value) {\n            /**\n             * Setting the value attribute must set an attribute value for the\n             * associated element using associated attribute’s local name and the given\n             * value.\n             */\n            algorithm_1.element_setAnAttributeValue(this._element, this._attribute._localName, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns an iterator for the token set.\n     */\n    DOMTokenListImpl.prototype[Symbol.iterator] = function () {\n        var it = this._tokenSet[Symbol.iterator]();\n        return {\n            next: function () {\n                return it.next();\n            }\n        };\n    };\n    /**\n     * Creates a new `DOMTokenList`.\n     *\n     * @param element - associated element\n     * @param attribute - associated attribute\n     */\n    DOMTokenListImpl._create = function (element, attribute) {\n        return new DOMTokenListImpl(element, attribute);\n    };\n    return DOMTokenListImpl;\n}());\nexports.DOMTokenListImpl = DOMTokenListImpl;\n//# sourceMappingURL=DOMTokenListImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar NodeImpl_1 = require(\"./NodeImpl\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a document fragment in the XML tree.\n */\nvar DocumentFragmentImpl = /** @class */ (function (_super) {\n    __extends(DocumentFragmentImpl, _super);\n    /**\n     * Initializes a new instance of `DocumentFragment`.\n     *\n     * @param host - shadow root's host element\n     */\n    function DocumentFragmentImpl(host) {\n        if (host === void 0) { host = null; }\n        var _this = _super.call(this) || this;\n        _this._children = new Set();\n        _this._host = host;\n        return _this;\n    }\n    // MIXIN: NonElementParentNode\n    /* istanbul ignore next */\n    DocumentFragmentImpl.prototype.getElementById = function (elementId) { throw new Error(\"Mixin: NonElementParentNode not implemented.\"); };\n    Object.defineProperty(DocumentFragmentImpl.prototype, \"children\", {\n        // MIXIN: ParentNode\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragmentImpl.prototype, \"firstElementChild\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragmentImpl.prototype, \"lastElementChild\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragmentImpl.prototype, \"childElementCount\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    /* istanbul ignore next */\n    DocumentFragmentImpl.prototype.prepend = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ParentNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentFragmentImpl.prototype.append = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ParentNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentFragmentImpl.prototype.querySelector = function (selectors) { throw new Error(\"Mixin: ParentNode not implemented.\"); };\n    /* istanbul ignore next */\n    DocumentFragmentImpl.prototype.querySelectorAll = function (selectors) { throw new Error(\"Mixin: ParentNode not implemented.\"); };\n    /**\n     * Creates a new `DocumentFragment`.\n     *\n     * @param document - owner document\n     * @param host - shadow root's host element\n     */\n    DocumentFragmentImpl._create = function (document, host) {\n        if (host === void 0) { host = null; }\n        var node = new DocumentFragmentImpl(host);\n        node._nodeDocument = document;\n        return node;\n    };\n    return DocumentFragmentImpl;\n}(NodeImpl_1.NodeImpl));\nexports.DocumentFragmentImpl = DocumentFragmentImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(DocumentFragmentImpl.prototype, \"_nodeType\", interfaces_1.NodeType.DocumentFragment);\n//# sourceMappingURL=DocumentFragmentImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar interfaces_1 = require(\"./interfaces\");\nvar DOMException_1 = require(\"./DOMException\");\nvar NodeImpl_1 = require(\"./NodeImpl\");\nvar util_1 = require(\"../util\");\nvar util_2 = require(\"@oozcitak/util\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar URLAlgorithm_1 = require(\"@oozcitak/url/lib/URLAlgorithm\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a document node.\n */\nvar DocumentImpl = /** @class */ (function (_super) {\n    __extends(DocumentImpl, _super);\n    /**\n     * Initializes a new instance of `Document`.\n     */\n    function DocumentImpl() {\n        var _this = _super.call(this) || this;\n        _this._children = new Set();\n        _this._encoding = {\n            name: \"UTF-8\",\n            labels: [\"unicode-1-1-utf-8\", \"utf-8\", \"utf8\"]\n        };\n        _this._contentType = 'application/xml';\n        _this._URL = {\n            scheme: \"about\",\n            username: \"\",\n            password: \"\",\n            host: null,\n            port: null,\n            path: [\"blank\"],\n            query: null,\n            fragment: null,\n            _cannotBeABaseURLFlag: true,\n            _blobURLEntry: null\n        };\n        _this._origin = null;\n        _this._type = \"xml\";\n        _this._mode = \"no-quirks\";\n        _this._documentElement = null;\n        _this._hasNamespaces = false;\n        _this._nodeDocumentOverwrite = null;\n        return _this;\n    }\n    Object.defineProperty(DocumentImpl.prototype, \"_nodeDocument\", {\n        get: function () { return this._nodeDocumentOverwrite || this; },\n        set: function (val) { this._nodeDocumentOverwrite = val; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"implementation\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The implementation attribute’s getter must return the DOMImplementation\n             * object that is associated with the document.\n             */\n            return this._implementation || (this._implementation = algorithm_1.create_domImplementation(this));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"URL\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The URL attribute’s getter and documentURI attribute’s getter must return\n             * the URL, serialized.\n             * See: https://url.spec.whatwg.org/#concept-url-serializer\n             */\n            return URLAlgorithm_1.urlSerializer(this._URL);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"documentURI\", {\n        /** @inheritdoc */\n        get: function () { return this.URL; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"origin\", {\n        /** @inheritdoc */\n        get: function () {\n            return \"null\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"compatMode\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The compatMode attribute’s getter must return \"BackCompat\" if context\n             * object’s mode is \"quirks\", and \"CSS1Compat\" otherwise.\n             */\n            return this._mode === \"quirks\" ? \"BackCompat\" : \"CSS1Compat\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"characterSet\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The characterSet attribute’s getter, charset attribute’s getter, and\n             * inputEncoding attribute’s getter, must return context object’s\n             * encoding’s name.\n             */\n            return this._encoding.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"charset\", {\n        /** @inheritdoc */\n        get: function () { return this._encoding.name; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"inputEncoding\", {\n        /** @inheritdoc */\n        get: function () { return this._encoding.name; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"contentType\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The contentType attribute’s getter must return the content type.\n             */\n            return this._contentType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"doctype\", {\n        /** @inheritdoc */\n        get: function () {\n            var e_1, _a;\n            try {\n                /**\n                 * The doctype attribute’s getter must return the child of the document\n                 * that is a doctype, and null otherwise.\n                 */\n                for (var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var child = _c.value;\n                    if (util_1.Guard.isDocumentTypeNode(child))\n                        return child;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"documentElement\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The documentElement attribute’s getter must return the document element.\n             */\n            return this._documentElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    DocumentImpl.prototype.getElementsByTagName = function (qualifiedName) {\n        /**\n         * The getElementsByTagName(qualifiedName) method, when invoked, must return\n         * the list of elements with qualified name qualifiedName for the context object.\n         */\n        return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.getElementsByTagNameNS = function (namespace, localName) {\n        /**\n         * The getElementsByTagNameNS(namespace, localName) method, when invoked,\n         * must return the list of elements with namespace namespace and local name\n         * localName for the context object.\n         */\n        return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.getElementsByClassName = function (classNames) {\n        /**\n         * The getElementsByClassName(classNames) method, when invoked, must return\n         * the list of elements with class names classNames for the context object.\n         */\n        return algorithm_1.node_listOfElementsWithClassNames(classNames, this);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createElement = function (localName, options) {\n        /**\n         * 1. If localName does not match the Name production, then throw an\n         * \"InvalidCharacterError\" DOMException.\n         * 2. If the context object is an HTML document, then set localName to\n         * localName in ASCII lowercase.\n         * 3. Let is be null.\n         * 4. If options is a dictionary and options’s is is present, then set is\n         * to it.\n         * 5. Let namespace be the HTML namespace, if the context object is an\n         * HTML document or context object’s content type is\n         * \"application/xhtml+xml\", and null otherwise.\n         * 6. Return the result of creating an element given the context object,\n         * localName, namespace, null, is, and with the synchronous custom elements\n         * flag set.\n         */\n        if (!algorithm_1.xml_isName(localName))\n            throw new DOMException_1.InvalidCharacterError();\n        if (this._type === \"html\")\n            localName = localName.toLowerCase();\n        var is = null;\n        if (options !== undefined) {\n            if (util_2.isString(options)) {\n                is = options;\n            }\n            else {\n                is = options.is;\n            }\n        }\n        var namespace = (this._type === \"html\" || this._contentType === \"application/xhtml+xml\") ?\n            infra_1.namespace.HTML : null;\n        return algorithm_1.element_createAnElement(this, localName, namespace, null, is, true);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createElementNS = function (namespace, qualifiedName, options) {\n        /**\n         * The createElementNS(namespace, qualifiedName, options) method, when\n         * invoked, must return the result of running the internal createElementNS\n         * steps, given context object, namespace, qualifiedName, and options.\n         */\n        return algorithm_1.document_internalCreateElementNS(this, namespace, qualifiedName, options);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createDocumentFragment = function () {\n        /**\n         * The createDocumentFragment() method, when invoked, must return a new\n         * DocumentFragment node with its node document set to the context object.\n         */\n        return algorithm_1.create_documentFragment(this);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createTextNode = function (data) {\n        /**\n         * The createTextNode(data) method, when invoked, must return a new Text\n         * node with its data set to data and node document set to the context object.\n         */\n        return algorithm_1.create_text(this, data);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createCDATASection = function (data) {\n        /**\n         * 1. If context object is an HTML document, then throw a\n         * \"NotSupportedError\" DOMException.\n         * 2. If data contains the string \"]]>\", then throw an\n         * \"InvalidCharacterError\" DOMException.\n         * 3. Return a new CDATASection node with its data set to data and node\n         * document set to the context object.\n         */\n        if (this._type === \"html\")\n            throw new DOMException_1.NotSupportedError();\n        if (data.indexOf(']]>') !== -1)\n            throw new DOMException_1.InvalidCharacterError();\n        return algorithm_1.create_cdataSection(this, data);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createComment = function (data) {\n        /**\n         * The createComment(data) method, when invoked, must return a new Comment\n         * node with its data set to data and node document set to the context object.\n         */\n        return algorithm_1.create_comment(this, data);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createProcessingInstruction = function (target, data) {\n        /**\n         * 1. If target does not match the Name production, then throw an\n         * \"InvalidCharacterError\" DOMException.\n         * 2. If data contains the string \"?>\", then throw an\n         * \"InvalidCharacterError\" DOMException.\n         * 3. Return a new ProcessingInstruction node, with target set to target,\n         * data set to data, and node document set to the context object.\n         */\n        if (!algorithm_1.xml_isName(target))\n            throw new DOMException_1.InvalidCharacterError();\n        if (data.indexOf(\"?>\") !== -1)\n            throw new DOMException_1.InvalidCharacterError();\n        return algorithm_1.create_processingInstruction(this, target, data);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.importNode = function (node, deep) {\n        if (deep === void 0) { deep = false; }\n        /**\n         * 1. If node is a document or shadow root, then throw a \"NotSupportedError\" DOMException.\n         */\n        if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node))\n            throw new DOMException_1.NotSupportedError();\n        /**\n         * 2. Return a clone of node, with context object and the clone children flag set if deep is true.\n         */\n        return algorithm_1.node_clone(node, this, deep);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.adoptNode = function (node) {\n        /**\n         * 1. If node is a document, then throw a \"NotSupportedError\" DOMException.\n         */\n        if (util_1.Guard.isDocumentNode(node))\n            throw new DOMException_1.NotSupportedError();\n        /**\n         * 2. If node is a shadow root, then throw a \"HierarchyRequestError\" DOMException.\n         */\n        if (util_1.Guard.isShadowRoot(node))\n            throw new DOMException_1.HierarchyRequestError();\n        /**\n         * 3. Adopt node into the context object.\n         * 4. Return node.\n         */\n        algorithm_1.document_adopt(node, this);\n        return node;\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createAttribute = function (localName) {\n        /**\n         * 1. If localName does not match the Name production in XML, then throw\n         * an \"InvalidCharacterError\" DOMException.\n         * 2. If the context object is an HTML document, then set localName to\n         * localName in ASCII lowercase.\n         * 3. Return a new attribute whose local name is localName and node document\n         * is context object.\n         */\n        if (!algorithm_1.xml_isName(localName))\n            throw new DOMException_1.InvalidCharacterError();\n        if (this._type === \"html\") {\n            localName = localName.toLowerCase();\n        }\n        var attr = algorithm_1.create_attr(this, localName);\n        return attr;\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createAttributeNS = function (namespace, qualifiedName) {\n        /**\n         * 1. Let namespace, prefix, and localName be the result of passing\n         * namespace and qualifiedName to validate and extract.\n         * 2. Return a new attribute whose namespace is namespace, namespace prefix\n         * is prefix, local name is localName, and node document is context object.\n         */\n        var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];\n        var attr = algorithm_1.create_attr(this, localName);\n        attr._namespace = ns;\n        attr._namespacePrefix = prefix;\n        return attr;\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createEvent = function (eventInterface) {\n        return algorithm_1.event_createLegacyEvent(eventInterface);\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createRange = function () {\n        /**\n         * The createRange() method, when invoked, must return a new live range\n         * with (context object, 0) as its start and end.\n         */\n        var range = algorithm_1.create_range();\n        range._start = [this, 0];\n        range._end = [this, 0];\n        return range;\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createNodeIterator = function (root, whatToShow, filter) {\n        if (whatToShow === void 0) { whatToShow = interfaces_1.WhatToShow.All; }\n        if (filter === void 0) { filter = null; }\n        /**\n         * 1. Let iterator be a new NodeIterator object.\n         * 2. Set iterator’s root and iterator’s reference to root.\n         * 3. Set iterator’s pointer before reference to true.\n         * 4. Set iterator’s whatToShow to whatToShow.\n         * 5. Set iterator’s filter to filter.\n         * 6. Return iterator.\n         */\n        var iterator = algorithm_1.create_nodeIterator(root, root, true);\n        iterator._whatToShow = whatToShow;\n        iterator._iteratorCollection = algorithm_1.create_nodeList(root);\n        if (util_2.isFunction(filter)) {\n            iterator._filter = algorithm_1.create_nodeFilter();\n            iterator._filter.acceptNode = filter;\n        }\n        else {\n            iterator._filter = filter;\n        }\n        return iterator;\n    };\n    /** @inheritdoc */\n    DocumentImpl.prototype.createTreeWalker = function (root, whatToShow, filter) {\n        if (whatToShow === void 0) { whatToShow = interfaces_1.WhatToShow.All; }\n        if (filter === void 0) { filter = null; }\n        /**\n         * 1. Let walker be a new TreeWalker object.\n         * 2. Set walker’s root and walker’s current to root.\n         * 3. Set walker’s whatToShow to whatToShow.\n         * 4. Set walker’s filter to filter.\n         * 5. Return walker.\n         */\n        var walker = algorithm_1.create_treeWalker(root, root);\n        walker._whatToShow = whatToShow;\n        if (util_2.isFunction(filter)) {\n            walker._filter = algorithm_1.create_nodeFilter();\n            walker._filter.acceptNode = filter;\n        }\n        else {\n            walker._filter = filter;\n        }\n        return walker;\n    };\n    /**\n     * Gets the parent event target for the given event.\n     *\n     * @param event - an event\n     */\n    DocumentImpl.prototype._getTheParent = function (event) {\n        /**\n         * TODO: Implement realms\n         * A document’s get the parent algorithm, given an event, returns null if\n         * event’s type attribute value is \"load\" or document does not have a\n         * browsing context, and the document’s relevant global object otherwise.\n         */\n        if (event._type === \"load\") {\n            return null;\n        }\n        else {\n            return DOMImpl_1.dom.window;\n        }\n    };\n    // MIXIN: NonElementParentNode\n    /* istanbul ignore next */\n    DocumentImpl.prototype.getElementById = function (elementId) { throw new Error(\"Mixin: NonElementParentNode not implemented.\"); };\n    Object.defineProperty(DocumentImpl.prototype, \"children\", {\n        // MIXIN: DocumentOrShadowRoot\n        // No elements\n        // MIXIN: ParentNode\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"firstElementChild\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"lastElementChild\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentImpl.prototype, \"childElementCount\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    /* istanbul ignore next */\n    DocumentImpl.prototype.prepend = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ParentNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentImpl.prototype.append = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ParentNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentImpl.prototype.querySelector = function (selectors) { throw new Error(\"Mixin: ParentNode not implemented.\"); };\n    /* istanbul ignore next */\n    DocumentImpl.prototype.querySelectorAll = function (selectors) { throw new Error(\"Mixin: ParentNode not implemented.\"); };\n    return DocumentImpl;\n}(NodeImpl_1.NodeImpl));\nexports.DocumentImpl = DocumentImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(DocumentImpl.prototype, \"_nodeType\", interfaces_1.NodeType.Document);\n//# sourceMappingURL=DocumentImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a mixin for an interface to be used to share APIs between\n * documents and shadow roots. This mixin is implemented by\n * {@link Document} and {@link ShadowRoot}.\n *\n * _Note:_ The DocumentOrShadowRoot mixin is expected to be used by other\n * standards that want to define APIs shared between documents and shadow roots.\n */\nvar DocumentOrShadowRootImpl = /** @class */ (function () {\n    function DocumentOrShadowRootImpl() {\n    }\n    return DocumentOrShadowRootImpl;\n}());\nexports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl;\n//# sourceMappingURL=DocumentOrShadowRootImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar NodeImpl_1 = require(\"./NodeImpl\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents an object providing methods which are not dependent on\n * any particular document\n */\nvar DocumentTypeImpl = /** @class */ (function (_super) {\n    __extends(DocumentTypeImpl, _super);\n    /**\n     * Initializes a new instance of `DocumentType`.\n     *\n     * @param name - name of the node\n     * @param publicId - `PUBLIC` identifier\n     * @param systemId - `SYSTEM` identifier\n     */\n    function DocumentTypeImpl(name, publicId, systemId) {\n        var _this = _super.call(this) || this;\n        _this._name = '';\n        _this._publicId = '';\n        _this._systemId = '';\n        _this._name = name;\n        _this._publicId = publicId;\n        _this._systemId = systemId;\n        return _this;\n    }\n    Object.defineProperty(DocumentTypeImpl.prototype, \"name\", {\n        /** @inheritdoc */\n        get: function () { return this._name; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentTypeImpl.prototype, \"publicId\", {\n        /** @inheritdoc */\n        get: function () { return this._publicId; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentTypeImpl.prototype, \"systemId\", {\n        /** @inheritdoc */\n        get: function () { return this._systemId; },\n        enumerable: true,\n        configurable: true\n    });\n    // MIXIN: ChildNode\n    /* istanbul ignore next */\n    DocumentTypeImpl.prototype.before = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentTypeImpl.prototype.after = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentTypeImpl.prototype.replaceWith = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    DocumentTypeImpl.prototype.remove = function () { throw new Error(\"Mixin: ChildNode not implemented.\"); };\n    /**\n     * Creates a new `DocumentType`.\n     *\n     * @param document - owner document\n     * @param name - name of the node\n     * @param publicId - `PUBLIC` identifier\n     * @param systemId - `SYSTEM` identifier\n     */\n    DocumentTypeImpl._create = function (document, name, publicId, systemId) {\n        if (publicId === void 0) { publicId = ''; }\n        if (systemId === void 0) { systemId = ''; }\n        var node = new DocumentTypeImpl(name, publicId, systemId);\n        node._nodeDocument = document;\n        return node;\n    };\n    return DocumentTypeImpl;\n}(NodeImpl_1.NodeImpl));\nexports.DocumentTypeImpl = DocumentTypeImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(DocumentTypeImpl.prototype, \"_nodeType\", interfaces_1.NodeType.DocumentType);\n//# sourceMappingURL=DocumentTypeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar NodeImpl_1 = require(\"./NodeImpl\");\nvar DOMException_1 = require(\"./DOMException\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents an element node.\n */\nvar ElementImpl = /** @class */ (function (_super) {\n    __extends(ElementImpl, _super);\n    /**\n     * Initializes a new instance of `Element`.\n     */\n    function ElementImpl() {\n        var _this = _super.call(this) || this;\n        _this._children = new Set();\n        _this._namespace = null;\n        _this._namespacePrefix = null;\n        _this._localName = \"\";\n        _this._customElementState = \"undefined\";\n        _this._customElementDefinition = null;\n        _this._is = null;\n        _this._shadowRoot = null;\n        _this._attributeList = algorithm_1.create_namedNodeMap(_this);\n        _this._attributeChangeSteps = [];\n        _this._name = '';\n        _this._assignedSlot = null;\n        return _this;\n    }\n    Object.defineProperty(ElementImpl.prototype, \"namespaceURI\", {\n        /** @inheritdoc */\n        get: function () { return this._namespace; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"prefix\", {\n        /** @inheritdoc */\n        get: function () { return this._namespacePrefix; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"localName\", {\n        /** @inheritdoc */\n        get: function () { return this._localName; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"tagName\", {\n        /** @inheritdoc */\n        get: function () { return this._htmlUppercasedQualifiedName; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"id\", {\n        /** @inheritdoc */\n        get: function () {\n            return algorithm_1.element_getAnAttributeValue(this, \"id\");\n        },\n        set: function (value) {\n            algorithm_1.element_setAnAttributeValue(this, \"id\", value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"className\", {\n        /** @inheritdoc */\n        get: function () {\n            return algorithm_1.element_getAnAttributeValue(this, \"class\");\n        },\n        set: function (value) {\n            algorithm_1.element_setAnAttributeValue(this, \"class\", value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"classList\", {\n        /** @inheritdoc */\n        get: function () {\n            var attr = algorithm_1.element_getAnAttributeByName(\"class\", this);\n            if (attr === null) {\n                attr = algorithm_1.create_attr(this._nodeDocument, \"class\");\n            }\n            return algorithm_1.create_domTokenList(this, attr);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"slot\", {\n        /** @inheritdoc */\n        get: function () {\n            return algorithm_1.element_getAnAttributeValue(this, \"slot\");\n        },\n        set: function (value) {\n            algorithm_1.element_setAnAttributeValue(this, \"slot\", value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    ElementImpl.prototype.hasAttributes = function () {\n        return this._attributeList.length !== 0;\n    };\n    Object.defineProperty(ElementImpl.prototype, \"attributes\", {\n        /** @inheritdoc */\n        get: function () { return this._attributeList; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    ElementImpl.prototype.getAttributeNames = function () {\n        var e_1, _a;\n        /**\n         * The getAttributeNames() method, when invoked, must return the qualified\n         * names of the attributes in context object’s attribute list, in order,\n         * and a new list otherwise.\n         */\n        var names = [];\n        try {\n            for (var _b = __values(this._attributeList), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                names.push(attr._qualifiedName);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return names;\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getAttribute = function (qualifiedName) {\n        /**\n         * 1. Let attr be the result of getting an attribute given qualifiedName\n         * and the context object.\n         * 2. If attr is null, return null.\n         * 3. Return attr’s value.\n         */\n        var attr = algorithm_1.element_getAnAttributeByName(qualifiedName, this);\n        return (attr ? attr._value : null);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getAttributeNS = function (namespace, localName) {\n        /**\n         * 1. Let attr be the result of getting an attribute given namespace,\n         * localName, and the context object.\n         * 2. If attr is null, return null.\n         * 3. Return attr’s value.\n         */\n        var attr = algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);\n        return (attr ? attr._value : null);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.setAttribute = function (qualifiedName, value) {\n        /**\n         * 1. If qualifiedName does not match the Name production in XML, then\n         * throw an \"InvalidCharacterError\" DOMException.\n         */\n        if (!algorithm_1.xml_isName(qualifiedName))\n            throw new DOMException_1.InvalidCharacterError();\n        /**\n         * 2. If the context object is in the HTML namespace and its node document\n         * is an HTML document, then set qualifiedName to qualifiedName in ASCII\n         * lowercase.\n         */\n        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === \"html\") {\n            qualifiedName = qualifiedName.toLowerCase();\n        }\n        /**\n         * 3. Let attribute be the first attribute in context object’s attribute\n         * list whose qualified name is qualifiedName, and null otherwise.\n         */\n        var attribute = null;\n        for (var i = 0; i < this._attributeList.length; i++) {\n            var attr = this._attributeList[i];\n            if (attr._qualifiedName === qualifiedName) {\n                attribute = attr;\n                break;\n            }\n        }\n        /**\n         * 4. If attribute is null, create an attribute whose local name is\n         * qualifiedName, value is value, and node document is context object’s\n         * node document, then append this attribute to context object, and\n         * then return.\n         */\n        if (attribute === null) {\n            attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);\n            attribute._value = value;\n            algorithm_1.element_append(attribute, this);\n            return;\n        }\n        /**\n         * 5. Change attribute from context object to value.\n         */\n        algorithm_1.element_change(attribute, this, value);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.setAttributeNS = function (namespace, qualifiedName, value) {\n        /**\n         * 1. Let namespace, prefix, and localName be the result of passing\n         * namespace and qualifiedName to validate and extract.\n         * 2. Set an attribute value for the context object using localName, value,\n         * and also prefix and namespace.\n         */\n        var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];\n        algorithm_1.element_setAnAttributeValue(this, localName, value, prefix, ns);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.removeAttribute = function (qualifiedName) {\n        /**\n         * The removeAttribute(qualifiedName) method, when invoked, must remove an\n         * attribute given qualifiedName and the context object, and then return\n         * undefined.\n         */\n        algorithm_1.element_removeAnAttributeByName(qualifiedName, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.removeAttributeNS = function (namespace, localName) {\n        /**\n         * The removeAttributeNS(namespace, localName) method, when invoked, must\n         * remove an attribute given namespace, localName, and context object, and\n         * then return undefined.\n         */\n        algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.hasAttribute = function (qualifiedName) {\n        /**\n         * 1. If the context object is in the HTML namespace and its node document\n         * is an HTML document, then set qualifiedName to qualifiedName in ASCII\n         * lowercase.\n         * 2. Return true if the context object has an attribute whose qualified\n         * name is qualifiedName, and false otherwise.\n         */\n        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === \"html\") {\n            qualifiedName = qualifiedName.toLowerCase();\n        }\n        for (var i = 0; i < this._attributeList.length; i++) {\n            var attr = this._attributeList[i];\n            if (attr._qualifiedName === qualifiedName) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.toggleAttribute = function (qualifiedName, force) {\n        /**\n         * 1. If qualifiedName does not match the Name production in XML, then\n         * throw an \"InvalidCharacterError\" DOMException.\n         */\n        if (!algorithm_1.xml_isName(qualifiedName))\n            throw new DOMException_1.InvalidCharacterError();\n        /**\n         * 2. If the context object is in the HTML namespace and its node document\n         * is an HTML document, then set qualifiedName to qualifiedName in ASCII\n         * lowercase.\n         */\n        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === \"html\") {\n            qualifiedName = qualifiedName.toLowerCase();\n        }\n        /**\n         * 3. Let attribute be the first attribute in the context object’s attribute\n         * list whose qualified name is qualifiedName, and null otherwise.\n         */\n        var attribute = null;\n        for (var i = 0; i < this._attributeList.length; i++) {\n            var attr = this._attributeList[i];\n            if (attr._qualifiedName === qualifiedName) {\n                attribute = attr;\n                break;\n            }\n        }\n        if (attribute === null) {\n            /**\n             * 4. If attribute is null, then:\n             * 4.1. If force is not given or is true, create an attribute whose local\n             * name is qualifiedName, value is the empty string, and node document is\n             * the context object’s node document, then append this attribute to the\n             * context object, and then return true.\n             * 4.2. Return false.\n             */\n            if (force === undefined || force === true) {\n                attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);\n                attribute._value = '';\n                algorithm_1.element_append(attribute, this);\n                return true;\n            }\n            return false;\n        }\n        else if (force === undefined || force === false) {\n            /**\n             * 5. Otherwise, if force is not given or is false, remove an attribute\n             * given qualifiedName and the context object, and then return false.\n             */\n            algorithm_1.element_removeAnAttributeByName(qualifiedName, this);\n            return false;\n        }\n        /**\n         * 6. Return true.\n         */\n        return true;\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.hasAttributeNS = function (namespace, localName) {\n        /**\n         * 1. If namespace is the empty string, set it to null.\n         * 2. Return true if the context object has an attribute whose namespace is\n         * namespace and local name is localName, and false otherwise.\n         */\n        var ns = namespace || null;\n        for (var i = 0; i < this._attributeList.length; i++) {\n            var attr = this._attributeList[i];\n            if (attr._namespace === ns && attr._localName === localName) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getAttributeNode = function (qualifiedName) {\n        /**\n         * The getAttributeNode(qualifiedName) method, when invoked, must return the\n         * result of getting an attribute given qualifiedName and context object.\n         */\n        return algorithm_1.element_getAnAttributeByName(qualifiedName, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getAttributeNodeNS = function (namespace, localName) {\n        /**\n         * The getAttributeNodeNS(namespace, localName) method, when invoked, must\n         * return the result of getting an attribute given namespace, localName, and\n         * the context object.\n         */\n        return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.setAttributeNode = function (attr) {\n        /**\n         * The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when\n         * invoked, must return the result of setting an attribute given attr and\n         * the context object.\n         */\n        return algorithm_1.element_setAnAttribute(attr, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.setAttributeNodeNS = function (attr) {\n        return algorithm_1.element_setAnAttribute(attr, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.removeAttributeNode = function (attr) {\n        /**\n         * 1. If context object’s attribute list does not contain attr, then throw\n         * a \"NotFoundError\" DOMException.\n         * 2. Remove attr from context object.\n         * 3. Return attr.\n         */\n        var found = false;\n        for (var i = 0; i < this._attributeList.length; i++) {\n            var attribute = this._attributeList[i];\n            if (attribute === attr) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            throw new DOMException_1.NotFoundError();\n        algorithm_1.element_remove(attr, this);\n        return attr;\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.attachShadow = function (init) {\n        /**\n         * 1. If context object’s namespace is not the HTML namespace, then throw a\n         * \"NotSupportedError\" DOMException.\n         */\n        if (this._namespace !== infra_1.namespace.HTML)\n            throw new DOMException_1.NotSupportedError();\n        /**\n         * 2. If context object’s local name is not a valid custom element name,\n         * \"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\",\n         * \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\" \"nav\", \"p\", \"section\",\n         * or \"span\", then throw a \"NotSupportedError\" DOMException.\n         */\n        if (!algorithm_1.customElement_isValidCustomElementName(this._localName) &&\n            !algorithm_1.customElement_isValidShadowHostName(this._localName))\n            throw new DOMException_1.NotSupportedError();\n        /**\n         * 3. If context object’s local name is a valid custom element name,\n         * or context object’s is value is not null, then:\n         * 3.1. Let definition be the result of looking up a custom element\n         * definition given context object’s node document, its namespace, its\n         * local name, and its is value.\n         * 3.2. If definition is not null and definition’s disable shadow is true,\n         *  then throw a \"NotSupportedError\" DOMException.\n         */\n        if (algorithm_1.customElement_isValidCustomElementName(this._localName) || this._is !== null) {\n            var definition = algorithm_1.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);\n            if (definition !== null && definition.disableShadow === true) {\n                throw new DOMException_1.NotSupportedError();\n            }\n        }\n        /**\n         * 4. If context object is a shadow host, then throw an \"NotSupportedError\"\n         * DOMException.\n         */\n        if (this._shadowRoot !== null)\n            throw new DOMException_1.NotSupportedError();\n        /**\n         * 5. Let shadow be a new shadow root whose node document is context\n         * object’s node document, host is context object, and mode is init’s mode.\n         * 6. Set context object’s shadow root to shadow.\n         * 7. Return shadow.\n         */\n        var shadow = algorithm_1.create_shadowRoot(this._nodeDocument, this);\n        shadow._mode = init.mode;\n        this._shadowRoot = shadow;\n        return shadow;\n    };\n    Object.defineProperty(ElementImpl.prototype, \"shadowRoot\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * 1. Let shadow be context object’s shadow root.\n             * 2. If shadow is null or its mode is \"closed\", then return null.\n             * 3. Return shadow.\n             */\n            var shadow = this._shadowRoot;\n            if (shadow === null || shadow.mode === \"closed\")\n                return null;\n            else\n                return shadow;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    ElementImpl.prototype.closest = function (selectors) {\n        /**\n         * TODO: Selectors\n         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]\n         * 2. If s is failure, throw a \"SyntaxError\" DOMException.\n         * 3. Let elements be context object’s inclusive ancestors that are\n         * elements, in reverse tree order.\n         * 4. For each element in elements, if match a selector against an element,\n         * using s, element, and :scope element context object, returns success,\n         * return element. [SELECTORS4]\n         * 5. Return null.\n         */\n        throw new DOMException_1.NotImplementedError();\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.matches = function (selectors) {\n        /**\n         * TODO: Selectors\n         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]\n         * 2. If s is failure, throw a \"SyntaxError\" DOMException.\n         * 3. Return true if the result of match a selector against an element,\n         * using s, element, and :scope element context object, returns success,\n         * and false otherwise. [SELECTORS4]\n         */\n        throw new DOMException_1.NotImplementedError();\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.webkitMatchesSelector = function (selectors) {\n        return this.matches(selectors);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getElementsByTagName = function (qualifiedName) {\n        /**\n         * The getElementsByTagName(qualifiedName) method, when invoked, must return\n         * the list of elements with qualified name qualifiedName for context\n         * object.\n         */\n        return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getElementsByTagNameNS = function (namespace, localName) {\n        /**\n         * The getElementsByTagNameNS(namespace, localName) method, when invoked,\n         * must return the list of elements with namespace namespace and local name\n         * localName for context object.\n         */\n        return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.getElementsByClassName = function (classNames) {\n        /**\n         * The getElementsByClassName(classNames) method, when invoked, must return\n         * the list of elements with class names classNames for context object.\n         */\n        return algorithm_1.node_listOfElementsWithClassNames(classNames, this);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.insertAdjacentElement = function (where, element) {\n        /**\n         * The insertAdjacentElement(where, element) method, when invoked, must\n         * return the result of running insert adjacent, given context object,\n         *  where, and element.\n         */\n        return algorithm_1.element_insertAdjacent(this, where, element);\n    };\n    /** @inheritdoc */\n    ElementImpl.prototype.insertAdjacentText = function (where, data) {\n        /**\n         * 1. Let text be a new Text node whose data is data and node document is\n         * context object’s node document.\n         * 2. Run insert adjacent, given context object, where, and text.\n         */\n        var text = algorithm_1.create_text(this._nodeDocument, data);\n        algorithm_1.element_insertAdjacent(this, where, text);\n    };\n    Object.defineProperty(ElementImpl.prototype, \"_qualifiedName\", {\n        /**\n         * Returns the qualified name.\n         */\n        get: function () {\n            /**\n             * An element’s qualified name is its local name if its namespace prefix is\n             * null, and its namespace prefix, followed by \":\", followed by its\n             * local name, otherwise.\n             */\n            return (this._namespacePrefix ?\n                this._namespacePrefix + ':' + this._localName :\n                this._localName);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"_htmlUppercasedQualifiedName\", {\n        /**\n         * Returns the upper-cased qualified name for a html element.\n         */\n        get: function () {\n            /**\n             * 1. Let qualifiedName be context object’s qualified name.\n             * 2. If the context object is in the HTML namespace and its node document\n             * is an HTML document, then set qualifiedName to qualifiedName in ASCII\n             * uppercase.\n             * 3. Return qualifiedName.\n             */\n            var qualifiedName = this._qualifiedName;\n            if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === \"html\") {\n                qualifiedName = qualifiedName.toUpperCase();\n            }\n            return qualifiedName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"children\", {\n        // MIXIN: ParentNode\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"firstElementChild\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"lastElementChild\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"childElementCount\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: ParentNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    /* istanbul ignore next */\n    ElementImpl.prototype.prepend = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ParentNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    ElementImpl.prototype.append = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ParentNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    ElementImpl.prototype.querySelector = function (selectors) { throw new Error(\"Mixin: ParentNode not implemented.\"); };\n    /* istanbul ignore next */\n    ElementImpl.prototype.querySelectorAll = function (selectors) { throw new Error(\"Mixin: ParentNode not implemented.\"); };\n    Object.defineProperty(ElementImpl.prototype, \"previousElementSibling\", {\n        // MIXIN: NonDocumentTypeChildNode\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: NonDocumentTypeChildNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ElementImpl.prototype, \"nextElementSibling\", {\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: NonDocumentTypeChildNode not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    // MIXIN: ChildNode\n    /* istanbul ignore next */\n    ElementImpl.prototype.before = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    ElementImpl.prototype.after = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    ElementImpl.prototype.replaceWith = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        throw new Error(\"Mixin: ChildNode not implemented.\");\n    };\n    /* istanbul ignore next */\n    ElementImpl.prototype.remove = function () { throw new Error(\"Mixin: ChildNode not implemented.\"); };\n    Object.defineProperty(ElementImpl.prototype, \"assignedSlot\", {\n        // MIXIN: Slotable\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: Slotable not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new `Element`.\n     *\n     * @param document - owner document\n     * @param localName - local name\n     * @param namespace - namespace\n     * @param prefix - namespace prefix\n     */\n    ElementImpl._create = function (document, localName, namespace, namespacePrefix) {\n        if (namespace === void 0) { namespace = null; }\n        if (namespacePrefix === void 0) { namespacePrefix = null; }\n        var node = new ElementImpl();\n        node._localName = localName;\n        node._namespace = namespace;\n        node._namespacePrefix = namespacePrefix;\n        node._nodeDocument = document;\n        return node;\n    };\n    return ElementImpl;\n}(NodeImpl_1.NodeImpl));\nexports.ElementImpl = ElementImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(ElementImpl.prototype, \"_nodeType\", interfaces_1.NodeType.Element);\n//# sourceMappingURL=ElementImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a DOM event.\n */\nvar EventImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `Event`.\n     */\n    function EventImpl(type, eventInit) {\n        this._target = null;\n        this._relatedTarget = null;\n        this._touchTargetList = [];\n        this._path = [];\n        this._currentTarget = null;\n        this._eventPhase = interfaces_1.EventPhase.None;\n        this._stopPropagationFlag = false;\n        this._stopImmediatePropagationFlag = false;\n        this._canceledFlag = false;\n        this._inPassiveListenerFlag = false;\n        this._composedFlag = false;\n        this._initializedFlag = false;\n        this._dispatchFlag = false;\n        this._isTrusted = false;\n        this._bubbles = false;\n        this._cancelable = false;\n        /**\n         * When a constructor of the Event interface, or of an interface that\n         * inherits from the Event interface, is invoked, these steps must be run,\n         * given the arguments type and eventInitDict:\n         * 1. Let event be the result of running the inner event creation steps with\n         * this interface, null, now, and eventInitDict.\n         * 2. Initialize event’s type attribute to type.\n         * 3. Return event.\n         */\n        this._type = type;\n        if (eventInit) {\n            this._bubbles = eventInit.bubbles || false;\n            this._cancelable = eventInit.cancelable || false;\n            this._composedFlag = eventInit.composed || false;\n        }\n        this._initializedFlag = true;\n        this._timeStamp = new Date().getTime();\n    }\n    Object.defineProperty(EventImpl.prototype, \"type\", {\n        /** @inheritdoc */\n        get: function () { return this._type; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"target\", {\n        /** @inheritdoc */\n        get: function () { return this._target; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"srcElement\", {\n        /** @inheritdoc */\n        get: function () { return this._target; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"currentTarget\", {\n        /** @inheritdoc */\n        get: function () { return this._currentTarget; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    EventImpl.prototype.composedPath = function () {\n        /**\n         * 1. Let composedPath be an empty list.\n         * 2. Let path be the context object’s path.\n         * 3. If path is empty, then return composedPath.\n         * 4. Let currentTarget be the context object’s currentTarget attribute\n         * value.\n         * 5. Append currentTarget to composedPath.\n         * 6. Let currentTargetIndex be 0.\n         * 7. Let currentTargetHiddenSubtreeLevel be 0.\n         */\n        var composedPath = [];\n        var path = this._path;\n        if (path.length === 0)\n            return composedPath;\n        var currentTarget = this._currentTarget;\n        if (currentTarget === null) {\n            throw new Error(\"Event currentTarget is null.\");\n        }\n        composedPath.push(currentTarget);\n        var currentTargetIndex = 0;\n        var currentTargetHiddenSubtreeLevel = 0;\n        /**\n         * 8. Let index be path’s size − 1.\n         * 9. While index is greater than or equal to 0:\n         */\n        var index = path.length - 1;\n        while (index >= 0) {\n            /**\n             * 9.1. If path[index]'s root-of-closed-tree is true, then increase\n             * currentTargetHiddenSubtreeLevel by 1.\n             * 9.2. If path[index]'s invocation target is currentTarget, then set\n             * currentTargetIndex to index and break.\n             * 9.3. If path[index]'s slot-in-closed-tree is true, then decrease\n             * currentTargetHiddenSubtreeLevel by 1.\n             * 9.4. Decrease index by 1.\n             */\n            if (path[index].rootOfClosedTree) {\n                currentTargetHiddenSubtreeLevel++;\n            }\n            if (path[index].invocationTarget === currentTarget) {\n                currentTargetIndex = index;\n                break;\n            }\n            if (path[index].slotInClosedTree) {\n                currentTargetHiddenSubtreeLevel--;\n            }\n            index--;\n        }\n        /**\n         * 10. Let currentHiddenLevel and maxHiddenLevel be\n         * currentTargetHiddenSubtreeLevel.\n         */\n        var currentHiddenLevel = currentTargetHiddenSubtreeLevel;\n        var maxHiddenLevel = currentTargetHiddenSubtreeLevel;\n        /**\n         * 11. Set index to currentTargetIndex − 1.\n         * 12. While index is greater than or equal to 0:\n         */\n        index = currentTargetIndex - 1;\n        while (index >= 0) {\n            /**\n             * 12.1. If path[index]'s root-of-closed-tree is true, then increase\n             * currentHiddenLevel by 1.\n             * 12.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,\n             * then prepend path[index]'s invocation target to composedPath.\n             */\n            if (path[index].rootOfClosedTree) {\n                currentHiddenLevel++;\n            }\n            if (currentHiddenLevel <= maxHiddenLevel) {\n                composedPath.unshift(path[index].invocationTarget);\n            }\n            /**\n             * 12.3. If path[index]'s slot-in-closed-tree is true, then:\n             */\n            if (path[index].slotInClosedTree) {\n                /**\n                 * 12.3.1. Decrease currentHiddenLevel by 1.\n                 * 12.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set\n                 * maxHiddenLevel to currentHiddenLevel.\n                 */\n                currentHiddenLevel--;\n                if (currentHiddenLevel < maxHiddenLevel) {\n                    maxHiddenLevel = currentHiddenLevel;\n                }\n            }\n            /**\n             * 12.4. Decrease index by 1.\n             */\n            index--;\n        }\n        /**\n         * 13. Set currentHiddenLevel and maxHiddenLevel to\n         * currentTargetHiddenSubtreeLevel.\n         */\n        currentHiddenLevel = currentTargetHiddenSubtreeLevel;\n        maxHiddenLevel = currentTargetHiddenSubtreeLevel;\n        /**\n         * 14. Set index to currentTargetIndex + 1.\n         * 15. While index is less than path’s size:\n         */\n        index = currentTargetIndex + 1;\n        while (index < path.length) {\n            /**\n             * 15.1. If path[index]'s slot-in-closed-tree is true, then increase\n             * currentHiddenLevel by 1.\n             * 15.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,\n             * then append path[index]'s invocation target to composedPath.\n             */\n            if (path[index].slotInClosedTree) {\n                currentHiddenLevel++;\n            }\n            if (currentHiddenLevel <= maxHiddenLevel) {\n                composedPath.push(path[index].invocationTarget);\n            }\n            /**\n             * 15.3. If path[index]'s root-of-closed-tree is true, then:\n             */\n            if (path[index].rootOfClosedTree) {\n                /**\n                 * 15.3.1. Decrease currentHiddenLevel by 1.\n                 * 15.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set\n                 * maxHiddenLevel to currentHiddenLevel.\n                 */\n                currentHiddenLevel--;\n                if (currentHiddenLevel < maxHiddenLevel) {\n                    maxHiddenLevel = currentHiddenLevel;\n                }\n            }\n            /**\n             * 15.4. Increase index by 1.\n             */\n            index++;\n        }\n        /**\n         * 16. Return composedPath.\n         */\n        return composedPath;\n    };\n    Object.defineProperty(EventImpl.prototype, \"eventPhase\", {\n        /** @inheritdoc */\n        get: function () { return this._eventPhase; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    EventImpl.prototype.stopPropagation = function () { this._stopPropagationFlag = true; };\n    Object.defineProperty(EventImpl.prototype, \"cancelBubble\", {\n        /** @inheritdoc */\n        get: function () { return this._stopPropagationFlag; },\n        set: function (value) { if (value)\n            this.stopPropagation(); },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    EventImpl.prototype.stopImmediatePropagation = function () {\n        this._stopPropagationFlag = true;\n        this._stopImmediatePropagationFlag = true;\n    };\n    Object.defineProperty(EventImpl.prototype, \"bubbles\", {\n        /** @inheritdoc */\n        get: function () { return this._bubbles; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"cancelable\", {\n        /** @inheritdoc */\n        get: function () { return this._cancelable; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"returnValue\", {\n        /** @inheritdoc */\n        get: function () { return !this._canceledFlag; },\n        set: function (value) {\n            if (!value) {\n                algorithm_1.event_setTheCanceledFlag(this);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    EventImpl.prototype.preventDefault = function () {\n        algorithm_1.event_setTheCanceledFlag(this);\n    };\n    Object.defineProperty(EventImpl.prototype, \"defaultPrevented\", {\n        /** @inheritdoc */\n        get: function () { return this._canceledFlag; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"composed\", {\n        /** @inheritdoc */\n        get: function () { return this._composedFlag; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"isTrusted\", {\n        /** @inheritdoc */\n        get: function () { return this._isTrusted; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventImpl.prototype, \"timeStamp\", {\n        /** @inheritdoc */\n        get: function () { return this._timeStamp; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    EventImpl.prototype.initEvent = function (type, bubbles, cancelable) {\n        if (bubbles === void 0) { bubbles = false; }\n        if (cancelable === void 0) { cancelable = false; }\n        /**\n         * 1. If the context object’s dispatch flag is set, then return.\n         */\n        if (this._dispatchFlag)\n            return;\n        /**\n         * 2. Initialize the context object with type, bubbles, and cancelable.\n         */\n        algorithm_1.event_initialize(this, type, bubbles, cancelable);\n    };\n    EventImpl.NONE = 0;\n    EventImpl.CAPTURING_PHASE = 1;\n    EventImpl.AT_TARGET = 2;\n    EventImpl.BUBBLING_PHASE = 3;\n    return EventImpl;\n}());\nexports.EventImpl = EventImpl;\n/**\n * Define constants on prototype.\n */\nWebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, \"NONE\", 0);\nWebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, \"CAPTURING_PHASE\", 1);\nWebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, \"AT_TARGET\", 2);\nWebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, \"BUBBLING_PHASE\", 3);\n//# sourceMappingURL=EventImpl.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMException_1 = require(\"./DOMException\");\nvar util_1 = require(\"../util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a target to which an event can be dispatched.\n */\nvar EventTargetImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `EventTarget`.\n     */\n    function EventTargetImpl() {\n    }\n    Object.defineProperty(EventTargetImpl.prototype, \"_eventListenerList\", {\n        get: function () {\n            return this.__eventListenerList || (this.__eventListenerList = []);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EventTargetImpl.prototype, \"_eventHandlerMap\", {\n        get: function () {\n            return this.__eventHandlerMap || (this.__eventHandlerMap = {});\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    EventTargetImpl.prototype.addEventListener = function (type, callback, options) {\n        if (options === void 0) { options = { passive: false, once: false, capture: false }; }\n        /**\n         * 1. Let capture, passive, and once be the result of flattening more options.\n         */\n        var _a = __read(algorithm_1.eventTarget_flattenMore(options), 3), capture = _a[0], passive = _a[1], once = _a[2];\n        // convert callback function to EventListener, return if null\n        var listenerCallback;\n        if (!callback) {\n            return;\n        }\n        else if (util_1.Guard.isEventListener(callback)) {\n            listenerCallback = callback;\n        }\n        else {\n            listenerCallback = { handleEvent: callback };\n        }\n        /**\n         * 2. Add an event listener with the context object and an event listener\n         * whose type is type, callback is callback, capture is capture, passive is\n         * passive, and once is once.\n         */\n        algorithm_1.eventTarget_addEventListener(this, {\n            type: type,\n            callback: listenerCallback,\n            capture: capture,\n            passive: passive,\n            once: once,\n            removed: false\n        });\n    };\n    /** @inheritdoc */\n    EventTargetImpl.prototype.removeEventListener = function (type, callback, options) {\n        /**\n         * TODO: Implement realms\n         * 1. If the context object’s relevant global object is a\n         * ServiceWorkerGlobalScope object and its associated service worker’s\n         * script resource’s has ever been evaluated flag is set, then throw\n         * a TypeError. [SERVICE-WORKERS]\n         */\n        if (options === void 0) { options = { capture: false }; }\n        /**\n         * 2. Let capture be the result of flattening options.\n         */\n        var capture = algorithm_1.eventTarget_flatten(options);\n        if (!callback)\n            return;\n        /**\n         * 3. If the context object’s event listener list contains an event listener\n         * whose type is type, callback is callback, and capture is capture, then\n         * remove an event listener with the context object and that event listener.\n         */\n        for (var i = 0; i < this._eventListenerList.length; i++) {\n            var entry = this._eventListenerList[i];\n            if (entry.type !== type || entry.capture !== capture)\n                continue;\n            if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {\n                algorithm_1.eventTarget_removeEventListener(this, entry, i);\n                break;\n            }\n            else if (callback && entry.callback.handleEvent === callback) {\n                algorithm_1.eventTarget_removeEventListener(this, entry, i);\n                break;\n            }\n        }\n    };\n    /** @inheritdoc */\n    EventTargetImpl.prototype.dispatchEvent = function (event) {\n        /**\n         * 1. If event’s dispatch flag is set, or if its initialized flag is not\n         * set, then throw an \"InvalidStateError\" DOMException.\n         * 2. Initialize event’s isTrusted attribute to false.\n         * 3. Return the result of dispatching event to the context object.\n         */\n        if (event._dispatchFlag || !event._initializedFlag) {\n            throw new DOMException_1.InvalidStateError();\n        }\n        event._isTrusted = false;\n        return algorithm_1.event_dispatch(event, this);\n    };\n    /** @inheritdoc */\n    EventTargetImpl.prototype._getTheParent = function (event) {\n        return null;\n    };\n    return EventTargetImpl;\n}());\nexports.EventTargetImpl = EventTargetImpl;\n//# sourceMappingURL=EventTargetImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"../algorithm\");\nvar util_1 = require(\"../util\");\nvar util_2 = require(\"@oozcitak/util\");\n/**\n * Represents a collection of elements.\n */\nvar HTMLCollectionImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `HTMLCollection`.\n     *\n     * @param root - root node\n     * @param filter - node filter\n     */\n    function HTMLCollectionImpl(root, filter) {\n        this._live = true;\n        this._root = root;\n        this._filter = filter;\n        return new Proxy(this, this);\n    }\n    Object.defineProperty(HTMLCollectionImpl.prototype, \"length\", {\n        /** @inheritdoc */\n        get: function () {\n            var _this = this;\n            /**\n             * The length attribute’s getter must return the number of nodes\n             * represented by the collection.\n             */\n            var count = 0;\n            var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });\n            while (node !== null) {\n                count++;\n                node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });\n            }\n            return count;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    HTMLCollectionImpl.prototype.item = function (index) {\n        var _this = this;\n        /**\n         * The item(index) method, when invoked, must return the indexth element\n         * in the collection. If there is no indexth element in the collection,\n         * then the method must return null.\n         */\n        var i = 0;\n        var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });\n        while (node !== null) {\n            if (i === index)\n                return node;\n            else\n                i++;\n            node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });\n        }\n        return null;\n    };\n    /** @inheritdoc */\n    HTMLCollectionImpl.prototype.namedItem = function (key) {\n        var _this = this;\n        /**\n         * 1. If key is the empty string, return null.\n         * 2. Return the first element in the collection for which at least one of\n         * the following is true:\n         * - it has an ID which is key;\n         * - it is in the HTML namespace and has a name attribute whose value is key;\n         * or null if there is no such element.\n         */\n        if (key === '')\n            return null;\n        var ele = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });\n        while (ele != null) {\n            if (ele._uniqueIdentifier === key) {\n                return ele;\n            }\n            else if (ele._namespace === infra_1.namespace.HTML) {\n                for (var i = 0; i < ele._attributeList.length; i++) {\n                    var attr = ele._attributeList[i];\n                    if (attr._localName === \"name\" && attr._namespace === null &&\n                        attr._namespacePrefix === null && attr._value === key)\n                        return ele;\n                }\n            }\n            ele = algorithm_1.tree_getNextDescendantNode(this._root, ele, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });\n        }\n        return null;\n    };\n    /** @inheritdoc */\n    HTMLCollectionImpl.prototype[Symbol.iterator] = function () {\n        var root = this._root;\n        var filter = this._filter;\n        var currentNode = algorithm_1.tree_getFirstDescendantNode(root, false, false, function (e) { return util_1.Guard.isElementNode(e) && filter(e); });\n        return {\n            next: function () {\n                if (currentNode === null) {\n                    return { done: true, value: null };\n                }\n                else {\n                    var result = { done: false, value: currentNode };\n                    currentNode = algorithm_1.tree_getNextDescendantNode(root, currentNode, false, false, function (e) { return util_1.Guard.isElementNode(e) && filter(e); });\n                    return result;\n                }\n            }\n        };\n    };\n    /**\n     * Implements a proxy get trap to provide array-like access.\n     */\n    HTMLCollectionImpl.prototype.get = function (target, key, receiver) {\n        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {\n            return Reflect.get(target, key, receiver);\n        }\n        var index = Number(key);\n        if (isNaN(index)) {\n            return target.namedItem(key) || undefined;\n        }\n        else {\n            return target.item(index) || undefined;\n        }\n    };\n    /**\n     * Implements a proxy set trap to provide array-like access.\n     */\n    HTMLCollectionImpl.prototype.set = function (target, key, value, receiver) {\n        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {\n            return Reflect.set(target, key, value, receiver);\n        }\n        var index = Number(key);\n        var node = isNaN(index) ?\n            target.namedItem(key) || undefined : target.item(index) || undefined;\n        if (node && node._parent) {\n            algorithm_1.mutation_replace(node, value, node._parent);\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Creates a new `HTMLCollection`.\n     *\n     * @param root - root node\n     * @param filter - node filter\n     */\n    HTMLCollectionImpl._create = function (root, filter) {\n        if (filter === void 0) { filter = (function () { return true; }); }\n        return new HTMLCollectionImpl(root, filter);\n    };\n    HTMLCollectionImpl.reservedNames = ['_root', '_live', '_filter', 'length',\n        'item', 'namedItem', 'get', 'set'];\n    return HTMLCollectionImpl;\n}());\nexports.HTMLCollectionImpl = HTMLCollectionImpl;\n//# sourceMappingURL=HTMLCollectionImpl.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar util_1 = require(\"../util\");\nvar infra_1 = require(\"@oozcitak/infra\");\n/**\n * Represents an object that can be used to observe mutations to the tree of\n * nodes.\n */\nvar MutationObserverImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `MutationObserver`.\n     *\n     * @param callback - the callback function\n     */\n    function MutationObserverImpl(callback) {\n        this._nodeList = [];\n        this._recordQueue = [];\n        /**\n         * 1. Let mo be a new MutationObserver object whose callback is callback.\n         * 2. Append mo to mo’s relevant agent’s mutation observers.\n         * 3. Return mo.\n         */\n        this._callback = callback;\n        var window = DOMImpl_1.dom.window;\n        infra_1.set.append(window._mutationObservers, this);\n    }\n    /** @inheritdoc */\n    MutationObserverImpl.prototype.observe = function (target, options) {\n        var e_1, _a;\n        options = options || {\n            childList: false,\n            subtree: false\n        };\n        /**\n         * 1. If either options’s attributeOldValue or attributeFilter is present\n         * and options’s attributes is omitted, then set options’s attributes\n         * to true.\n         * 2. If options’s characterDataOldValue is present and options’s\n         * characterData is omitted, then set options’s characterData to true.\n         * 3. If none of options’s childList, attributes, and characterData is\n         * true, then throw a TypeError.\n         * 4. If options’s attributeOldValue is true and options’s attributes is\n         * false, then throw a TypeError.\n         * 5. If options’s attributeFilter is present and options’s attributes is\n         *  false, then throw a TypeError.\n         * 6. If options’s characterDataOldValue is true and options’s characterData\n         * is false, then throw a TypeError.\n         */\n        if ((options.attributeOldValue !== undefined || options.attributeFilter !== undefined) &&\n            options.attributes === undefined) {\n            options.attributes = true;\n        }\n        if (options.characterDataOldValue !== undefined && options.characterData === undefined) {\n            options.characterData = true;\n        }\n        if (!options.childList && !options.attributes && !options.characterData) {\n            throw new TypeError();\n        }\n        if (options.attributeOldValue && !options.attributes) {\n            throw new TypeError();\n        }\n        if (options.attributeFilter !== undefined && !options.attributes) {\n            throw new TypeError();\n        }\n        if (options.characterDataOldValue && !options.characterData) {\n            throw new TypeError();\n        }\n        /**\n         * 7. For each registered of target’s registered observer list, if\n         * registered’s observer is the context object:\n         */\n        var isRegistered = false;\n        var coptions = options;\n        var _loop_1 = function (registered) {\n            var e_2, _a;\n            if (registered.observer === this_1) {\n                isRegistered = true;\n                try {\n                    /**\n                     * 7.1. For each node of the context object’s node list, remove all\n                     * transient registered observers whose source is registered from node’s\n                     * registered observer list.\n                     */\n                    for (var _b = (e_2 = void 0, __values(this_1._nodeList)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var node = _c.value;\n                        infra_1.list.remove(node._registeredObserverList, function (ob) {\n                            return util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered;\n                        });\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                /**\n                 * 7.2. Set registered’s options to options.\n                 */\n                registered.options = coptions;\n            }\n        };\n        var this_1 = this;\n        try {\n            for (var _b = __values(target._registeredObserverList), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var registered = _c.value;\n                _loop_1(registered);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        /**\n         * 8. Otherwise:\n         * 8.1. Append a new registered observer whose observer is the context\n         * object and options is options to target’s registered observer list.\n         * 8.2. Append target to the context object’s node list.\n         */\n        if (!isRegistered) {\n            target._registeredObserverList.push({ observer: this, options: options });\n            this._nodeList.push(target);\n        }\n    };\n    /** @inheritdoc */\n    MutationObserverImpl.prototype.disconnect = function () {\n        var e_3, _a;\n        var _this = this;\n        try {\n            /**\n             * 1. For each node of the context object’s node list, remove any\n             * registered observer from node’s registered observer list for which the\n             * context object is the observer.\n             */\n            for (var _b = __values(this._nodeList), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var node = _c.value;\n                infra_1.list.remove((node)._registeredObserverList, function (ob) {\n                    return ob.observer === _this;\n                });\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        /**\n         * 2. Empty the context object’s record queue.\n         */\n        this._recordQueue = [];\n    };\n    /** @inheritdoc */\n    MutationObserverImpl.prototype.takeRecords = function () {\n        /**\n         * 1. Let records be a clone of the context object’s record queue.\n         * 2. Empty the context object’s record queue.\n         * 3. Return records.\n         */\n        var records = this._recordQueue;\n        this._recordQueue = [];\n        return records;\n    };\n    return MutationObserverImpl;\n}());\nexports.MutationObserverImpl = MutationObserverImpl;\n//# sourceMappingURL=MutationObserverImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a mutation record.\n */\nvar MutationRecordImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `MutationRecord`.\n     *\n     * @param type - type of mutation: `\"attributes\"` for an attribute\n     * mutation, `\"characterData\"` for a mutation to a CharacterData node\n     * and `\"childList\"` for a mutation to the tree of nodes.\n     * @param target - node affected by the mutation.\n     * @param addedNodes - list of added nodes.\n     * @param removedNodes - list of removed nodes.\n     * @param previousSibling - previous sibling of added or removed nodes.\n     * @param nextSibling - next sibling of added or removed nodes.\n     * @param attributeName - local name of the changed attribute,\n     * and `null` otherwise.\n     * @param attributeNamespace - namespace of the changed attribute,\n     * and `null` otherwise.\n     * @param oldValue - value before mutation: attribute value for an attribute\n     * mutation, node `data` for a mutation to a CharacterData node and `null`\n     * for a mutation to the tree of nodes.\n     */\n    function MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {\n        this._type = type;\n        this._target = target;\n        this._addedNodes = addedNodes;\n        this._removedNodes = removedNodes;\n        this._previousSibling = previousSibling;\n        this._nextSibling = nextSibling;\n        this._attributeName = attributeName;\n        this._attributeNamespace = attributeNamespace;\n        this._oldValue = oldValue;\n    }\n    Object.defineProperty(MutationRecordImpl.prototype, \"type\", {\n        /** @inheritdoc */\n        get: function () { return this._type; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"target\", {\n        /** @inheritdoc */\n        get: function () { return this._target; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"addedNodes\", {\n        /** @inheritdoc */\n        get: function () { return this._addedNodes; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"removedNodes\", {\n        /** @inheritdoc */\n        get: function () { return this._removedNodes; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"previousSibling\", {\n        /** @inheritdoc */\n        get: function () { return this._previousSibling; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"nextSibling\", {\n        /** @inheritdoc */\n        get: function () { return this._nextSibling; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"attributeName\", {\n        /** @inheritdoc */\n        get: function () { return this._attributeName; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"attributeNamespace\", {\n        /** @inheritdoc */\n        get: function () { return this._attributeNamespace; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutationRecordImpl.prototype, \"oldValue\", {\n        /** @inheritdoc */\n        get: function () { return this._oldValue; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new `MutationRecord`.\n     *\n     * @param type - type of mutation: `\"attributes\"` for an attribute\n     * mutation, `\"characterData\"` for a mutation to a CharacterData node\n     * and `\"childList\"` for a mutation to the tree of nodes.\n     * @param target - node affected by the mutation.\n     * @param addedNodes - list of added nodes.\n     * @param removedNodes - list of removed nodes.\n     * @param previousSibling - previous sibling of added or removed nodes.\n     * @param nextSibling - next sibling of added or removed nodes.\n     * @param attributeName - local name of the changed attribute,\n     * and `null` otherwise.\n     * @param attributeNamespace - namespace of the changed attribute,\n     * and `null` otherwise.\n     * @param oldValue - value before mutation: attribute value for an attribute\n     * mutation, node `data` for a mutation to a CharacterData node and `null`\n     * for a mutation to the tree of nodes.\n     */\n    MutationRecordImpl._create = function (type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {\n        return new MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);\n    };\n    return MutationRecordImpl;\n}());\nexports.MutationRecordImpl = MutationRecordImpl;\n//# sourceMappingURL=MutationRecordImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMException_1 = require(\"./DOMException\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a collection of attributes.\n */\nvar NamedNodeMapImpl = /** @class */ (function (_super) {\n    __extends(NamedNodeMapImpl, _super);\n    /**\n     * Initializes a new instance of `NamedNodeMap`.\n     *\n     * @param element - parent element\n     */\n    function NamedNodeMapImpl(element) {\n        var _this = _super.call(this) || this;\n        _this._element = element;\n        // TODO: This workaround is needed to extend Array in ES5\n        Object.setPrototypeOf(_this, NamedNodeMapImpl.prototype);\n        return _this;\n    }\n    NamedNodeMapImpl.prototype._asArray = function () { return this; };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.item = function (index) {\n        /**\n         * 1. If index is equal to or greater than context object’s attribute list’s\n         * size, then return null.\n         * 2. Otherwise, return context object’s attribute list[index].\n         *\n         */\n        return this[index] || null;\n    };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.getNamedItem = function (qualifiedName) {\n        /**\n         * The getNamedItem(qualifiedName) method, when invoked, must return the\n         * result of getting an attribute given qualifiedName and element.\n         */\n        return algorithm_1.element_getAnAttributeByName(qualifiedName, this._element);\n    };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.getNamedItemNS = function (namespace, localName) {\n        /**\n         * The getNamedItemNS(namespace, localName) method, when invoked, must\n         * return the result of getting an attribute given namespace, localName,\n         * and element.\n         */\n        return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace || '', localName, this._element);\n    };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.setNamedItem = function (attr) {\n        /**\n         * The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked,\n         * must return the result of setting an attribute given attr and element.\n         */\n        return algorithm_1.element_setAnAttribute(attr, this._element);\n    };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.setNamedItemNS = function (attr) {\n        return algorithm_1.element_setAnAttribute(attr, this._element);\n    };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.removeNamedItem = function (qualifiedName) {\n        /**\n         * 1. Let attr be the result of removing an attribute given qualifiedName\n         * and element.\n         * 2. If attr is null, then throw a \"NotFoundError\" DOMException.\n         * 3. Return attr.\n         */\n        var attr = algorithm_1.element_removeAnAttributeByName(qualifiedName, this._element);\n        if (attr === null)\n            throw new DOMException_1.NotFoundError();\n        return attr;\n    };\n    /** @inheritdoc */\n    NamedNodeMapImpl.prototype.removeNamedItemNS = function (namespace, localName) {\n        /**\n         * 1. Let attr be the result of removing an attribute given namespace,\n         * localName, and element.\n         * 2. If attr is null, then throw a \"NotFoundError\" DOMException.\n         * 3. Return attr.\n         */\n        var attr = algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace || '', localName, this._element);\n        if (attr === null)\n            throw new DOMException_1.NotFoundError();\n        return attr;\n    };\n    /**\n     * Creates a new `NamedNodeMap`.\n     *\n     * @param element - parent element\n     */\n    NamedNodeMapImpl._create = function (element) {\n        return new NamedNodeMapImpl(element);\n    };\n    return NamedNodeMapImpl;\n}(Array));\nexports.NamedNodeMapImpl = NamedNodeMapImpl;\n//# sourceMappingURL=NamedNodeMapImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a node filter.\n */\nvar NodeFilterImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `NodeFilter`.\n     */\n    function NodeFilterImpl() {\n    }\n    /**\n     * Callback function.\n     */\n    NodeFilterImpl.prototype.acceptNode = function (node) {\n        return interfaces_1.FilterResult.Accept;\n    };\n    /**\n     * Creates a new `NodeFilter`.\n     */\n    NodeFilterImpl._create = function () {\n        return new NodeFilterImpl();\n    };\n    NodeFilterImpl.FILTER_ACCEPT = 1;\n    NodeFilterImpl.FILTER_REJECT = 2;\n    NodeFilterImpl.FILTER_SKIP = 3;\n    NodeFilterImpl.SHOW_ALL = 0xffffffff;\n    NodeFilterImpl.SHOW_ELEMENT = 0x1;\n    NodeFilterImpl.SHOW_ATTRIBUTE = 0x2;\n    NodeFilterImpl.SHOW_TEXT = 0x4;\n    NodeFilterImpl.SHOW_CDATA_SECTION = 0x8;\n    NodeFilterImpl.SHOW_ENTITY_REFERENCE = 0x10;\n    NodeFilterImpl.SHOW_ENTITY = 0x20;\n    NodeFilterImpl.SHOW_PROCESSING_INSTRUCTION = 0x40;\n    NodeFilterImpl.SHOW_COMMENT = 0x80;\n    NodeFilterImpl.SHOW_DOCUMENT = 0x100;\n    NodeFilterImpl.SHOW_DOCUMENT_TYPE = 0x200;\n    NodeFilterImpl.SHOW_DOCUMENT_FRAGMENT = 0x400;\n    NodeFilterImpl.SHOW_NOTATION = 0x800;\n    return NodeFilterImpl;\n}());\nexports.NodeFilterImpl = NodeFilterImpl;\n/**\n * Define constants on prototype.\n */\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"FILTER_ACCEPT\", 1);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"FILTER_REJECT\", 2);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"FILTER_SKIP\", 3);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_ALL\", 0xffffffff);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_ELEMENT\", 0x1);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_ATTRIBUTE\", 0x2);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_TEXT\", 0x4);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_CDATA_SECTION\", 0x8);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_ENTITY_REFERENCE\", 0x10);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_ENTITY\", 0x20);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_PROCESSING_INSTRUCTION\", 0x40);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_COMMENT\", 0x80);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_DOCUMENT\", 0x100);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_DOCUMENT_TYPE\", 0x200);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_DOCUMENT_FRAGMENT\", 0x400);\nWebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, \"SHOW_NOTATION\", 0x800);\n//# sourceMappingURL=NodeFilterImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar interfaces_1 = require(\"./interfaces\");\nvar EventTargetImpl_1 = require(\"./EventTargetImpl\");\nvar util_1 = require(\"../util\");\nvar DOMException_1 = require(\"./DOMException\");\nvar algorithm_1 = require(\"../algorithm\");\nvar URLAlgorithm_1 = require(\"@oozcitak/url/lib/URLAlgorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a generic XML node.\n */\nvar NodeImpl = /** @class */ (function (_super) {\n    __extends(NodeImpl, _super);\n    /**\n     * Initializes a new instance of `Node`.\n     */\n    function NodeImpl() {\n        var _this = _super.call(this) || this;\n        _this._parent = null;\n        _this._firstChild = null;\n        _this._lastChild = null;\n        _this._previousSibling = null;\n        _this._nextSibling = null;\n        return _this;\n    }\n    Object.defineProperty(NodeImpl.prototype, \"_childNodes\", {\n        get: function () {\n            return this.__childNodes || (this.__childNodes = algorithm_1.create_nodeList(this));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"_nodeDocument\", {\n        get: function () { return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument; },\n        set: function (val) { this._nodeDocumentOverride = val; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"_registeredObserverList\", {\n        get: function () {\n            return this.__registeredObserverList || (this.__registeredObserverList = []);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"nodeType\", {\n        /** @inheritdoc */\n        get: function () { return this._nodeType; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"nodeName\", {\n        /**\n         * Returns a string appropriate for the type of node.\n         */\n        get: function () {\n            if (util_1.Guard.isElementNode(this)) {\n                return this._htmlUppercasedQualifiedName;\n            }\n            else if (util_1.Guard.isAttrNode(this)) {\n                return this._qualifiedName;\n            }\n            else if (util_1.Guard.isExclusiveTextNode(this)) {\n                return \"#text\";\n            }\n            else if (util_1.Guard.isCDATASectionNode(this)) {\n                return \"#cdata-section\";\n            }\n            else if (util_1.Guard.isProcessingInstructionNode(this)) {\n                return this._target;\n            }\n            else if (util_1.Guard.isCommentNode(this)) {\n                return \"#comment\";\n            }\n            else if (util_1.Guard.isDocumentNode(this)) {\n                return \"#document\";\n            }\n            else if (util_1.Guard.isDocumentTypeNode(this)) {\n                return this._name;\n            }\n            else if (util_1.Guard.isDocumentFragmentNode(this)) {\n                return \"#document-fragment\";\n            }\n            else {\n                return \"\";\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"baseURI\", {\n        /**\n         * Gets the absolute base URL of the node.\n         */\n        get: function () {\n            /**\n             * The baseURI attribute’s getter must return node document’s document\n             * base URL, serialized.\n             * TODO: Implement in HTML DOM\n             * https://html.spec.whatwg.org/multipage/urls-and-fetching.html#document-base-url\n             */\n            return URLAlgorithm_1.urlSerializer(this._nodeDocument._URL);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"isConnected\", {\n        /**\n         * Returns whether the node is rooted to a document node.\n         */\n        get: function () {\n            /**\n             * The isConnected attribute’s getter must return true, if context object\n             * is connected, and false otherwise.\n             */\n            return util_1.Guard.isElementNode(this) && algorithm_1.shadowTree_isConnected(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"ownerDocument\", {\n        /**\n         * Returns the parent document.\n         */\n        get: function () {\n            /**\n             * The ownerDocument attribute’s getter must return null, if the context\n             * object is a document, and the context object’s node document otherwise.\n             * _Note:_ The node document of a document is that document itself. All\n             * nodes have a node document at all times.\n             */\n            if (this._nodeType === interfaces_1.NodeType.Document)\n                return null;\n            else\n                return this._nodeDocument;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the root node.\n     *\n     * @param options - if options has `composed = true` this function\n     * returns the node's shadow-including root, otherwise it returns\n     * the node's root node.\n     */\n    NodeImpl.prototype.getRootNode = function (options) {\n        /**\n         * The getRootNode(options) method, when invoked, must return context\n         * object’s shadow-including root if options’s composed is true,\n         * and context object’s root otherwise.\n         */\n        return algorithm_1.tree_rootNode(this, !!options && options.composed);\n    };\n    Object.defineProperty(NodeImpl.prototype, \"parentNode\", {\n        /**\n         * Returns the parent node.\n         */\n        get: function () {\n            /**\n             * The parentNode attribute’s getter must return the context object’s parent.\n             * _Note:_ An Attr node has no parent.\n             */\n            if (this._nodeType === interfaces_1.NodeType.Attribute) {\n                return null;\n            }\n            else {\n                return this._parent;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"parentElement\", {\n        /**\n         * Returns the parent element.\n         */\n        get: function () {\n            /**\n             * The parentElement attribute’s getter must return the context object’s\n             * parent element.\n             */\n            if (this._parent && util_1.Guard.isElementNode(this._parent)) {\n                return this._parent;\n            }\n            else {\n                return null;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Determines whether a node has any children.\n     */\n    NodeImpl.prototype.hasChildNodes = function () {\n        /**\n         * The hasChildNodes() method, when invoked, must return true if the context\n         * object has children, and false otherwise.\n         */\n        return (this._firstChild !== null);\n    };\n    Object.defineProperty(NodeImpl.prototype, \"childNodes\", {\n        /**\n         * Returns a {@link NodeList} of child nodes.\n         */\n        get: function () {\n            /**\n             * The childNodes attribute’s getter must return a NodeList rooted at the\n             * context object matching only children.\n             */\n            return this._childNodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"firstChild\", {\n        /**\n         * Returns the first child node.\n         */\n        get: function () {\n            /**\n             * The firstChild attribute’s getter must return the context object’s first\n             * child.\n             */\n            return this._firstChild;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"lastChild\", {\n        /**\n         * Returns the last child node.\n         */\n        get: function () {\n            /**\n             * The lastChild attribute’s getter must return the context object’s last\n             * child.\n             */\n            return this._lastChild;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"previousSibling\", {\n        /**\n         * Returns the previous sibling node.\n         */\n        get: function () {\n            /**\n             * The previousSibling attribute’s getter must return the context object’s\n             * previous sibling.\n             * _Note:_ An Attr node has no siblings.\n             */\n            return this._previousSibling;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"nextSibling\", {\n        /**\n         * Returns the next sibling node.\n         */\n        get: function () {\n            /**\n             * The nextSibling attribute’s getter must return the context object’s\n             * next sibling.\n             */\n            return this._nextSibling;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"nodeValue\", {\n        /**\n         * Gets or sets the data associated with a {@link CharacterData} node or the\n         * value of an {@link @Attr} node. For other node types returns `null`.\n         */\n        get: function () {\n            if (util_1.Guard.isAttrNode(this)) {\n                return this._value;\n            }\n            else if (util_1.Guard.isCharacterDataNode(this)) {\n                return this._data;\n            }\n            else {\n                return null;\n            }\n        },\n        set: function (value) {\n            if (value === null) {\n                value = '';\n            }\n            if (util_1.Guard.isAttrNode(this)) {\n                algorithm_1.attr_setAnExistingAttributeValue(this, value);\n            }\n            else if (util_1.Guard.isCharacterDataNode(this)) {\n                algorithm_1.characterData_replaceData(this, 0, this._data.length, value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeImpl.prototype, \"textContent\", {\n        /**\n         * Returns the concatenation of data of all the {@link Text}\n         * node descendants in tree order. When set, replaces the text\n         * contents of the node with the given value.\n         */\n        get: function () {\n            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {\n                return algorithm_1.text_descendantTextContent(this);\n            }\n            else if (util_1.Guard.isAttrNode(this)) {\n                return this._value;\n            }\n            else if (util_1.Guard.isCharacterDataNode(this)) {\n                return this._data;\n            }\n            else {\n                return null;\n            }\n        },\n        set: function (value) {\n            if (value === null) {\n                value = '';\n            }\n            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {\n                algorithm_1.node_stringReplaceAll(value, this);\n            }\n            else if (util_1.Guard.isAttrNode(this)) {\n                algorithm_1.attr_setAnExistingAttributeValue(this, value);\n            }\n            else if (util_1.Guard.isCharacterDataNode(this)) {\n                algorithm_1.characterData_replaceData(this, 0, algorithm_1.tree_nodeLength(this), value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Puts all {@link Text} nodes in the full depth of the sub-tree\n     * underneath this node into a \"normal\" form where only markup\n     * (e.g., tags, comments, processing instructions, CDATA sections,\n     * and entity references) separates {@link Text} nodes, i.e., there\n     * are no adjacent Text nodes.\n     */\n    NodeImpl.prototype.normalize = function () {\n        var e_1, _a, e_2, _b;\n        /**\n         * The normalize() method, when invoked, must run these steps for each\n         * descendant exclusive Text node node of context object:\n         */\n        var descendantNodes = [];\n        var node = algorithm_1.tree_getFirstDescendantNode(this, false, false, function (e) { return util_1.Guard.isExclusiveTextNode(e); });\n        while (node !== null) {\n            descendantNodes.push(node);\n            node = algorithm_1.tree_getNextDescendantNode(this, node, false, false, function (e) { return util_1.Guard.isExclusiveTextNode(e); });\n        }\n        for (var i = 0; i < descendantNodes.length; i++) {\n            var node_1 = descendantNodes[i];\n            if (node_1._parent === null)\n                continue;\n            /**\n             * 1. Let length be node’s length.\n             * 2. If length is zero, then remove node and continue with the next\n             * exclusive Text node, if any.\n             */\n            var length = algorithm_1.tree_nodeLength(node_1);\n            if (length === 0) {\n                algorithm_1.mutation_remove(node_1, node_1._parent);\n                continue;\n            }\n            /**\n             * 3. Let data be the concatenation of the data of node’s contiguous\n             * exclusive Text nodes (excluding itself), in tree order.\n             */\n            var textSiblings = [];\n            var data = '';\n            try {\n                for (var _c = (e_1 = void 0, __values(algorithm_1.text_contiguousExclusiveTextNodes(node_1))), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var sibling = _d.value;\n                    textSiblings.push(sibling);\n                    data += sibling._data;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            /**\n             * 4. Replace data with node node, offset length, count 0, and data data.\n             */\n            algorithm_1.characterData_replaceData(node_1, length, 0, data);\n            /**\n             * 5. Let currentNode be node’s next sibling.\n             * 6. While currentNode is an exclusive Text node:\n             */\n            if (DOMImpl_1.dom.rangeList.size !== 0) {\n                var currentNode = node_1._nextSibling;\n                while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {\n                    /**\n                     * 6.1. For each live range whose start node is currentNode, add length\n                     * to its start offset and set its start node to node.\n                     * 6.2. For each live range whose end node is currentNode, add length to\n                     * its end offset and set its end node to node.\n                     * 6.3. For each live range whose start node is currentNode’s parent and\n                     * start offset is currentNode’s index, set its start node to node and\n                     * its start offset to length.\n                     * 6.4. For each live range whose end node is currentNode’s parent and\n                     * end offset is currentNode’s index, set its end node to node and its\n                     * end offset to length.\n                     */\n                    var cn = currentNode;\n                    var index = algorithm_1.tree_index(cn);\n                    try {\n                        for (var _e = (e_2 = void 0, __values(DOMImpl_1.dom.rangeList)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var range = _f.value;\n                            if (range._start[0] === cn) {\n                                range._start[0] = node_1;\n                                range._start[1] += length;\n                            }\n                            if (range._end[0] === cn) {\n                                range._end[0] = node_1;\n                                range._end[1] += length;\n                            }\n                            if (range._start[0] === cn._parent && range._start[1] === index) {\n                                range._start[0] = node_1;\n                                range._start[1] = length;\n                            }\n                            if (range._end[0] === cn._parent && range._end[1] === index) {\n                                range._end[0] = node_1;\n                                range._end[1] = length;\n                            }\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    /**\n                     * 6.5. Add currentNode’s length to length.\n                     * 6.6. Set currentNode to its next sibling.\n                     */\n                    length += algorithm_1.tree_nodeLength(currentNode);\n                    currentNode = currentNode._nextSibling;\n                }\n            }\n            /**\n             * 7. Remove node’s contiguous exclusive Text nodes (excluding itself),\n             * in tree order.\n             */\n            for (var i_1 = 0; i_1 < textSiblings.length; i_1++) {\n                var sibling = textSiblings[i_1];\n                if (sibling._parent === null)\n                    continue;\n                algorithm_1.mutation_remove(sibling, sibling._parent);\n            }\n        }\n    };\n    /**\n     * Returns a duplicate of this node, i.e., serves as a generic copy\n     * constructor for nodes. The duplicate node has no parent\n     * ({@link parentNode} returns `null`).\n     *\n     * @param deep - if `true`, recursively clone the subtree under the\n     * specified node. If `false`, clone only the node itself (and its\n     * attributes, if it is an {@link Element}).\n     */\n    NodeImpl.prototype.cloneNode = function (deep) {\n        if (deep === void 0) { deep = false; }\n        /**\n         * 1. If context object is a shadow root, then throw a \"NotSupportedError\"\n         * DOMException.\n         * 2. Return a clone of the context object, with the clone children flag set\n         * if deep is true.\n         */\n        if (util_1.Guard.isShadowRoot(this))\n            throw new DOMException_1.NotSupportedError();\n        return algorithm_1.node_clone(this, null, deep);\n    };\n    /**\n     * Determines if the given node is equal to this one.\n     *\n     * @param node - the node to compare with\n     */\n    NodeImpl.prototype.isEqualNode = function (node) {\n        if (node === void 0) { node = null; }\n        /**\n         * The isEqualNode(otherNode) method, when invoked, must return true if\n         * otherNode is non-null and context object equals otherNode, and false\n         * otherwise.\n         */\n        return (node !== null && algorithm_1.node_equals(this, node));\n    };\n    /**\n     * Determines if the given node is reference equal to this one.\n     *\n     * @param node - the node to compare with\n     */\n    NodeImpl.prototype.isSameNode = function (node) {\n        if (node === void 0) { node = null; }\n        /**\n         * The isSameNode(otherNode) method, when invoked, must return true if\n         * otherNode is context object, and false otherwise.\n         */\n        return (this === node);\n    };\n    /**\n     * Returns a bitmask indicating the position of the given `node`\n     * relative to this node.\n     */\n    NodeImpl.prototype.compareDocumentPosition = function (other) {\n        /**\n         * 1. If context object is other, then return zero.\n         * 2. Let node1 be other and node2 be context object.\n         * 3. Let attr1 and attr2 be null.\n         * attr1’s element.\n         */\n        if (other === this)\n            return 0;\n        var node1 = other;\n        var node2 = this;\n        var attr1 = null;\n        var attr2 = null;\n        /**\n         * 4. If node1 is an attribute, then set attr1 to node1 and node1 to\n         * attr1’s element.\n         */\n        if (util_1.Guard.isAttrNode(node1)) {\n            attr1 = node1;\n            node1 = attr1._element;\n        }\n        /**\n         * 5. If node2 is an attribute, then:\n         */\n        if (util_1.Guard.isAttrNode(node2)) {\n            /**\n             * 5.1. Set attr2 to node2 and node2 to attr2’s element.\n             */\n            attr2 = node2;\n            node2 = attr2._element;\n            /**\n             * 5.2. If attr1 and node1 are non-null, and node2 is node1, then:\n             */\n            if (attr1 && node1 && (node1 === node2)) {\n                /**\n                 * 5.2. For each attr in node2’s attribute list:\n                 */\n                for (var i = 0; i < node2._attributeList.length; i++) {\n                    var attr = node2._attributeList[i];\n                    /**\n                     * 5.2.1. If attr equals attr1, then return the result of adding\n                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and\n                     * DOCUMENT_POSITION_PRECEDING.\n                     * 5.2.2. If attr equals attr2, then return the result of adding\n                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and\n                     * DOCUMENT_POSITION_FOLLOWING.\n                     */\n                    if (algorithm_1.node_equals(attr, attr1)) {\n                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;\n                    }\n                    else if (algorithm_1.node_equals(attr, attr2)) {\n                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;\n                    }\n                }\n            }\n        }\n        /**\n         * 6. If node1 or node2 is null, or node1’s root is not node2’s root, then\n         * return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n         * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either\n         * DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,\n         * with the constraint that this is to be consistent, together.\n         */\n        if (node1 === null || node2 === null ||\n            algorithm_1.tree_rootNode(node1) !== algorithm_1.tree_rootNode(node2)) {\n            // nodes are disconnected\n            // return a random result but cache the value for consistency\n            return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific |\n                (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);\n        }\n        /**\n         * 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2\n         * and attr2 is non-null, then return the result of adding\n         * DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.\n         */\n        if ((!attr1 && algorithm_1.tree_isAncestorOf(node2, node1)) ||\n            (attr2 && (node1 === node2))) {\n            return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;\n        }\n        /**\n         * 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2\n         * and attr1 is non-null, then return the result of adding\n         * DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.\n         */\n        if ((!attr2 && algorithm_1.tree_isDescendantOf(node2, node1)) ||\n            (attr1 && (node1 === node2))) {\n            return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;\n        }\n        /**\n         * 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.\n         */\n        if (algorithm_1.tree_isPreceding(node2, node1))\n            return interfaces_1.Position.Preceding;\n        /**\n         * 10. Return DOCUMENT_POSITION_FOLLOWING.\n         */\n        return interfaces_1.Position.Following;\n    };\n    /**\n     * Returns `true` if given node is an inclusive descendant of this\n     * node, and `false` otherwise (including when other node is `null`).\n     *\n     * @param other - the node to check\n     */\n    NodeImpl.prototype.contains = function (other) {\n        /**\n         * The contains(other) method, when invoked, must return true if other is an\n         * inclusive descendant of context object, and false otherwise (including\n         * when other is null).\n         */\n        if (other === null)\n            return false;\n        return algorithm_1.tree_isDescendantOf(this, other, true);\n    };\n    /**\n     * Returns the prefix for a given namespace URI, if present, and\n     * `null` if not.\n     *\n     * @param namespace - the namespace to search\n     */\n    NodeImpl.prototype.lookupPrefix = function (namespace) {\n        /**\n         * 1. If namespace is null or the empty string, then return null.\n         * 2. Switch on the context object:\n         */\n        if (!namespace)\n            return null;\n        if (util_1.Guard.isElementNode(this)) {\n            /**\n             * Return the result of locating a namespace prefix for it using\n             * namespace.\n             */\n            return algorithm_1.node_locateANamespacePrefix(this, namespace);\n        }\n        else if (util_1.Guard.isDocumentNode(this)) {\n            /**\n             * Return the result of locating a namespace prefix for its document\n             * element, if its document element is non-null, and null otherwise.\n             */\n            if (this.documentElement === null) {\n                return null;\n            }\n            else {\n                return algorithm_1.node_locateANamespacePrefix(this.documentElement, namespace);\n            }\n        }\n        else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {\n            return null;\n        }\n        else if (util_1.Guard.isAttrNode(this)) {\n            /**\n             * Return the result of locating a namespace prefix for its element,\n             * if its element is non-null, and null otherwise.\n             */\n            if (this._element === null) {\n                return null;\n            }\n            else {\n                return algorithm_1.node_locateANamespacePrefix(this._element, namespace);\n            }\n        }\n        else {\n            /**\n             * Return the result of locating a namespace prefix for its parent\n             * element, if its parent element is non-null, and null otherwise.\n             */\n            if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {\n                return algorithm_1.node_locateANamespacePrefix(this._parent, namespace);\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    /**\n     * Returns the namespace URI for a given prefix if present, and `null`\n     * if not.\n     *\n     * @param prefix - the prefix to search\n     */\n    NodeImpl.prototype.lookupNamespaceURI = function (prefix) {\n        /**\n         * 1. If prefix is the empty string, then set it to null.\n         * 2. Return the result of running locate a namespace for the context object\n         * using prefix.\n         */\n        return algorithm_1.node_locateANamespace(this, prefix || null);\n    };\n    /**\n     * Returns `true` if the namespace is the default namespace on this\n     * node or `false` if not.\n     *\n     * @param namespace - the namespace to check\n     */\n    NodeImpl.prototype.isDefaultNamespace = function (namespace) {\n        /**\n         * 1. If namespace is the empty string, then set it to null.\n         * 2. Let defaultNamespace be the result of running locate a namespace for\n         * context object using null.\n         * 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\n         */\n        if (!namespace)\n            namespace = null;\n        var defaultNamespace = algorithm_1.node_locateANamespace(this, null);\n        return (defaultNamespace === namespace);\n    };\n    /**\n     * Inserts the node `newChild` before the existing child node\n     * `refChild`. If `refChild` is `null`, inserts `newChild` at the end\n     * of the list of children.\n     *\n     * If `newChild` is a {@link DocumentFragment} object, all of its\n     * children are inserted, in the same order, before `refChild`.\n     *\n     * If `newChild` is already in the tree, it is first removed.\n     *\n     * @param newChild - the node to insert\n     * @param refChild - the node before which the new node must be\n     *   inserted\n     *\n     * @returns the newly inserted child node\n     */\n    NodeImpl.prototype.insertBefore = function (newChild, refChild) {\n        /**\n         * The insertBefore(node, child) method, when invoked, must return the\n         * result of pre-inserting node into context object before child.\n         */\n        return algorithm_1.mutation_preInsert(newChild, this, refChild);\n    };\n    /**\n     * Adds the node `newChild` to the end of the list of children of this\n     * node, and returns it. If `newChild` is already in the tree, it is\n     * first removed.\n     *\n     * If `newChild` is a {@link DocumentFragment} object, the entire\n     * contents of the document fragment are moved into the child list of\n     * this node.\n     *\n     * @param newChild - the node to add\n     *\n     * @returns the newly inserted child node\n     */\n    NodeImpl.prototype.appendChild = function (newChild) {\n        /**\n         * The appendChild(node) method, when invoked, must return the result of\n         * appending node to context object.\n         */\n        return algorithm_1.mutation_append(newChild, this);\n    };\n    /**\n     * Replaces the child node `oldChild` with `newChild` in the list of\n     * children, and returns the `oldChild` node. If `newChild` is already\n     * in the tree, it is first removed.\n     *\n     * @param newChild - the new node to put in the child list\n     * @param oldChild - the node being replaced in the list\n     *\n     * @returns the removed child node\n     */\n    NodeImpl.prototype.replaceChild = function (newChild, oldChild) {\n        /**\n         * The replaceChild(node, child) method, when invoked, must return the\n         * result of replacing child with node within context object.\n         */\n        return algorithm_1.mutation_replace(oldChild, newChild, this);\n    };\n    /**\n    * Removes the child node indicated by `oldChild` from the list of\n    * children, and returns it.\n    *\n    * @param oldChild - the node being removed from the list\n    *\n    * @returns the removed child node\n    */\n    NodeImpl.prototype.removeChild = function (oldChild) {\n        /**\n         * The removeChild(child) method, when invoked, must return the result of\n         * pre-removing child from context object.\n         */\n        return algorithm_1.mutation_preRemove(oldChild, this);\n    };\n    /**\n     * Gets the parent event target for the given event.\n     *\n     * @param event - an event\n     */\n    NodeImpl.prototype._getTheParent = function (event) {\n        /**\n         * A node’s get the parent algorithm, given an event, returns the node’s\n         * assigned slot, if node is assigned, and node’s parent otherwise.\n         */\n        if (util_1.Guard.isSlotable(this) && algorithm_1.shadowTree_isAssigned(this)) {\n            return this._assignedSlot;\n        }\n        else {\n            return this._parent;\n        }\n    };\n    NodeImpl.ELEMENT_NODE = 1;\n    NodeImpl.ATTRIBUTE_NODE = 2;\n    NodeImpl.TEXT_NODE = 3;\n    NodeImpl.CDATA_SECTION_NODE = 4;\n    NodeImpl.ENTITY_REFERENCE_NODE = 5;\n    NodeImpl.ENTITY_NODE = 6;\n    NodeImpl.PROCESSING_INSTRUCTION_NODE = 7;\n    NodeImpl.COMMENT_NODE = 8;\n    NodeImpl.DOCUMENT_NODE = 9;\n    NodeImpl.DOCUMENT_TYPE_NODE = 10;\n    NodeImpl.DOCUMENT_FRAGMENT_NODE = 11;\n    NodeImpl.NOTATION_NODE = 12;\n    NodeImpl.DOCUMENT_POSITION_DISCONNECTED = 0x01;\n    NodeImpl.DOCUMENT_POSITION_PRECEDING = 0x02;\n    NodeImpl.DOCUMENT_POSITION_FOLLOWING = 0x04;\n    NodeImpl.DOCUMENT_POSITION_CONTAINS = 0x08;\n    NodeImpl.DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n    NodeImpl.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\n    return NodeImpl;\n}(EventTargetImpl_1.EventTargetImpl));\nexports.NodeImpl = NodeImpl;\n/**\n * A performance tweak to share an empty set between all node classes. This will\n * be overwritten by element, document and document fragment nodes to supply an\n * actual set of nodes.\n */\nNodeImpl.prototype._children = new util_1.EmptySet();\n/**\n * Define constants on prototype.\n */\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"ELEMENT_NODE\", 1);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"ATTRIBUTE_NODE\", 2);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"TEXT_NODE\", 3);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"CDATA_SECTION_NODE\", 4);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"ENTITY_REFERENCE_NODE\", 5);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"ENTITY_NODE\", 6);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"PROCESSING_INSTRUCTION_NODE\", 7);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"COMMENT_NODE\", 8);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_NODE\", 9);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_TYPE_NODE\", 10);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_FRAGMENT_NODE\", 11);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"NOTATION_NODE\", 12);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_POSITION_DISCONNECTED\", 0x01);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_POSITION_PRECEDING\", 0x02);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_POSITION_FOLLOWING\", 0x04);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_POSITION_CONTAINS\", 0x08);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_POSITION_CONTAINED_BY\", 0x10);\nWebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\", 0x20);\n//# sourceMappingURL=NodeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TraverserImpl_1 = require(\"./TraverserImpl\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents an object which can be used to iterate through the nodes\n * of a subtree.\n */\nvar NodeIteratorImpl = /** @class */ (function (_super) {\n    __extends(NodeIteratorImpl, _super);\n    /**\n     * Initializes a new instance of `NodeIterator`.\n     */\n    function NodeIteratorImpl(root, reference, pointerBeforeReference) {\n        var _this = _super.call(this, root) || this;\n        _this._iteratorCollection = undefined;\n        _this._reference = reference;\n        _this._pointerBeforeReference = pointerBeforeReference;\n        algorithm_1.nodeIterator_iteratorList().add(_this);\n        return _this;\n    }\n    Object.defineProperty(NodeIteratorImpl.prototype, \"referenceNode\", {\n        /** @inheritdoc */\n        get: function () { return this._reference; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeIteratorImpl.prototype, \"pointerBeforeReferenceNode\", {\n        /** @inheritdoc */\n        get: function () { return this._pointerBeforeReference; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    NodeIteratorImpl.prototype.nextNode = function () {\n        /**\n         * The nextNode() method, when invoked, must return the result of\n         * traversing with the context object and next.\n         */\n        return algorithm_1.nodeIterator_traverse(this, true);\n    };\n    /** @inheritdoc */\n    NodeIteratorImpl.prototype.previousNode = function () {\n        /**\n         * The previousNode() method, when invoked, must return the result of\n         * traversing with the context object and previous.\n         */\n        return algorithm_1.nodeIterator_traverse(this, false);\n    };\n    /** @inheritdoc */\n    NodeIteratorImpl.prototype.detach = function () {\n        /**\n         * The detach() method, when invoked, must do nothing.\n         *\n         * since JS lacks weak references, we still use detach\n         */\n        algorithm_1.nodeIterator_iteratorList().delete(this);\n    };\n    /**\n     * Creates a new `NodeIterator`.\n     *\n     * @param root - iterator's root node\n     * @param reference - reference node\n     * @param pointerBeforeReference - whether the iterator is before or after the\n     * reference node\n     */\n    NodeIteratorImpl._create = function (root, reference, pointerBeforeReference) {\n        return new NodeIteratorImpl(root, reference, pointerBeforeReference);\n    };\n    return NodeIteratorImpl;\n}(TraverserImpl_1.TraverserImpl));\nexports.NodeIteratorImpl = NodeIteratorImpl;\n//# sourceMappingURL=NodeIteratorImpl.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar util_1 = require(\"@oozcitak/util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents an ordered set of nodes.\n */\nvar NodeListImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `NodeList`.\n     *\n     * @param root - root node\n     */\n    function NodeListImpl(root) {\n        this._live = true;\n        this._filter = null;\n        this._length = 0;\n        this._root = root;\n        return new Proxy(this, this);\n    }\n    Object.defineProperty(NodeListImpl.prototype, \"length\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The length attribute must return the number of nodes represented\n             * by the collection.\n             */\n            return this._root._children.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    NodeListImpl.prototype.item = function (index) {\n        /**\n         * The item(index) method must return the indexth node in the collection.\n         * If there is no indexth node in the collection, then the method must\n         * return null.\n         */\n        if (index < 0 || index > this.length - 1)\n            return null;\n        if (index < this.length / 2) {\n            var i = 0;\n            var node = this._root._firstChild;\n            while (node !== null && i !== index) {\n                node = node._nextSibling;\n                i++;\n            }\n            return node;\n        }\n        else {\n            var i = this.length - 1;\n            var node = this._root._lastChild;\n            while (node !== null && i !== index) {\n                node = node._previousSibling;\n                i--;\n            }\n            return node;\n        }\n    };\n    /** @inheritdoc */\n    NodeListImpl.prototype.keys = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                var index = 0;\n                return {\n                    next: function () {\n                        if (index === this.length) {\n                            return { done: true, value: null };\n                        }\n                        else {\n                            return { done: false, value: index++ };\n                        }\n                    }.bind(this)\n                };\n            }.bind(this),\n            _a;\n    };\n    /** @inheritdoc */\n    NodeListImpl.prototype.values = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                var it = this[Symbol.iterator]();\n                return {\n                    next: function () {\n                        return it.next();\n                    }\n                };\n            }.bind(this),\n            _a;\n    };\n    /** @inheritdoc */\n    NodeListImpl.prototype.entries = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                var it = this[Symbol.iterator]();\n                var index = 0;\n                return {\n                    next: function () {\n                        var itResult = it.next();\n                        if (itResult.done) {\n                            return { done: true, value: null };\n                        }\n                        else {\n                            return { done: false, value: [index++, itResult.value] };\n                        }\n                    }\n                };\n            }.bind(this),\n            _a;\n    };\n    /** @inheritdoc */\n    NodeListImpl.prototype[Symbol.iterator] = function () {\n        return this._root._children[Symbol.iterator]();\n    };\n    /** @inheritdoc */\n    NodeListImpl.prototype.forEach = function (callback, thisArg) {\n        var e_1, _a;\n        if (thisArg === undefined) {\n            thisArg = DOMImpl_1.dom.window;\n        }\n        var index = 0;\n        try {\n            for (var _b = __values(this._root._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var node = _c.value;\n                callback.call(thisArg, node, index++, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Implements a proxy get trap to provide array-like access.\n     */\n    NodeListImpl.prototype.get = function (target, key, receiver) {\n        if (!util_1.isString(key)) {\n            return Reflect.get(target, key, receiver);\n        }\n        var index = Number(key);\n        if (isNaN(index)) {\n            return Reflect.get(target, key, receiver);\n        }\n        return target.item(index) || undefined;\n    };\n    /**\n     * Implements a proxy set trap to provide array-like access.\n     */\n    NodeListImpl.prototype.set = function (target, key, value, receiver) {\n        if (!util_1.isString(key)) {\n            return Reflect.set(target, key, value, receiver);\n        }\n        var index = Number(key);\n        if (isNaN(index)) {\n            return Reflect.set(target, key, value, receiver);\n        }\n        var node = target.item(index) || undefined;\n        if (!node)\n            return false;\n        if (node._parent) {\n            algorithm_1.mutation_replace(node, value, node._parent);\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Creates a new `NodeList`.\n     *\n     * @param root - root node\n     */\n    NodeListImpl._create = function (root) {\n        return new NodeListImpl(root);\n    };\n    return NodeListImpl;\n}());\nexports.NodeListImpl = NodeListImpl;\n//# sourceMappingURL=NodeListImpl.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Represents an ordered list of nodes.\n * This is a static implementation of `NodeList`.\n */\nvar NodeListStaticImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `NodeList`.\n     *\n     * @param root - root node\n     */\n    function NodeListStaticImpl(root) {\n        this._live = false;\n        this._items = [];\n        this._length = 0;\n        this._root = root;\n        this._items = [];\n        this._filter = function (node) { return true; };\n        return new Proxy(this, this);\n    }\n    Object.defineProperty(NodeListStaticImpl.prototype, \"length\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The length attribute must return the number of nodes represented by\n             * the collection.\n             */\n            return this._items.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    NodeListStaticImpl.prototype.item = function (index) {\n        /**\n         * The item(index) method must return the indexth node in the collection.\n         * If there is no indexth node in the collection, then the method must\n         * return null.\n         */\n        if (index < 0 || index > this.length - 1)\n            return null;\n        return this._items[index];\n    };\n    /** @inheritdoc */\n    NodeListStaticImpl.prototype.keys = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                var index = 0;\n                return {\n                    next: function () {\n                        if (index === this.length) {\n                            return { done: true, value: null };\n                        }\n                        else {\n                            return { done: false, value: index++ };\n                        }\n                    }.bind(this)\n                };\n            }.bind(this),\n            _a;\n    };\n    /** @inheritdoc */\n    NodeListStaticImpl.prototype.values = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                var it = this[Symbol.iterator]();\n                return {\n                    next: function () {\n                        return it.next();\n                    }\n                };\n            }.bind(this),\n            _a;\n    };\n    /** @inheritdoc */\n    NodeListStaticImpl.prototype.entries = function () {\n        var _a;\n        return _a = {},\n            _a[Symbol.iterator] = function () {\n                var it = this[Symbol.iterator]();\n                var index = 0;\n                return {\n                    next: function () {\n                        var itResult = it.next();\n                        if (itResult.done) {\n                            return { done: true, value: null };\n                        }\n                        else {\n                            return { done: false, value: [index++, itResult.value] };\n                        }\n                    }\n                };\n            }.bind(this),\n            _a;\n    };\n    /** @inheritdoc */\n    NodeListStaticImpl.prototype[Symbol.iterator] = function () {\n        var it = this._items[Symbol.iterator]();\n        return {\n            next: function () {\n                return it.next();\n            }\n        };\n    };\n    /** @inheritdoc */\n    NodeListStaticImpl.prototype.forEach = function (callback, thisArg) {\n        var e_1, _a;\n        if (thisArg === undefined) {\n            thisArg = DOMImpl_1.dom.window;\n        }\n        var index = 0;\n        try {\n            for (var _b = __values(this._items), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var node = _c.value;\n                callback.call(thisArg, node, index++, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Implements a proxy get trap to provide array-like access.\n     */\n    NodeListStaticImpl.prototype.get = function (target, key, receiver) {\n        if (!util_1.isString(key)) {\n            return Reflect.get(target, key, receiver);\n        }\n        var index = Number(key);\n        if (isNaN(index)) {\n            return Reflect.get(target, key, receiver);\n        }\n        return target._items[index] || undefined;\n    };\n    /**\n     * Implements a proxy set trap to provide array-like access.\n     */\n    NodeListStaticImpl.prototype.set = function (target, key, value, receiver) {\n        if (!util_1.isString(key)) {\n            return Reflect.set(target, key, value, receiver);\n        }\n        var index = Number(key);\n        if (isNaN(index)) {\n            return Reflect.set(target, key, value, receiver);\n        }\n        if (index >= 0 && index < target._items.length) {\n            target._items[index] = value;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Creates a new `NodeList`.\n     *\n     * @param root - root node\n     * @param items - a list of items to initialize the list\n     */\n    NodeListStaticImpl._create = function (root, items) {\n        var list = new NodeListStaticImpl(root);\n        list._items = items;\n        return list;\n    };\n    return NodeListStaticImpl;\n}());\nexports.NodeListStaticImpl = NodeListStaticImpl;\n//# sourceMappingURL=NodeListStaticImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\n/**\n * Represents a mixin that extends child nodes that can have siblings\n * other than doctypes. This mixin is implemented by {@link Element} and\n * {@link CharacterData}.\n */\nvar NonDocumentTypeChildNodeImpl = /** @class */ (function () {\n    function NonDocumentTypeChildNodeImpl() {\n    }\n    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, \"previousElementSibling\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The previousElementSibling attribute’s getter must return the first\n             * preceding sibling that is an element, and null otherwise.\n             */\n            var node = util_1.Cast.asNode(this)._previousSibling;\n            while (node) {\n                if (util_1.Guard.isElementNode(node))\n                    return node;\n                else\n                    node = node._previousSibling;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, \"nextElementSibling\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The nextElementSibling attribute’s getter must return the first\n             * following sibling that is an element, and null otherwise.\n             */\n            var node = util_1.Cast.asNode(this)._nextSibling;\n            while (node) {\n                if (util_1.Guard.isElementNode(node))\n                    return node;\n                else\n                    node = node._nextSibling;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return NonDocumentTypeChildNodeImpl;\n}());\nexports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl;\n//# sourceMappingURL=NonDocumentTypeChildNodeImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a mixin that extends non-element parent nodes. This mixin\n * is implemented by {@link Document} and {@link DocumentFragment}.\n */\nvar NonElementParentNodeImpl = /** @class */ (function () {\n    function NonElementParentNodeImpl() {\n    }\n    /** @inheritdoc */\n    NonElementParentNodeImpl.prototype.getElementById = function (id) {\n        /**\n         * The getElementById(elementId) method, when invoked, must return the first\n         * element, in tree order, within the context object’s descendants,\n         * whose ID is elementId, and null if there is no such element otherwise.\n         */\n        var ele = algorithm_1.tree_getFirstDescendantNode(util_1.Cast.asNode(this), false, false, function (e) { return util_1.Guard.isElementNode(e); });\n        while (ele !== null) {\n            if (ele._uniqueIdentifier === id) {\n                return ele;\n            }\n            ele = algorithm_1.tree_getNextDescendantNode(util_1.Cast.asNode(this), ele, false, false, function (e) { return util_1.Guard.isElementNode(e); });\n        }\n        return null;\n    };\n    return NonElementParentNodeImpl;\n}());\nexports.NonElementParentNodeImpl = NonElementParentNodeImpl;\n//# sourceMappingURL=NonElementParentNodeImpl.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a mixin that extends parent nodes that can have children.\n * This mixin is implemented by {@link Element}, {@link Document} and\n * {@link DocumentFragment}.\n */\nvar ParentNodeImpl = /** @class */ (function () {\n    function ParentNodeImpl() {\n    }\n    Object.defineProperty(ParentNodeImpl.prototype, \"children\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The children attribute’s getter must return an HTMLCollection collection\n             * rooted at context object matching only element children.\n             */\n            return algorithm_1.create_htmlCollection(util_1.Cast.asNode(this));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ParentNodeImpl.prototype, \"firstElementChild\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The firstElementChild attribute’s getter must return the first child\n             * that is an element, and null otherwise.\n             */\n            var node = util_1.Cast.asNode(this)._firstChild;\n            while (node) {\n                if (util_1.Guard.isElementNode(node))\n                    return node;\n                else\n                    node = node._nextSibling;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ParentNodeImpl.prototype, \"lastElementChild\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * The lastElementChild attribute’s getter must return the last child that\n             * is an element, and null otherwise.\n             */\n            var node = util_1.Cast.asNode(this)._lastChild;\n            while (node) {\n                if (util_1.Guard.isElementNode(node))\n                    return node;\n                else\n                    node = node._previousSibling;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ParentNodeImpl.prototype, \"childElementCount\", {\n        /** @inheritdoc */\n        get: function () {\n            var e_1, _a;\n            /**\n             * The childElementCount attribute’s getter must return the number of\n             * children of context object that are elements.\n             */\n            var count = 0;\n            try {\n                for (var _b = __values(util_1.Cast.asNode(this)._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var childNode = _c.value;\n                    if (util_1.Guard.isElementNode(childNode))\n                        count++;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return count;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    ParentNodeImpl.prototype.prepend = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        /**\n         * 1. Let node be the result of converting nodes into a node given nodes\n         * and context object’s node document.\n         * 2. Pre-insert node into context object before the context object’s first\n         * child.\n         */\n        var node = util_1.Cast.asNode(this);\n        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);\n        algorithm_1.mutation_preInsert(childNode, node, node._firstChild);\n    };\n    /** @inheritdoc */\n    ParentNodeImpl.prototype.append = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        /**\n         * 1. Let node be the result of converting nodes into a node given nodes\n         * and context object’s node document.\n         * 2. Append node to context object.\n         */\n        var node = util_1.Cast.asNode(this);\n        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);\n        algorithm_1.mutation_append(childNode, node);\n    };\n    /** @inheritdoc */\n    ParentNodeImpl.prototype.querySelector = function (selectors) {\n        /**\n         * The querySelector(selectors) method, when invoked, must return the first\n         * result of running scope-match a selectors string selectors against\n         * context object, if the result is not an empty list, and null otherwise.\n         */\n        var node = util_1.Cast.asNode(this);\n        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);\n        return (result.length === 0 ? null : result[0]);\n    };\n    /** @inheritdoc */\n    ParentNodeImpl.prototype.querySelectorAll = function (selectors) {\n        /**\n         * The querySelectorAll(selectors) method, when invoked, must return the\n         * static result of running scope-match a selectors string selectors against\n         * context object.\n         */\n        var node = util_1.Cast.asNode(this);\n        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);\n        return algorithm_1.create_nodeListStatic(node, result);\n    };\n    return ParentNodeImpl;\n}());\nexports.ParentNodeImpl = ParentNodeImpl;\n//# sourceMappingURL=ParentNodeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar CharacterDataImpl_1 = require(\"./CharacterDataImpl\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a processing instruction node.\n */\nvar ProcessingInstructionImpl = /** @class */ (function (_super) {\n    __extends(ProcessingInstructionImpl, _super);\n    /**\n     * Initializes a new instance of `ProcessingInstruction`.\n     */\n    function ProcessingInstructionImpl(target, data) {\n        var _this = _super.call(this, data) || this;\n        _this._target = target;\n        return _this;\n    }\n    Object.defineProperty(ProcessingInstructionImpl.prototype, \"target\", {\n        /**\n         * Gets the target of the {@link ProcessingInstruction} node.\n         */\n        get: function () { return this._target; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new `ProcessingInstruction`.\n     *\n     * @param document - owner document\n     * @param target - instruction target\n     * @param data - node contents\n     */\n    ProcessingInstructionImpl._create = function (document, target, data) {\n        var node = new ProcessingInstructionImpl(target, data);\n        node._nodeDocument = document;\n        return node;\n    };\n    return ProcessingInstructionImpl;\n}(CharacterDataImpl_1.CharacterDataImpl));\nexports.ProcessingInstructionImpl = ProcessingInstructionImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(ProcessingInstructionImpl.prototype, \"_nodeType\", interfaces_1.NodeType.ProcessingInstruction);\n//# sourceMappingURL=ProcessingInstructionImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOMImpl_1 = require(\"./DOMImpl\");\nvar interfaces_1 = require(\"./interfaces\");\nvar AbstractRangeImpl_1 = require(\"./AbstractRangeImpl\");\nvar DOMException_1 = require(\"./DOMException\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\nvar util_1 = require(\"../util\");\n/**\n * Represents a live range.\n */\nvar RangeImpl = /** @class */ (function (_super) {\n    __extends(RangeImpl, _super);\n    /**\n     * Initializes a new instance of `Range`.\n     */\n    function RangeImpl() {\n        var _this = _super.call(this) || this;\n        /**\n         * The Range() constructor, when invoked, must return a new live range with\n         * (current global object’s associated Document, 0) as its start and end.\n         */\n        var doc = DOMImpl_1.dom.window._associatedDocument;\n        _this._start = [doc, 0];\n        _this._end = [doc, 0];\n        DOMImpl_1.dom.rangeList.add(_this);\n        return _this;\n    }\n    Object.defineProperty(RangeImpl.prototype, \"commonAncestorContainer\", {\n        /** @inheritdoc */\n        get: function () {\n            /**\n             * 1. Let container be start node.\n             * 2. While container is not an inclusive ancestor of end node, let\n             * container be container’s parent.\n             * 3. Return container.\n             */\n            var container = this._start[0];\n            while (!algorithm_1.tree_isAncestorOf(this._end[0], container, true)) {\n                if (container._parent === null) {\n                    throw new Error(\"Parent node  is null.\");\n                }\n                container = container._parent;\n            }\n            return container;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    RangeImpl.prototype.setStart = function (node, offset) {\n        /**\n         * The setStart(node, offset) method, when invoked, must set the start of\n         * context object to boundary point (node, offset).\n         */\n        algorithm_1.range_setTheStart(this, node, offset);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.setEnd = function (node, offset) {\n        /**\n         * The setEnd(node, offset) method, when invoked, must set the end of\n         * context object to boundary point (node, offset).\n         */\n        algorithm_1.range_setTheEnd(this, node, offset);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.setStartBefore = function (node) {\n        /**\n         * 1. Let parent be node’s parent.\n         * 2. If parent is null, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 3. Set the start of the context object to boundary point\n         * (parent, node’s index).\n         */\n        var parent = node._parent;\n        if (parent === null)\n            throw new DOMException_1.InvalidNodeTypeError();\n        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node));\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.setStartAfter = function (node) {\n        /**\n         * 1. Let parent be node’s parent.\n         * 2. If parent is null, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 3. Set the start of the context object to boundary point\n         * (parent, node’s index plus 1).\n         */\n        var parent = node._parent;\n        if (parent === null)\n            throw new DOMException_1.InvalidNodeTypeError();\n        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node) + 1);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.setEndBefore = function (node) {\n        /**\n         * 1. Let parent be node’s parent.\n         * 2. If parent is null, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 3. Set the end of the context object to boundary point\n         * (parent, node’s index).\n         */\n        var parent = node._parent;\n        if (parent === null)\n            throw new DOMException_1.InvalidNodeTypeError();\n        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node));\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.setEndAfter = function (node) {\n        /**\n         * 1. Let parent be node’s parent.\n         * 2. If parent is null, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 3. Set the end of the context object to boundary point\n         * (parent, node’s index plus 1).\n         */\n        var parent = node._parent;\n        if (parent === null)\n            throw new DOMException_1.InvalidNodeTypeError();\n        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node) + 1);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.collapse = function (toStart) {\n        /**\n         * The collapse(toStart) method, when invoked, must if toStart is true,\n         * set end to start, and set start to end otherwise.\n         */\n        if (toStart) {\n            this._end = this._start;\n        }\n        else {\n            this._start = this._end;\n        }\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.selectNode = function (node) {\n        /**\n         * The selectNode(node) method, when invoked, must select node within\n         * context object.\n         */\n        algorithm_1.range_select(node, this);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.selectNodeContents = function (node) {\n        /**\n         * 1. If node is a doctype, throw an \"InvalidNodeTypeError\" DOMException.\n         * 2. Let length be the length of node.\n         * 3. Set start to the boundary point (node, 0).\n         * 4. Set end to the boundary point (node, length).\n         */\n        if (util_1.Guard.isDocumentTypeNode(node))\n            throw new DOMException_1.InvalidNodeTypeError();\n        var length = algorithm_1.tree_nodeLength(node);\n        this._start = [node, 0];\n        this._end = [node, length];\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.compareBoundaryPoints = function (how, sourceRange) {\n        /**\n         * 1. If how is not one of\n         * - START_TO_START,\n         * - START_TO_END,\n         * - END_TO_END, and\n         * - END_TO_START,\n         * then throw a \"NotSupportedError\" DOMException.\n         */\n        if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd &&\n            how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)\n            throw new DOMException_1.NotSupportedError();\n        /**\n         * 2. If context object’s root is not the same as sourceRange’s root,\n         * then throw a \"WrongDocumentError\" DOMException.\n         */\n        if (algorithm_1.range_root(this) !== algorithm_1.range_root(sourceRange))\n            throw new DOMException_1.WrongDocumentError();\n        /**\n         * 3. If how is:\n         * - START_TO_START:\n         * Let this point be the context object’s start. Let other point be\n         * sourceRange’s start.\n         * - START_TO_END:\n         * Let this point be the context object’s end. Let other point be\n         * sourceRange’s start.\n         * - END_TO_END:\n         * Let this point be the context object’s end. Let other point be\n         * sourceRange’s end.\n         * - END_TO_START:\n         * Let this point be the context object’s start. Let other point be\n         * sourceRange’s end.\n         */\n        var thisPoint;\n        var otherPoint;\n        switch (how) {\n            case interfaces_1.HowToCompare.StartToStart:\n                thisPoint = this._start;\n                otherPoint = sourceRange._start;\n                break;\n            case interfaces_1.HowToCompare.StartToEnd:\n                thisPoint = this._end;\n                otherPoint = sourceRange._start;\n                break;\n            case interfaces_1.HowToCompare.EndToEnd:\n                thisPoint = this._end;\n                otherPoint = sourceRange._end;\n                break;\n            case interfaces_1.HowToCompare.EndToStart:\n                thisPoint = this._start;\n                otherPoint = sourceRange._end;\n                break;\n            /* istanbul ignore next */\n            default:\n                throw new DOMException_1.NotSupportedError();\n        }\n        /**\n         * 4. If the position of this point relative to other point is\n         * - before\n         * Return −1.\n         * - equal\n         * Return 0.\n         * - after\n         * Return 1.\n         */\n        var position = algorithm_1.boundaryPoint_position(thisPoint, otherPoint);\n        if (position === interfaces_1.BoundaryPosition.Before) {\n            return -1;\n        }\n        else if (position === interfaces_1.BoundaryPosition.After) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.deleteContents = function () {\n        var e_1, _a, e_2, _b;\n        /**\n         * 1. If the context object is collapsed, then return.\n         * 2. Let original start node, original start offset, original end node,\n         * and original end offset be the context object’s start node,\n         * start offset, end node, and end offset, respectively.\n         */\n        if (algorithm_1.range_collapsed(this))\n            return;\n        var originalStartNode = this._startNode;\n        var originalStartOffset = this._startOffset;\n        var originalEndNode = this._endNode;\n        var originalEndOffset = this._endOffset;\n        /**\n         * 3. If original start node and original end node are the same, and they\n         * are a Text, ProcessingInstruction, or Comment node, replace data with\n         * node original start node, offset original start offset, count original\n         * end offset minus original start offset, and data the empty string,\n         * and then return.\n         */\n        if (originalStartNode === originalEndNode &&\n            util_1.Guard.isCharacterDataNode(originalStartNode)) {\n            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, '');\n            return;\n        }\n        /**\n         * 4. Let nodes to remove be a list of all the nodes that are contained in\n         * the context object, in tree order, omitting any node whose parent is also\n         * contained in the context object.\n         */\n        var nodesToRemove = [];\n        try {\n            for (var _c = __values(algorithm_1.range_getContainedNodes(this)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var node = _d.value;\n                var parent = node._parent;\n                if (parent !== null && algorithm_1.range_isContained(parent, this)) {\n                    continue;\n                }\n                nodesToRemove.push(node);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var newNode;\n        var newOffset;\n        if (algorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {\n            /**\n             * 5. If original start node is an inclusive ancestor of original end\n             * node, set new node to original start node and new offset to original\n             * start offset.\n             */\n            newNode = originalStartNode;\n            newOffset = originalStartOffset;\n        }\n        else {\n            /**\n             * 6. Otherwise:\n             * 6.1. Let reference node equal original start node.\n             * 6.2. While reference node’s parent is not null and is not an inclusive\n             * ancestor of original end node, set reference node to its parent.\n             * 6.3. Set new node to the parent of reference node, and new offset to\n             * one plus the index of reference node.\n             */\n            var referenceNode = originalStartNode;\n            while (referenceNode._parent !== null &&\n                !algorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent, true)) {\n                referenceNode = referenceNode._parent;\n            }\n            /* istanbul ignore next */\n            if (referenceNode._parent === null) {\n                throw new Error(\"Parent node is null.\");\n            }\n            newNode = referenceNode._parent;\n            newOffset = algorithm_1.tree_index(referenceNode) + 1;\n        }\n        /**\n         * 7. If original start node is a Text, ProcessingInstruction, or Comment\n         * node, replace data with node original start node, offset original start\n         * offset, count original start node’s length minus original start offset,\n         * data the empty string.\n         */\n        if (util_1.Guard.isCharacterDataNode(originalStartNode)) {\n            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, algorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, '');\n        }\n        try {\n            /**\n             * 8. For each node in nodes to remove, in tree order, remove node from its\n             * parent.\n             */\n            for (var nodesToRemove_1 = __values(nodesToRemove), nodesToRemove_1_1 = nodesToRemove_1.next(); !nodesToRemove_1_1.done; nodesToRemove_1_1 = nodesToRemove_1.next()) {\n                var node = nodesToRemove_1_1.value;\n                /* istanbul ignore else */\n                if (node._parent) {\n                    algorithm_1.mutation_remove(node, node._parent);\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (nodesToRemove_1_1 && !nodesToRemove_1_1.done && (_b = nodesToRemove_1.return)) _b.call(nodesToRemove_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        /**\n         * 9. If original end node is a Text, ProcessingInstruction, or Comment\n         * node, replace data with node original end node, offset 0, count original\n         * end offset and data the empty string.\n         */\n        if (util_1.Guard.isCharacterDataNode(originalEndNode)) {\n            algorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, '');\n        }\n        /**\n         * 10. Set start and end to (new node, new offset).\n         */\n        this._start = [newNode, newOffset];\n        this._end = [newNode, newOffset];\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.extractContents = function () {\n        /**\n         * The extractContents() method, when invoked, must return the result of\n         * extracting the context object.\n         */\n        return algorithm_1.range_extract(this);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.cloneContents = function () {\n        /**\n         * The cloneContents() method, when invoked, must return the result of\n         * cloning the contents of the context object.\n         */\n        return algorithm_1.range_cloneTheContents(this);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.insertNode = function (node) {\n        /**\n         * The insertNode(node) method, when invoked, must insert node into the\n         * context object.\n         */\n        return algorithm_1.range_insert(node, this);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.surroundContents = function (newParent) {\n        var e_3, _a;\n        try {\n            /**\n             * 1. If a non-Text node is partially contained in the context object, then\n             * throw an \"InvalidStateError\" DOMException.\n             */\n            for (var _b = __values(algorithm_1.range_getPartiallyContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var node = _c.value;\n                if (!util_1.Guard.isTextNode(node)) {\n                    throw new DOMException_1.InvalidStateError();\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        /**\n         * 2. If newParent is a Document, DocumentType, or DocumentFragment node,\n         * then throw an \"InvalidNodeTypeError\" DOMException.\n         */\n        if (util_1.Guard.isDocumentNode(newParent) ||\n            util_1.Guard.isDocumentTypeNode(newParent) ||\n            util_1.Guard.isDocumentFragmentNode(newParent)) {\n            throw new DOMException_1.InvalidNodeTypeError();\n        }\n        /**\n         * 3. Let fragment be the result of extracting the context object.\n         */\n        var fragment = algorithm_1.range_extract(this);\n        /**\n         * 4. If newParent has children, then replace all with null within newParent.\n         */\n        if ((newParent)._children.size !== 0) {\n            algorithm_1.mutation_replaceAll(null, newParent);\n        }\n        /**\n         * 5. Insert newParent into the context object.\n         * 6. Append fragment to newParent.\n         */\n        algorithm_1.range_insert(newParent, this);\n        algorithm_1.mutation_append(fragment, newParent);\n        /**\n         * 7. Select newParent within the context object.\n         */\n        algorithm_1.range_select(newParent, this);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.cloneRange = function () {\n        /**\n         * The cloneRange() method, when invoked, must return a new live range with\n         * the same start and end as the context object.\n         */\n        return algorithm_1.create_range(this._start, this._end);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.detach = function () {\n        /**\n         * The detach() method, when invoked, must do nothing.\n         *\n         * since JS lacks weak references, we still use detach\n         */\n        DOMImpl_1.dom.rangeList.delete(this);\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.isPointInRange = function (node, offset) {\n        /**\n         * 1. If node’s root is different from the context object’s root, return false.\n         */\n        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {\n            return false;\n        }\n        /**\n         * 2. If node is a doctype, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 3. If offset is greater than node’s length, then throw an\n         * \"IndexSizeError\" DOMException.\n         */\n        if (util_1.Guard.isDocumentTypeNode(node))\n            throw new DOMException_1.InvalidNodeTypeError();\n        if (offset > algorithm_1.tree_nodeLength(node))\n            throw new DOMException_1.IndexSizeError();\n        /**\n         * 4. If (node, offset) is before start or after end, return false.\n         */\n        var bp = [node, offset];\n        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before ||\n            algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {\n            return false;\n        }\n        /**\n         * 5. Return true.\n         */\n        return true;\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.comparePoint = function (node, offset) {\n        /**\n         * 1. If node’s root is different from the context object’s root, then throw\n         * a \"WrongDocumentError\" DOMException.\n         * 2. If node is a doctype, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 3. If offset is greater than node’s length, then throw an\n         * \"IndexSizeError\" DOMException.\n         */\n        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this))\n            throw new DOMException_1.WrongDocumentError();\n        if (util_1.Guard.isDocumentTypeNode(node))\n            throw new DOMException_1.InvalidNodeTypeError();\n        if (offset > algorithm_1.tree_nodeLength(node))\n            throw new DOMException_1.IndexSizeError();\n        /**\n         * 4. If (node, offset) is before start, return −1.\n         * 5. If (node, offset) is after end, return 1.\n         * 6. Return 0.\n         */\n        var bp = [node, offset];\n        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before) {\n            return -1;\n        }\n        else if (algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /** @inheritdoc */\n    RangeImpl.prototype.intersectsNode = function (node) {\n        /**\n         * 1. If node’s root is different from the context object’s root, return false.\n         */\n        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {\n            return false;\n        }\n        /**\n         * 2. Let parent be node’s parent.\n         * 3. If parent is null, return true.\n         */\n        var parent = node._parent;\n        if (parent === null)\n            return true;\n        /**\n         * 4. Let offset be node’s index.\n         */\n        var offset = algorithm_1.tree_index(node);\n        /**\n         * 5. If (parent, offset) is before end and (parent, offset plus 1) is\n         * after start, return true.\n         */\n        if (algorithm_1.boundaryPoint_position([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before &&\n            algorithm_1.boundaryPoint_position([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {\n            return true;\n        }\n        /**\n         * 6. Return false.\n         */\n        return false;\n    };\n    RangeImpl.prototype.toString = function () {\n        var e_4, _a;\n        /**\n         * 1. Let s be the empty string.\n         */\n        var s = '';\n        /**\n         * 2. If the context object’s start node is the context object’s end node\n         * and it is a Text node, then return the substring of that Text node’s data\n         * beginning at the context object’s start offset and ending at the context\n         * object’s end offset.\n         */\n        if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {\n            return this._startNode._data.substring(this._startOffset, this._endOffset);\n        }\n        /**\n         * 3. If the context object’s start node is a Text node, then append the\n         * substring of that node’s data from the context object’s start offset\n         * until the end to s.\n         */\n        if (util_1.Guard.isTextNode(this._startNode)) {\n            s += this._startNode._data.substring(this._startOffset);\n        }\n        try {\n            /**\n             * 4. Append the concatenation of the data of all Text nodes that are\n             * contained in the context object, in tree order, to s.\n             */\n            for (var _b = __values(algorithm_1.range_getContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var child = _c.value;\n                if (util_1.Guard.isTextNode(child)) {\n                    s += child._data;\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        /**\n         * 5. If the context object’s end node is a Text node, then append the\n         * substring of that node’s data from its start until the context object’s\n         * end offset to s.\n         */\n        if (util_1.Guard.isTextNode(this._endNode)) {\n            s += this._endNode._data.substring(0, this._endOffset);\n        }\n        /**\n         * 6. Return s.\n         */\n        return s;\n    };\n    /**\n     * Creates a new `Range`.\n     *\n     * @param start - start point\n     * @param end - end point\n     */\n    RangeImpl._create = function (start, end) {\n        var range = new RangeImpl();\n        if (start)\n            range._start = start;\n        if (end)\n            range._end = end;\n        return range;\n    };\n    RangeImpl.START_TO_START = 0;\n    RangeImpl.START_TO_END = 1;\n    RangeImpl.END_TO_END = 2;\n    RangeImpl.END_TO_START = 3;\n    return RangeImpl;\n}(AbstractRangeImpl_1.AbstractRangeImpl));\nexports.RangeImpl = RangeImpl;\n/**\n * Define constants on prototype.\n */\nWebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, \"START_TO_START\", 0);\nWebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, \"START_TO_END\", 1);\nWebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, \"END_TO_END\", 2);\nWebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, \"END_TO_START\", 3);\n//# sourceMappingURL=RangeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DocumentFragmentImpl_1 = require(\"./DocumentFragmentImpl\");\nvar util_1 = require(\"@oozcitak/util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a shadow root.\n */\nvar ShadowRootImpl = /** @class */ (function (_super) {\n    __extends(ShadowRootImpl, _super);\n    /**\n     * Initializes a new instance of `ShadowRoot`.\n     *\n     * @param host - shadow root's host element\n     * @param mode - shadow root's mode\n     */\n    function ShadowRootImpl(host, mode) {\n        var _this = _super.call(this) || this;\n        _this._host = host;\n        _this._mode = mode;\n        return _this;\n    }\n    Object.defineProperty(ShadowRootImpl.prototype, \"mode\", {\n        /** @inheritdoc */\n        get: function () { return this._mode; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowRootImpl.prototype, \"host\", {\n        /** @inheritdoc */\n        get: function () { return this._host; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Gets the parent event target for the given event.\n     *\n     * @param event - an event\n     */\n    ShadowRootImpl.prototype._getTheParent = function (event) {\n        /**\n         * A shadow root’s get the parent algorithm, given an event, returns null\n         * if event’s composed flag is unset and shadow root is the root of\n         * event’s path’s first struct’s invocation target, and shadow root’s host\n         * otherwise.\n         */\n        if (!event._composedFlag && !util_1.isEmpty(event._path) &&\n            algorithm_1.tree_rootNode(event._path[0].invocationTarget) === this) {\n            return null;\n        }\n        else {\n            return this._host;\n        }\n    };\n    // MIXIN: DocumentOrShadowRoot\n    // No elements\n    /**\n     * Creates a new `ShadowRoot`.\n     *\n     * @param document - owner document\n     * @param host - shadow root's host element\n     */\n    ShadowRootImpl._create = function (document, host) {\n        return new ShadowRootImpl(host, \"closed\");\n    };\n    return ShadowRootImpl;\n}(DocumentFragmentImpl_1.DocumentFragmentImpl));\nexports.ShadowRootImpl = ShadowRootImpl;\n//# sourceMappingURL=ShadowRootImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a mixin that allows nodes to become the contents of\n * a <slot> element. This mixin is implemented by {@link Element} and\n * {@link Text}.\n */\nvar SlotableImpl = /** @class */ (function () {\n    function SlotableImpl() {\n    }\n    Object.defineProperty(SlotableImpl.prototype, \"_name\", {\n        get: function () { return this.__name || ''; },\n        set: function (val) { this.__name = val; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SlotableImpl.prototype, \"_assignedSlot\", {\n        get: function () { return this.__assignedSlot || null; },\n        set: function (val) { this.__assignedSlot = val; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SlotableImpl.prototype, \"assignedSlot\", {\n        /** @inheritdoc */\n        get: function () {\n            return algorithm_1.shadowTree_findASlot(this, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SlotableImpl;\n}());\nexports.SlotableImpl = SlotableImpl;\n//# sourceMappingURL=SlotableImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractRangeImpl_1 = require(\"./AbstractRangeImpl\");\nvar DOMException_1 = require(\"./DOMException\");\nvar util_1 = require(\"../util\");\n/**\n * Represents a static range.\n */\nvar StaticRangeImpl = /** @class */ (function (_super) {\n    __extends(StaticRangeImpl, _super);\n    /**\n     * Initializes a new instance of `StaticRange`.\n     */\n    function StaticRangeImpl(init) {\n        var _this = _super.call(this) || this;\n        /**\n         * 1. If init’s startContainer or endContainer is a DocumentType or Attr\n         * node, then throw an \"InvalidNodeTypeError\" DOMException.\n         * 2. Let staticRange be a new StaticRange object.\n         * 3. Set staticRange’s start to (init’s startContainer, init’s startOffset)\n         * and end to (init’s endContainer, init’s endOffset).\n         * 4. Return staticRange.\n         */\n        if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) ||\n            util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {\n            throw new DOMException_1.InvalidNodeTypeError();\n        }\n        _this._start = [init.startContainer, init.startOffset];\n        _this._end = [init.endContainer, init.endOffset];\n        return _this;\n    }\n    return StaticRangeImpl;\n}(AbstractRangeImpl_1.AbstractRangeImpl));\nexports.StaticRangeImpl = StaticRangeImpl;\n//# sourceMappingURL=StaticRangeImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar CharacterDataImpl_1 = require(\"./CharacterDataImpl\");\nvar algorithm_1 = require(\"../algorithm\");\nvar WebIDLAlgorithm_1 = require(\"../algorithm/WebIDLAlgorithm\");\n/**\n * Represents a text node.\n */\nvar TextImpl = /** @class */ (function (_super) {\n    __extends(TextImpl, _super);\n    /**\n     * Initializes a new instance of `Text`.\n     *\n     * @param data - the text content\n     */\n    function TextImpl(data) {\n        if (data === void 0) { data = ''; }\n        var _this = _super.call(this, data) || this;\n        _this._name = '';\n        _this._assignedSlot = null;\n        return _this;\n    }\n    Object.defineProperty(TextImpl.prototype, \"wholeText\", {\n        /** @inheritdoc */\n        get: function () {\n            var e_1, _a;\n            /**\n             * The wholeText attribute’s getter must return the concatenation of the\n             * data of the contiguous Text nodes of the context object, in tree order.\n             */\n            var text = '';\n            try {\n                for (var _b = __values(algorithm_1.text_contiguousTextNodes(this, true)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var node = _c.value;\n                    text = text + node._data;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return text;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    TextImpl.prototype.splitText = function (offset) {\n        /**\n         * The splitText(offset) method, when invoked, must split context object\n         * with offset offset.\n         */\n        return algorithm_1.text_split(this, offset);\n    };\n    Object.defineProperty(TextImpl.prototype, \"assignedSlot\", {\n        // MIXIN: Slotable\n        /* istanbul ignore next */\n        get: function () { throw new Error(\"Mixin: Slotable not implemented.\"); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a `Text`.\n     *\n     * @param document - owner document\n     * @param data - the text content\n     */\n    TextImpl._create = function (document, data) {\n        if (data === void 0) { data = ''; }\n        var node = new TextImpl(data);\n        node._nodeDocument = document;\n        return node;\n    };\n    return TextImpl;\n}(CharacterDataImpl_1.CharacterDataImpl));\nexports.TextImpl = TextImpl;\n/**\n * Initialize prototype properties\n */\nWebIDLAlgorithm_1.idl_defineConst(TextImpl.prototype, \"_nodeType\", interfaces_1.NodeType.Text);\n//# sourceMappingURL=TextImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\n/**\n * Represents an object which can be used to iterate through the nodes\n * of a subtree.\n */\nvar TraverserImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `Traverser`.\n     *\n     * @param root - root node\n     */\n    function TraverserImpl(root) {\n        this._activeFlag = false;\n        this._root = root;\n        this._whatToShow = interfaces_1.WhatToShow.All;\n        this._filter = null;\n    }\n    Object.defineProperty(TraverserImpl.prototype, \"root\", {\n        /** @inheritdoc */\n        get: function () { return this._root; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TraverserImpl.prototype, \"whatToShow\", {\n        /** @inheritdoc */\n        get: function () { return this._whatToShow; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TraverserImpl.prototype, \"filter\", {\n        /** @inheritdoc */\n        get: function () { return this._filter; },\n        enumerable: true,\n        configurable: true\n    });\n    return TraverserImpl;\n}());\nexports.TraverserImpl = TraverserImpl;\n//# sourceMappingURL=TraverserImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\nvar TraverserImpl_1 = require(\"./TraverserImpl\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents the nodes of a subtree and a position within them.\n */\nvar TreeWalkerImpl = /** @class */ (function (_super) {\n    __extends(TreeWalkerImpl, _super);\n    /**\n     * Initializes a new instance of `TreeWalker`.\n     */\n    function TreeWalkerImpl(root, current) {\n        var _this = _super.call(this, root) || this;\n        _this._current = current;\n        return _this;\n    }\n    Object.defineProperty(TreeWalkerImpl.prototype, \"currentNode\", {\n        /** @inheritdoc */\n        get: function () { return this._current; },\n        set: function (value) { this._current = value; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.parentNode = function () {\n        /**\n         * 1. Let node be the context object’s current.\n         * 2. While node is non-null and is not the context object’s root:\n         */\n        var node = this._current;\n        while (node !== null && node !== this._root) {\n            /**\n             * 2.1. Set node to node’s parent.\n             * 2.2. If node is non-null and filtering node within the context object\n             * returns FILTER_ACCEPT, then set the context object’s current to node\n             * and return node.\n             */\n            node = node._parent;\n            if (node !== null &&\n                algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {\n                this._current = node;\n                return node;\n            }\n        }\n        /**\n         * 3. Return null.\n         */\n        return null;\n    };\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.firstChild = function () {\n        /**\n         * The firstChild() method, when invoked, must traverse children with the\n         * context object and first.\n         */\n        return algorithm_1.treeWalker_traverseChildren(this, true);\n    };\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.lastChild = function () {\n        /**\n         * The lastChild() method, when invoked, must traverse children with the\n         * context object and last.\n         */\n        return algorithm_1.treeWalker_traverseChildren(this, false);\n    };\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.nextSibling = function () {\n        /**\n         * The nextSibling() method, when invoked, must traverse siblings with the\n         * context object and next.\n         */\n        return algorithm_1.treeWalker_traverseSiblings(this, true);\n    };\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.previousNode = function () {\n        /**\n         * 1. Let node be the context object’s current.\n         * 2. While node is not the context object’s root:\n         */\n        var node = this._current;\n        while (node !== this._root) {\n            /**\n             * 2.1. Let sibling be node’s previous sibling.\n             * 2.2. While sibling is non-null:\n             */\n            var sibling = node._previousSibling;\n            while (sibling) {\n                /**\n                 * 2.2.1. Set node to sibling.\n                 * 2.2.2. Let result be the result of filtering node within the context\n                 * object.\n                 */\n                node = sibling;\n                var result = algorithm_1.traversal_filter(this, node);\n                /**\n                 * 2.2.3. While result is not FILTER_REJECT and node has a child:\n                 */\n                while (result !== interfaces_1.FilterResult.Reject && node._lastChild) {\n                    /**\n                     * 2.2.3.1. Set node to node’s last child.\n                     * 2.2.3.2. Set result to the result of filtering node within the\n                     * context object.\n                     */\n                    node = node._lastChild;\n                    result = algorithm_1.traversal_filter(this, node);\n                }\n                /**\n                 * 2.2.4. If result is FILTER_ACCEPT, then set the context object’s\n                 * current to node and return node.\n                 */\n                if (result === interfaces_1.FilterResult.Accept) {\n                    this._current = node;\n                    return node;\n                }\n                /**\n                 * 2.2.5. Set sibling to node’s previous sibling.\n                 */\n                sibling = node._previousSibling;\n            }\n            /**\n             * 2.3. If node is the context object’s root or node’s parent is null,\n             * then return null.\n             */\n            if (node === this._root || node._parent === null) {\n                return null;\n            }\n            /**\n             * 2.4. Set node to node’s parent.\n             */\n            node = node._parent;\n            /**\n             * 2.5. If the return value of filtering node within the context object is\n             * FILTER_ACCEPT, then set the context object’s current to node and\n             * return node.\n             */\n            if (algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {\n                this._current = node;\n                return node;\n            }\n        }\n        /**\n         * 3. Return null.\n         */\n        return null;\n    };\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.previousSibling = function () {\n        /**\n         * The previousSibling() method, when invoked, must traverse siblings with\n         * the context object and previous.\n         */\n        return algorithm_1.treeWalker_traverseSiblings(this, false);\n    };\n    /** @inheritdoc */\n    TreeWalkerImpl.prototype.nextNode = function () {\n        /**\n         * 1. Let node be the context object’s current.\n         * 2. Let result be FILTER_ACCEPT.\n         * 3. While true:\n         */\n        var node = this._current;\n        var result = interfaces_1.FilterResult.Accept;\n        while (true) {\n            /**\n             * 3.1. While result is not FILTER_REJECT and node has a child:\n             */\n            while (result !== interfaces_1.FilterResult.Reject && node._firstChild) {\n                /**\n                 * 3.1.1. Set node to its first child.\n                 * 3.1.2. Set result to the result of filtering node within the context\n                 * object.\n                 * 3.1.3. If result is FILTER_ACCEPT, then set the context object’s\n                 * current to node and return node.\n                 */\n                node = node._firstChild;\n                result = algorithm_1.traversal_filter(this, node);\n                if (result === interfaces_1.FilterResult.Accept) {\n                    this._current = node;\n                    return node;\n                }\n            }\n            /**\n             * 3.2. Let sibling be null.\n             * 3.3. Let temporary be node.\n             * 3.4. While temporary is non-null:\n             */\n            var sibling = null;\n            var temporary = node;\n            while (temporary !== null) {\n                /**\n                 * 3.4.1. If temporary is the context object’s root, then return null.\n                 */\n                if (temporary === this._root) {\n                    return null;\n                }\n                /**\n                 * 3.4.2. Set sibling to temporary’s next sibling.\n                 * 3.4.3. If sibling is non-null, then break.\n                 */\n                sibling = temporary._nextSibling;\n                if (sibling !== null) {\n                    node = sibling;\n                    break;\n                }\n                /**\n                 * 3.4.4. Set temporary to temporary’s parent.\n                 */\n                temporary = temporary._parent;\n            }\n            /**\n             * 3.5. Set result to the result of filtering node within the context object.\n             * 3.6. If result is FILTER_ACCEPT, then set the context object’s current\n             * to node and return node.\n             */\n            result = algorithm_1.traversal_filter(this, node);\n            if (result === interfaces_1.FilterResult.Accept) {\n                this._current = node;\n                return node;\n            }\n        }\n    };\n    /**\n     * Creates a new `TreeWalker`.\n     *\n     * @param root - iterator's root node\n     * @param current - current node\n     */\n    TreeWalkerImpl._create = function (root, current) {\n        return new TreeWalkerImpl(root, current);\n    };\n    return TreeWalkerImpl;\n}(TraverserImpl_1.TraverserImpl));\nexports.TreeWalkerImpl = TreeWalkerImpl;\n//# sourceMappingURL=TreeWalkerImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventTargetImpl_1 = require(\"./EventTargetImpl\");\nvar util_1 = require(\"@oozcitak/util\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents a window containing a DOM document.\n */\nvar WindowImpl = /** @class */ (function (_super) {\n    __extends(WindowImpl, _super);\n    /**\n     * Initializes a new instance of `Window`.\n     */\n    function WindowImpl() {\n        var _this = _super.call(this) || this;\n        _this._signalSlots = new Set();\n        _this._mutationObserverMicrotaskQueued = false;\n        _this._mutationObservers = new Set();\n        _this._iteratorList = new util_1.FixedSizeSet();\n        _this._associatedDocument = algorithm_1.create_document();\n        return _this;\n    }\n    Object.defineProperty(WindowImpl.prototype, \"document\", {\n        /** @inheritdoc */\n        get: function () { return this._associatedDocument; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WindowImpl.prototype, \"event\", {\n        /** @inheritdoc */\n        get: function () { return this._currentEvent; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new window with a blank document.\n     */\n    WindowImpl._create = function () {\n        return new WindowImpl();\n    };\n    return WindowImpl;\n}(EventTargetImpl_1.EventTargetImpl));\nexports.WindowImpl = WindowImpl;\n//# sourceMappingURL=WindowImpl.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DocumentImpl_1 = require(\"./DocumentImpl\");\n/**\n * Represents an XML document.\n */\nvar XMLDocumentImpl = /** @class */ (function (_super) {\n    __extends(XMLDocumentImpl, _super);\n    /**\n     * Initializes a new instance of `XMLDocument`.\n     */\n    function XMLDocumentImpl() {\n        return _super.call(this) || this;\n    }\n    return XMLDocumentImpl;\n}(DocumentImpl_1.DocumentImpl));\nexports.XMLDocumentImpl = XMLDocumentImpl;\n//# sourceMappingURL=XMLDocumentImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\n// Import implementation classes\nvar AbortControllerImpl_1 = require(\"./AbortControllerImpl\");\nexports.AbortController = AbortControllerImpl_1.AbortControllerImpl;\nvar AbortSignalImpl_1 = require(\"./AbortSignalImpl\");\nexports.AbortSignal = AbortSignalImpl_1.AbortSignalImpl;\nvar AbstractRangeImpl_1 = require(\"./AbstractRangeImpl\");\nexports.AbstractRange = AbstractRangeImpl_1.AbstractRangeImpl;\nvar AttrImpl_1 = require(\"./AttrImpl\");\nexports.Attr = AttrImpl_1.AttrImpl;\nvar CDATASectionImpl_1 = require(\"./CDATASectionImpl\");\nexports.CDATASection = CDATASectionImpl_1.CDATASectionImpl;\nvar CharacterDataImpl_1 = require(\"./CharacterDataImpl\");\nexports.CharacterData = CharacterDataImpl_1.CharacterDataImpl;\nvar ChildNodeImpl_1 = require(\"./ChildNodeImpl\");\nvar CommentImpl_1 = require(\"./CommentImpl\");\nexports.Comment = CommentImpl_1.CommentImpl;\nvar CustomEventImpl_1 = require(\"./CustomEventImpl\");\nexports.CustomEvent = CustomEventImpl_1.CustomEventImpl;\nvar DocumentFragmentImpl_1 = require(\"./DocumentFragmentImpl\");\nexports.DocumentFragment = DocumentFragmentImpl_1.DocumentFragmentImpl;\nvar DocumentImpl_1 = require(\"./DocumentImpl\");\nexports.Document = DocumentImpl_1.DocumentImpl;\nvar DocumentOrShadowRootImpl_1 = require(\"./DocumentOrShadowRootImpl\");\nvar DocumentTypeImpl_1 = require(\"./DocumentTypeImpl\");\nexports.DocumentType = DocumentTypeImpl_1.DocumentTypeImpl;\nvar DOMImpl_1 = require(\"./DOMImpl\");\nexports.dom = DOMImpl_1.dom;\nvar DOMImplementationImpl_1 = require(\"./DOMImplementationImpl\");\nexports.DOMImplementation = DOMImplementationImpl_1.DOMImplementationImpl;\nvar DOMTokenListImpl_1 = require(\"./DOMTokenListImpl\");\nexports.DOMTokenList = DOMTokenListImpl_1.DOMTokenListImpl;\nvar ElementImpl_1 = require(\"./ElementImpl\");\nexports.Element = ElementImpl_1.ElementImpl;\nvar EventImpl_1 = require(\"./EventImpl\");\nexports.Event = EventImpl_1.EventImpl;\nvar EventTargetImpl_1 = require(\"./EventTargetImpl\");\nexports.EventTarget = EventTargetImpl_1.EventTargetImpl;\nvar HTMLCollectionImpl_1 = require(\"./HTMLCollectionImpl\");\nexports.HTMLCollection = HTMLCollectionImpl_1.HTMLCollectionImpl;\nvar MutationObserverImpl_1 = require(\"./MutationObserverImpl\");\nexports.MutationObserver = MutationObserverImpl_1.MutationObserverImpl;\nvar MutationRecordImpl_1 = require(\"./MutationRecordImpl\");\nexports.MutationRecord = MutationRecordImpl_1.MutationRecordImpl;\nvar NamedNodeMapImpl_1 = require(\"./NamedNodeMapImpl\");\nexports.NamedNodeMap = NamedNodeMapImpl_1.NamedNodeMapImpl;\nvar NodeFilterImpl_1 = require(\"./NodeFilterImpl\");\nexports.NodeFilter = NodeFilterImpl_1.NodeFilterImpl;\nvar NodeImpl_1 = require(\"./NodeImpl\");\nexports.Node = NodeImpl_1.NodeImpl;\nvar NodeIteratorImpl_1 = require(\"./NodeIteratorImpl\");\nexports.NodeIterator = NodeIteratorImpl_1.NodeIteratorImpl;\nvar NodeListImpl_1 = require(\"./NodeListImpl\");\nexports.NodeList = NodeListImpl_1.NodeListImpl;\nvar NodeListStaticImpl_1 = require(\"./NodeListStaticImpl\");\nexports.NodeListStatic = NodeListStaticImpl_1.NodeListStaticImpl;\nvar NonDocumentTypeChildNodeImpl_1 = require(\"./NonDocumentTypeChildNodeImpl\");\nvar NonElementParentNodeImpl_1 = require(\"./NonElementParentNodeImpl\");\nvar ParentNodeImpl_1 = require(\"./ParentNodeImpl\");\nvar ProcessingInstructionImpl_1 = require(\"./ProcessingInstructionImpl\");\nexports.ProcessingInstruction = ProcessingInstructionImpl_1.ProcessingInstructionImpl;\nvar RangeImpl_1 = require(\"./RangeImpl\");\nexports.Range = RangeImpl_1.RangeImpl;\nvar ShadowRootImpl_1 = require(\"./ShadowRootImpl\");\nexports.ShadowRoot = ShadowRootImpl_1.ShadowRootImpl;\nvar SlotableImpl_1 = require(\"./SlotableImpl\");\nvar StaticRangeImpl_1 = require(\"./StaticRangeImpl\");\nexports.StaticRange = StaticRangeImpl_1.StaticRangeImpl;\nvar TextImpl_1 = require(\"./TextImpl\");\nexports.Text = TextImpl_1.TextImpl;\nvar TraverserImpl_1 = require(\"./TraverserImpl\");\nexports.Traverser = TraverserImpl_1.TraverserImpl;\nvar TreeWalkerImpl_1 = require(\"./TreeWalkerImpl\");\nexports.TreeWalker = TreeWalkerImpl_1.TreeWalkerImpl;\nvar WindowImpl_1 = require(\"./WindowImpl\");\nexports.Window = WindowImpl_1.WindowImpl;\nvar XMLDocumentImpl_1 = require(\"./XMLDocumentImpl\");\nexports.XMLDocument = XMLDocumentImpl_1.XMLDocumentImpl;\n// Apply mixins\n// ChildNode\nutil_1.applyMixin(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);\nutil_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);\nutil_1.applyMixin(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);\n// DocumentOrShadowRoot\nutil_1.applyMixin(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);\nutil_1.applyMixin(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);\n// NonDocumentTypeChildNode\nutil_1.applyMixin(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);\nutil_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);\n// NonElementParentNode\nutil_1.applyMixin(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);\nutil_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);\n// ParentNode\nutil_1.applyMixin(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);\nutil_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);\nutil_1.applyMixin(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);\n// Slotable\nutil_1.applyMixin(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);\nutil_1.applyMixin(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines the position of a boundary point relative to another.\n */\nvar BoundaryPosition;\n(function (BoundaryPosition) {\n    BoundaryPosition[BoundaryPosition[\"Before\"] = 0] = \"Before\";\n    BoundaryPosition[BoundaryPosition[\"Equal\"] = 1] = \"Equal\";\n    BoundaryPosition[BoundaryPosition[\"After\"] = 2] = \"After\";\n})(BoundaryPosition = exports.BoundaryPosition || (exports.BoundaryPosition = {}));\n/**\n * Defines the event phase.\n */\nvar EventPhase;\n(function (EventPhase) {\n    EventPhase[EventPhase[\"None\"] = 0] = \"None\";\n    EventPhase[EventPhase[\"Capturing\"] = 1] = \"Capturing\";\n    EventPhase[EventPhase[\"AtTarget\"] = 2] = \"AtTarget\";\n    EventPhase[EventPhase[\"Bubbling\"] = 3] = \"Bubbling\";\n})(EventPhase = exports.EventPhase || (exports.EventPhase = {}));\n/**\n * Defines the type of a node object.\n */\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Element\"] = 1] = \"Element\";\n    NodeType[NodeType[\"Attribute\"] = 2] = \"Attribute\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CData\"] = 4] = \"CData\";\n    NodeType[NodeType[\"EntityReference\"] = 5] = \"EntityReference\";\n    NodeType[NodeType[\"Entity\"] = 6] = \"Entity\";\n    NodeType[NodeType[\"ProcessingInstruction\"] = 7] = \"ProcessingInstruction\";\n    NodeType[NodeType[\"Comment\"] = 8] = \"Comment\";\n    NodeType[NodeType[\"Document\"] = 9] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 10] = \"DocumentType\";\n    NodeType[NodeType[\"DocumentFragment\"] = 11] = \"DocumentFragment\";\n    NodeType[NodeType[\"Notation\"] = 12] = \"Notation\"; // historical\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\n/**\n * Defines the position of a node in the document relative to another\n * node.\n */\nvar Position;\n(function (Position) {\n    Position[Position[\"Disconnected\"] = 1] = \"Disconnected\";\n    Position[Position[\"Preceding\"] = 2] = \"Preceding\";\n    Position[Position[\"Following\"] = 4] = \"Following\";\n    Position[Position[\"Contains\"] = 8] = \"Contains\";\n    Position[Position[\"ContainedBy\"] = 16] = \"ContainedBy\";\n    Position[Position[\"ImplementationSpecific\"] = 32] = \"ImplementationSpecific\";\n})(Position = exports.Position || (exports.Position = {}));\n/**\n * Defines the return value of a filter callback.\n */\nvar FilterResult;\n(function (FilterResult) {\n    FilterResult[FilterResult[\"Accept\"] = 1] = \"Accept\";\n    FilterResult[FilterResult[\"Reject\"] = 2] = \"Reject\";\n    FilterResult[FilterResult[\"Skip\"] = 3] = \"Skip\";\n})(FilterResult = exports.FilterResult || (exports.FilterResult = {}));\n/**\n * Defines what to show in node filter.\n */\nvar WhatToShow;\n(function (WhatToShow) {\n    WhatToShow[WhatToShow[\"All\"] = 4294967295] = \"All\";\n    WhatToShow[WhatToShow[\"Element\"] = 1] = \"Element\";\n    WhatToShow[WhatToShow[\"Attribute\"] = 2] = \"Attribute\";\n    WhatToShow[WhatToShow[\"Text\"] = 4] = \"Text\";\n    WhatToShow[WhatToShow[\"CDataSection\"] = 8] = \"CDataSection\";\n    WhatToShow[WhatToShow[\"EntityReference\"] = 16] = \"EntityReference\";\n    WhatToShow[WhatToShow[\"Entity\"] = 32] = \"Entity\";\n    WhatToShow[WhatToShow[\"ProcessingInstruction\"] = 64] = \"ProcessingInstruction\";\n    WhatToShow[WhatToShow[\"Comment\"] = 128] = \"Comment\";\n    WhatToShow[WhatToShow[\"Document\"] = 256] = \"Document\";\n    WhatToShow[WhatToShow[\"DocumentType\"] = 512] = \"DocumentType\";\n    WhatToShow[WhatToShow[\"DocumentFragment\"] = 1024] = \"DocumentFragment\";\n    WhatToShow[WhatToShow[\"Notation\"] = 2048] = \"Notation\";\n})(WhatToShow = exports.WhatToShow || (exports.WhatToShow = {}));\n/**\n * Defines how boundary points are compared.\n */\nvar HowToCompare;\n(function (HowToCompare) {\n    HowToCompare[HowToCompare[\"StartToStart\"] = 0] = \"StartToStart\";\n    HowToCompare[HowToCompare[\"StartToEnd\"] = 1] = \"StartToEnd\";\n    HowToCompare[HowToCompare[\"EndToEnd\"] = 2] = \"EndToEnd\";\n    HowToCompare[HowToCompare[\"EndToStart\"] = 3] = \"EndToStart\";\n})(HowToCompare = exports.HowToCompare || (exports.HowToCompare = {}));\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dom_1 = require(\"./dom\");\ndom_1.dom.setFeatures(true);\nvar dom_2 = require(\"./dom\");\nexports.DOMImplementation = dom_2.DOMImplementation;\nvar parser_1 = require(\"./parser\");\nexports.DOMParser = parser_1.DOMParser;\nvar serializer_1 = require(\"./serializer\");\nexports.XMLSerializer = serializer_1.XMLSerializer;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar algorithm_1 = require(\"../algorithm\");\nvar XMLParserImpl_1 = require(\"./XMLParserImpl\");\n/**\n * Represents a parser for XML and HTML content.\n *\n * See: https://w3c.github.io/DOM-Parsing/#the-domparser-interface\n */\nvar DOMParserImpl = /** @class */ (function () {\n    function DOMParserImpl() {\n    }\n    /** @inheritdoc */\n    DOMParserImpl.prototype.parseFromString = function (source, mimeType) {\n        if (mimeType === \"text/html\")\n            throw new Error('HTML parser not implemented.');\n        try {\n            var parser = new XMLParserImpl_1.XMLParserImpl();\n            var doc = parser.parse(source);\n            doc._contentType = mimeType;\n            return doc;\n        }\n        catch (e) {\n            var errorNS = \"http://www.mozilla.org/newlayout/xml/parsererror.xml\";\n            var doc = algorithm_1.create_xmlDocument();\n            var root = doc.createElementNS(errorNS, \"parsererror\");\n            var ele = doc.createElementNS(errorNS, \"error\");\n            ele.setAttribute(\"message\", e.message);\n            root.appendChild(ele);\n            doc.appendChild(root);\n            return doc;\n        }\n    };\n    return DOMParserImpl;\n}());\nexports.DOMParserImpl = DOMParserImpl;\n//# sourceMappingURL=DOMParserImpl.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar XMLStringLexer_1 = require(\"./XMLStringLexer\");\nvar interfaces_1 = require(\"./interfaces\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"../algorithm\");\nvar LocalNameSet_1 = require(\"../serializer/LocalNameSet\");\n/**\n * Represents a parser for XML content.\n *\n * See: https://html.spec.whatwg.org/#xml-parser\n */\nvar XMLParserImpl = /** @class */ (function () {\n    function XMLParserImpl() {\n    }\n    /**\n     * Parses XML content.\n     *\n     * @param source - a string containing XML content\n     */\n    XMLParserImpl.prototype.parse = function (source) {\n        var e_1, _a, e_2, _b;\n        var lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });\n        var doc = algorithm_1.create_document();\n        var context = doc;\n        var token = lexer.nextToken();\n        while (token.type !== interfaces_1.TokenType.EOF) {\n            switch (token.type) {\n                case interfaces_1.TokenType.Declaration:\n                    var declaration = token;\n                    if (declaration.version !== \"1.0\") {\n                        throw new Error(\"Invalid xml version: \" + declaration.version);\n                    }\n                    break;\n                case interfaces_1.TokenType.DocType:\n                    var doctype = token;\n                    if (!algorithm_1.xml_isPubidChar(doctype.pubId)) {\n                        throw new Error(\"DocType public identifier does not match PubidChar construct.\");\n                    }\n                    if (!algorithm_1.xml_isLegalChar(doctype.sysId) ||\n                        (doctype.sysId.indexOf('\"') !== -1 && doctype.sysId.indexOf(\"'\") !== -1)) {\n                        throw new Error(\"DocType system identifier contains invalid characters.\");\n                    }\n                    context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));\n                    break;\n                case interfaces_1.TokenType.CDATA:\n                    var cdata = token;\n                    if (!algorithm_1.xml_isLegalChar(cdata.data) ||\n                        cdata.data.indexOf(\"]]>\") !== -1) {\n                        throw new Error(\"CDATA contains invalid characters.\");\n                    }\n                    context.appendChild(doc.createCDATASection(cdata.data));\n                    break;\n                case interfaces_1.TokenType.Comment:\n                    var comment = token;\n                    if (!algorithm_1.xml_isLegalChar(comment.data) ||\n                        comment.data.indexOf(\"--\") !== -1 || comment.data.endsWith(\"-\")) {\n                        throw new Error(\"Comment data contains invalid characters.\");\n                    }\n                    context.appendChild(doc.createComment(comment.data));\n                    break;\n                case interfaces_1.TokenType.PI:\n                    var pi = token;\n                    if (pi.target.indexOf(\":\") !== -1 || (/^xml$/i).test(pi.target)) {\n                        throw new Error(\"Processing instruction target contains invalid characters.\");\n                    }\n                    if (!algorithm_1.xml_isLegalChar(pi.data) || pi.data.indexOf(\"?>\") !== -1) {\n                        throw new Error(\"Processing instruction data contains invalid characters.\");\n                    }\n                    context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));\n                    break;\n                case interfaces_1.TokenType.Text:\n                    var text = token;\n                    if (!algorithm_1.xml_isLegalChar(text.data)) {\n                        throw new Error(\"Text data contains invalid characters.\");\n                    }\n                    context.appendChild(doc.createTextNode(text.data));\n                    break;\n                case interfaces_1.TokenType.Element:\n                    var element = token;\n                    // inherit namespace from parent\n                    var _c = __read(algorithm_1.namespace_extractQName(element.name), 2), prefix = _c[0], localName = _c[1];\n                    if (localName.indexOf(\":\") !== -1 || !algorithm_1.xml_isName(localName)) {\n                        throw new Error(\"Node local name contains invalid characters.\");\n                    }\n                    if (prefix === \"xmlns\") {\n                        throw new Error(\"An element cannot have the 'xmlns' prefix.\");\n                    }\n                    var namespace = context.lookupNamespaceURI(prefix);\n                    // override namespace if there is a namespace declaration\n                    // attribute\n                    // also lookup namespace declaration attributes\n                    var nsDeclarations = {};\n                    try {\n                        for (var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];\n                            if (attName === \"xmlns\") {\n                                namespace = attValue;\n                            }\n                            else {\n                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];\n                                if (attPrefix === \"xmlns\") {\n                                    if (attLocalName === prefix) {\n                                        namespace = attValue;\n                                    }\n                                    nsDeclarations[attLocalName] = attValue;\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    // create the DOM element node\n                    var elementNode = (namespace !== null ?\n                        doc.createElementNS(namespace, element.name) :\n                        doc.createElement(element.name));\n                    context.appendChild(elementNode);\n                    // assign attributes\n                    var localNameSet = new LocalNameSet_1.LocalNameSet();\n                    try {\n                        for (var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];\n                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];\n                            var attNamespace = null;\n                            if (attPrefix === \"xmlns\" || (attPrefix === null && attLocalName === \"xmlns\")) {\n                                // namespace declaration attribute\n                                attNamespace = infra_1.namespace.XMLNS;\n                            }\n                            else {\n                                attNamespace = elementNode.lookupNamespaceURI(attPrefix);\n                                if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {\n                                    attNamespace = null;\n                                }\n                                else if (attNamespace === null && attPrefix !== null) {\n                                    attNamespace = nsDeclarations[attPrefix] || null;\n                                }\n                            }\n                            if (localNameSet.has(attNamespace, attLocalName)) {\n                                throw new Error(\"Element contains duplicate attributes.\");\n                            }\n                            localNameSet.set(attNamespace, attLocalName);\n                            if (attNamespace === infra_1.namespace.XMLNS) {\n                                if (attValue === infra_1.namespace.XMLNS) {\n                                    throw new Error(\"XMLNS namespace is reserved.\");\n                                }\n                            }\n                            if (attLocalName.indexOf(\":\") !== -1 || !algorithm_1.xml_isName(attLocalName)) {\n                                throw new Error(\"Attribute local name contains invalid characters.\");\n                            }\n                            if (attPrefix === \"xmlns\" && attValue === \"\") {\n                                throw new Error(\"Empty XML namespace is not allowed.\");\n                            }\n                            if (attNamespace !== null)\n                                elementNode.setAttributeNS(attNamespace, attName, attValue);\n                            else\n                                elementNode.setAttribute(attName, attValue);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    if (!element.selfClosing) {\n                        context = elementNode;\n                    }\n                    break;\n                case interfaces_1.TokenType.ClosingTag:\n                    var closingTag = token;\n                    if (closingTag.name !== context.nodeName) {\n                        throw new Error('Closing tag name does not match opening tag name.');\n                    }\n                    /* istanbul ignore else */\n                    if (context._parent) {\n                        context = context._parent;\n                    }\n                    break;\n            }\n            token = lexer.nextToken();\n        }\n        return doc;\n    };\n    return XMLParserImpl;\n}());\nexports.XMLParserImpl = XMLParserImpl;\n//# sourceMappingURL=XMLParserImpl.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"./interfaces\");\n/**\n * Represents a lexer for XML content in a string.\n */\nvar XMLStringLexer = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `XMLStringLexer`.\n     *\n     * @param str - the string to tokenize and lex\n     * @param options - lexer options\n     */\n    function XMLStringLexer(str, options) {\n        this._options = {\n            skipWhitespaceOnlyText: false\n        };\n        this.err = { line: -1, col: -1, index: -1, str: \"\" };\n        this._str = str;\n        this._index = 0;\n        this._length = str.length;\n        if (options) {\n            this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;\n        }\n    }\n    /**\n     * Returns the next token.\n     */\n    XMLStringLexer.prototype.nextToken = function () {\n        if (this.eof()) {\n            return { type: interfaces_1.TokenType.EOF };\n        }\n        var token = (this.skipIfStartsWith('<') ? this.openBracket() : this.text());\n        if (this._options.skipWhitespaceOnlyText) {\n            if (token.type === interfaces_1.TokenType.Text &&\n                XMLStringLexer.isWhiteSpaceToken(token)) {\n                token = this.nextToken();\n            }\n        }\n        return token;\n    };\n    /**\n     * Branches from an opening bracket (`<`).\n     */\n    XMLStringLexer.prototype.openBracket = function () {\n        if (this.skipIfStartsWith('?')) {\n            if (this.skipIfStartsWith('xml')) {\n                if (XMLStringLexer.isSpace(this._str[this._index])) {\n                    return this.declaration();\n                }\n                else {\n                    // a processing instruction starting with xml. e.g. <?xml-stylesheet href=\"doc.xsl\" type=\"text/xsl\"?>\n                    this.seek(-3);\n                    return this.pi();\n                }\n            }\n            else {\n                return this.pi();\n            }\n        }\n        else if (this.skipIfStartsWith('!')) {\n            if (this.skipIfStartsWith('--')) {\n                return this.comment();\n            }\n            else if (this.skipIfStartsWith('[CDATA[')) {\n                return this.cdata();\n            }\n            else if (this.skipIfStartsWith('DOCTYPE')) {\n                return this.doctype();\n            }\n            else {\n                this.throwError(\"Invalid '!' in opening tag.\");\n            }\n        }\n        else if (this.skipIfStartsWith('/')) {\n            return this.closeTag();\n        }\n        else {\n            return this.openTag();\n        }\n    };\n    /**\n     * Produces an XML declaration token.\n     */\n    XMLStringLexer.prototype.declaration = function () {\n        var version = '';\n        var encoding = '';\n        var standalone = '';\n        while (!this.eof()) {\n            this.skipSpace();\n            if (this.skipIfStartsWith('?>')) {\n                return { type: interfaces_1.TokenType.Declaration, version: version, encoding: encoding, standalone: standalone };\n            }\n            else {\n                // attribute name\n                var _a = __read(this.attribute(), 2), attName = _a[0], attValue = _a[1];\n                if (attName === 'version')\n                    version = attValue;\n                else if (attName === 'encoding')\n                    encoding = attValue;\n                else if (attName === 'standalone')\n                    standalone = attValue;\n                else\n                    this.throwError('Invalid attribute name: ' + attName);\n            }\n        }\n        this.throwError('Missing declaration end symbol `?>`');\n    };\n    /**\n     * Produces a doc type token.\n     */\n    XMLStringLexer.prototype.doctype = function () {\n        var pubId = '';\n        var sysId = '';\n        // name\n        this.skipSpace();\n        var name = this.takeUntil2('[', '>', true);\n        this.skipSpace();\n        if (this.skipIfStartsWith('PUBLIC')) {\n            pubId = this.quotedString();\n            sysId = this.quotedString();\n        }\n        else if (this.skipIfStartsWith('SYSTEM')) {\n            sysId = this.quotedString();\n        }\n        // skip internal subset\n        this.skipSpace();\n        if (this.skipIfStartsWith('[')) {\n            // skip internal subset nodes\n            this.skipUntil(']');\n            if (!this.skipIfStartsWith(']')) {\n                this.throwError('Missing end bracket of DTD internal subset');\n            }\n        }\n        this.skipSpace();\n        if (!this.skipIfStartsWith('>')) {\n            this.throwError('Missing doctype end symbol `>`');\n        }\n        return { type: interfaces_1.TokenType.DocType, name: name, pubId: pubId, sysId: sysId };\n    };\n    /**\n     * Produces a processing instruction token.\n     */\n    XMLStringLexer.prototype.pi = function () {\n        var target = this.takeUntilStartsWith('?>', true);\n        if (this.eof()) {\n            this.throwError('Missing processing instruction end symbol `?>`');\n        }\n        this.skipSpace();\n        if (this.skipIfStartsWith('?>')) {\n            return { type: interfaces_1.TokenType.PI, target: target, data: '' };\n        }\n        var data = this.takeUntilStartsWith('?>');\n        if (this.eof()) {\n            this.throwError('Missing processing instruction end symbol `?>`');\n        }\n        this.seek(2);\n        return { type: interfaces_1.TokenType.PI, target: target, data: data };\n    };\n    /**\n     * Produces a text token.\n     *\n     */\n    XMLStringLexer.prototype.text = function () {\n        var data = this.takeUntil('<');\n        return { type: interfaces_1.TokenType.Text, data: data };\n    };\n    /**\n     * Produces a comment token.\n     *\n     */\n    XMLStringLexer.prototype.comment = function () {\n        var data = this.takeUntilStartsWith('-->');\n        if (this.eof()) {\n            this.throwError('Missing comment end symbol `-->`');\n        }\n        this.seek(3);\n        return { type: interfaces_1.TokenType.Comment, data: data };\n    };\n    /**\n     * Produces a CDATA token.\n     *\n     */\n    XMLStringLexer.prototype.cdata = function () {\n        var data = this.takeUntilStartsWith(']]>');\n        if (this.eof()) {\n            this.throwError('Missing CDATA end symbol `]>`');\n        }\n        this.seek(3);\n        return { type: interfaces_1.TokenType.CDATA, data: data };\n    };\n    /**\n     * Produces an element token.\n     */\n    XMLStringLexer.prototype.openTag = function () {\n        // element name\n        this.skipSpace();\n        var name = this.takeUntil2('>', '/', true);\n        this.skipSpace();\n        if (this.skipIfStartsWith('>')) {\n            return { type: interfaces_1.TokenType.Element, name: name, attributes: [], selfClosing: false };\n        }\n        else if (this.skipIfStartsWith('/>')) {\n            return { type: interfaces_1.TokenType.Element, name: name, attributes: [], selfClosing: true };\n        }\n        // attributes\n        var attributes = [];\n        while (!this.eof()) {\n            // end tag\n            this.skipSpace();\n            if (this.skipIfStartsWith('>')) {\n                return { type: interfaces_1.TokenType.Element, name: name, attributes: attributes, selfClosing: false };\n            }\n            else if (this.skipIfStartsWith('/>')) {\n                return { type: interfaces_1.TokenType.Element, name: name, attributes: attributes, selfClosing: true };\n            }\n            var attr = this.attribute();\n            attributes.push(attr);\n        }\n        this.throwError('Missing opening element tag end symbol `>`');\n    };\n    /**\n     * Produces a closing tag token.\n     *\n     */\n    XMLStringLexer.prototype.closeTag = function () {\n        this.skipSpace();\n        var name = this.takeUntil('>', true);\n        this.skipSpace();\n        if (!this.skipIfStartsWith('>')) {\n            this.throwError('Missing closing element tag end symbol `>`');\n        }\n        return { type: interfaces_1.TokenType.ClosingTag, name: name };\n    };\n    /**\n     * Reads an attribute name, value pair\n     */\n    XMLStringLexer.prototype.attribute = function () {\n        // attribute name\n        this.skipSpace();\n        var name = this.takeUntil('=', true);\n        this.skipSpace();\n        if (!this.skipIfStartsWith('=')) {\n            this.throwError('Missing equals sign before attribute value');\n        }\n        // attribute value\n        var value = this.quotedString();\n        return [name, value];\n    };\n    /**\n     * Reads a string between double or single quotes.\n     */\n    XMLStringLexer.prototype.quotedString = function () {\n        this.skipSpace();\n        var startQuote = this.take(1);\n        if (!XMLStringLexer.isQuote(startQuote)) {\n            this.throwError('Missing start quote character before quoted value');\n        }\n        var value = this.takeUntil(startQuote);\n        if (!this.skipIfStartsWith(startQuote)) {\n            this.throwError('Missing end quote character after quoted value');\n        }\n        return value;\n    };\n    /**\n     * Determines if the current index is at or past the end of input string.\n     */\n    XMLStringLexer.prototype.eof = function () { return this._index >= this._length; };\n    /**\n     * Skips the length of the given string if the string from current position\n     * starts with the given string.\n     *\n     * @param str - the string to match\n     */\n    XMLStringLexer.prototype.skipIfStartsWith = function (str) {\n        var strLength = str.length;\n        if (strLength === 1) {\n            if (this._str[this._index] === str) {\n                this._index++;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        for (var i = 0; i < strLength; i++) {\n            if (this._str[this._index + i] !== str[i])\n                return false;\n        }\n        this._index += strLength;\n        return true;\n    };\n    /**\n     * Seeks a number of character codes.\n     *\n     * @param count - number of characters to skip\n     */\n    XMLStringLexer.prototype.seek = function (count) {\n        this._index += count;\n        if (this._index < 0)\n            this._index = 0;\n        if (this._index > this._length)\n            this._index = this._length;\n    };\n    /**\n     * Skips space characters.\n     */\n    XMLStringLexer.prototype.skipSpace = function () {\n        while (!this.eof() && (XMLStringLexer.isSpace(this._str[this._index]))) {\n            this._index++;\n        }\n    };\n    /**\n     * Takes a given number of characters.\n     *\n     * @param count - character count\n     */\n    XMLStringLexer.prototype.take = function (count) {\n        if (count === 1) {\n            return this._str[this._index++];\n        }\n        var startIndex = this._index;\n        this.seek(count);\n        return this._str.slice(startIndex, this._index);\n    };\n    /**\n     * Takes characters until the next character matches `char`.\n     *\n     * @param char - a character to match\n     * @param space - whether a space character stops iteration\n     */\n    XMLStringLexer.prototype.takeUntil = function (char, space) {\n        if (space === void 0) { space = false; }\n        var startIndex = this._index;\n        while (this._index < this._length) {\n            var c = this._str[this._index];\n            if (c !== char && (!space || !XMLStringLexer.isSpace(c))) {\n                this._index++;\n            }\n            else {\n                break;\n            }\n        }\n        return this._str.slice(startIndex, this._index);\n    };\n    /**\n     * Takes characters until the next character matches `char1` or `char1`.\n     *\n     * @param char1 - a character to match\n     * @param char2 - a character to match\n     * @param space - whether a space character stops iteration\n     */\n    XMLStringLexer.prototype.takeUntil2 = function (char1, char2, space) {\n        if (space === void 0) { space = false; }\n        var startIndex = this._index;\n        while (this._index < this._length) {\n            var c = this._str[this._index];\n            if (c !== char1 && c !== char2 && (!space || !XMLStringLexer.isSpace(c))) {\n                this._index++;\n            }\n            else {\n                break;\n            }\n        }\n        return this._str.slice(startIndex, this._index);\n    };\n    /**\n     * Takes characters until the next characters matches `str`.\n     *\n     * @param str - a string to match\n     * @param space - whether a space character stops iteration\n     */\n    XMLStringLexer.prototype.takeUntilStartsWith = function (str, space) {\n        if (space === void 0) { space = false; }\n        var startIndex = this._index;\n        var strLength = str.length;\n        while (this._index < this._length) {\n            var match = true;\n            for (var i = 0; i < strLength; i++) {\n                var c = this._str[this._index + i];\n                var char = str[i];\n                if (space && XMLStringLexer.isSpace(c)) {\n                    return this._str.slice(startIndex, this._index);\n                }\n                else if (c !== char) {\n                    this._index++;\n                    match = false;\n                    break;\n                }\n            }\n            if (match)\n                return this._str.slice(startIndex, this._index);\n        }\n        this._index = this._length;\n        return this._str.slice(startIndex);\n    };\n    /**\n     * Skips characters until the next character matches `char`.\n     *\n     * @param char - a character to match\n     */\n    XMLStringLexer.prototype.skipUntil = function (char) {\n        while (this._index < this._length) {\n            var c = this._str[this._index];\n            if (c !== char) {\n                this._index++;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Determines if the given token is entirely whitespace.\n     *\n     * @param token - the token to check\n     */\n    XMLStringLexer.isWhiteSpaceToken = function (token) {\n        var str = token.data;\n        for (var i = 0; i < str.length; i++) {\n            var c = str[i];\n            if (c !== ' ' && c !== '\\n' && c !== '\\r' && c !== '\\t' && c !== '\\f')\n                return false;\n        }\n        return true;\n    };\n    /**\n     * Determines if the given character is whitespace.\n     *\n     * @param char - the character to check\n     */\n    XMLStringLexer.isSpace = function (char) {\n        return char === ' ' || char === '\\n' || char === '\\r' || char === '\\t';\n    };\n    /**\n     * Determines if the given character is a quote character.\n     *\n     * @param char - the character to check\n     */\n    XMLStringLexer.isQuote = function (char) {\n        return (char === '\"' || char === '\\'');\n    };\n    /**\n     * Throws a parser error and records the line and column numbers in the parsed\n     * string.\n     *\n     * @param msg - error message\n     */\n    XMLStringLexer.prototype.throwError = function (msg) {\n        var regexp = /\\r\\n|\\r|\\n/g;\n        var match = null;\n        var line = 0;\n        var firstNewLineIndex = 0;\n        var lastNewlineIndex = this._str.length;\n        while ((match = regexp.exec(this._str)) !== null) {\n            if (match === null)\n                break;\n            line++;\n            if (match.index < this._index)\n                firstNewLineIndex = regexp.lastIndex;\n            if (match.index > this._index) {\n                lastNewlineIndex = match.index;\n                break;\n            }\n        }\n        this.err = {\n            line: line,\n            col: this._index - firstNewLineIndex,\n            index: this._index,\n            str: this._str.substring(firstNewLineIndex, lastNewlineIndex)\n        };\n        throw new Error(msg + \"\\nIndex: \" + this.err.index +\n            \"\\nLn: \" + this.err.line + \", Col: \" + this.err.col +\n            \"\\nInput: \" + this.err.str);\n    };\n    /**\n     * Returns an iterator for the lexer.\n     */\n    XMLStringLexer.prototype[Symbol.iterator] = function () {\n        this._index = 0;\n        return {\n            next: function () {\n                var token = this.nextToken();\n                if (token.type === interfaces_1.TokenType.EOF) {\n                    return { done: true, value: null };\n                }\n                else {\n                    return { done: false, value: token };\n                }\n            }.bind(this)\n        };\n    };\n    return XMLStringLexer;\n}());\nexports.XMLStringLexer = XMLStringLexer;\n//# sourceMappingURL=XMLStringLexer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Export classes\nvar DOMParserImpl_1 = require(\"./DOMParserImpl\");\nexports.DOMParser = DOMParserImpl_1.DOMParserImpl;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines the type of a token.\n */\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"EOF\"] = 0] = \"EOF\";\n    TokenType[TokenType[\"Declaration\"] = 1] = \"Declaration\";\n    TokenType[TokenType[\"DocType\"] = 2] = \"DocType\";\n    TokenType[TokenType[\"Element\"] = 3] = \"Element\";\n    TokenType[TokenType[\"Text\"] = 4] = \"Text\";\n    TokenType[TokenType[\"CDATA\"] = 5] = \"CDATA\";\n    TokenType[TokenType[\"PI\"] = 6] = \"PI\";\n    TokenType[TokenType[\"Comment\"] = 7] = \"Comment\";\n    TokenType[TokenType[\"ClosingTag\"] = 8] = \"ClosingTag\";\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a set of unique attribute namespaceURI and localName pairs.\n * This set will contain tuples of unique attribute namespaceURI and\n * localName pairs, and is populated as each attr is processed. This set is\n * used to [optionally] enforce the well-formed constraint that an element\n * cannot have two attributes with the same namespaceURI and localName.\n * This can occur when two otherwise identical attributes on the same\n * element differ only by their prefix values.\n */\nvar LocalNameSet = /** @class */ (function () {\n    function LocalNameSet() {\n        // tuple storage\n        this._items = {};\n        this._nullItems = {};\n    }\n    /**\n     * Adds or replaces a tuple.\n     *\n     * @param ns - namespace URI\n     * @param localName - attribute local name\n     */\n    LocalNameSet.prototype.set = function (ns, localName) {\n        if (ns === null) {\n            this._nullItems[localName] = true;\n        }\n        else if (this._items[ns]) {\n            this._items[ns][localName] = true;\n        }\n        else {\n            this._items[ns] = {};\n            this._items[ns][localName] = true;\n        }\n    };\n    /**\n     * Determines if the given tuple exists in the set.\n     *\n     * @param ns - namespace URI\n     * @param localName - attribute local name\n     */\n    LocalNameSet.prototype.has = function (ns, localName) {\n        if (ns === null) {\n            return this._nullItems[localName] === true;\n        }\n        else if (this._items[ns]) {\n            return this._items[ns][localName] === true;\n        }\n        else {\n            return false;\n        }\n    };\n    return LocalNameSet;\n}());\nexports.LocalNameSet = LocalNameSet;\n//# sourceMappingURL=LocalNameSet.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A namespace prefix map is a map that associates namespaceURI and namespace\n * prefix lists, where namespaceURI values are the map's unique keys (which can\n * include the null value representing no namespace), and ordered lists of\n * associated prefix values are the map's key values. The namespace prefix map\n * will be populated by previously seen namespaceURIs and all their previously\n * encountered prefix associations for a given node and its ancestors.\n *\n * _Note:_ The last seen prefix for a given namespaceURI is at the end of its\n * respective list. The list is searched to find potentially matching prefixes,\n * and if no matches are found for the given namespaceURI, then the last prefix\n * in the list is used. See copy a namespace prefix map and retrieve a preferred\n * prefix string for additional details.\n *\n * See: https://w3c.github.io/DOM-Parsing/#the-namespace-prefix-map\n */\nvar NamespacePrefixMap = /** @class */ (function () {\n    function NamespacePrefixMap() {\n        this._items = {};\n        this._nullItems = [];\n    }\n    /**\n     * Creates a copy of the map.\n     */\n    NamespacePrefixMap.prototype.copy = function () {\n        /**\n         * To copy a namespace prefix map map means to copy the map's keys into a\n         * new empty namespace prefix map, and to copy each of the values in the\n         * namespace prefix list associated with each keys' value into a new list\n         * which should be associated with the respective key in the new map.\n         */\n        var mapCopy = new NamespacePrefixMap();\n        for (var key in this._items) {\n            mapCopy._items[key] = this._items[key].slice(0);\n        }\n        mapCopy._nullItems = this._nullItems.slice(0);\n        return mapCopy;\n    };\n    /**\n     * Retrieves a preferred prefix string from the namespace prefix map.\n     *\n     * @param preferredPrefix - preferred prefix string\n     * @param ns - namespace\n     */\n    NamespacePrefixMap.prototype.get = function (preferredPrefix, ns) {\n        /**\n         * 1. Let candidates list be the result of retrieving a list from map where\n         * there exists a key in map that matches the value of ns or if there is no\n         * such key, then stop running these steps, and return the null value.\n         */\n        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);\n        if (candidatesList === null) {\n            return null;\n        }\n        /**\n         * 2. Otherwise, for each prefix value prefix in candidates list, iterating\n         * from beginning to end:\n         *\n         * _Note:_ There will always be at least one prefix value in the list.\n         */\n        var prefix = null;\n        for (var i = 0; i < candidatesList.length; i++) {\n            prefix = candidatesList[i];\n            /**\n             * 2.1. If prefix matches preferred prefix, then stop running these steps\n             * and return prefix.\n             */\n            if (prefix === preferredPrefix) {\n                return prefix;\n            }\n        }\n        /**\n        * 2.2. If prefix is the last item in the candidates list, then stop\n        * running these steps and return prefix.\n        */\n        return prefix;\n    };\n    /**\n     * Checks if a prefix string is found in the namespace prefix map associated\n     * with the given namespace.\n     *\n     * @param prefix - prefix string\n     * @param ns - namespace\n     */\n    NamespacePrefixMap.prototype.has = function (prefix, ns) {\n        /**\n         * 1. Let candidates list be the result of retrieving a list from map where\n         * there exists a key in map that matches the value of ns or if there is\n         * no such key, then stop running these steps, and return false.\n         */\n        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);\n        if (candidatesList === null) {\n            return false;\n        }\n        /**\n         * 2. If the value of prefix occurs at least once in candidates list,\n         * return true, otherwise return false.\n         */\n        return (candidatesList.indexOf(prefix) !== -1);\n    };\n    /**\n     * Checks if a prefix string is found in the namespace prefix map.\n     *\n     * @param prefix - prefix string\n     */\n    NamespacePrefixMap.prototype.hasPrefix = function (prefix) {\n        if (this._nullItems.indexOf(prefix) !== -1)\n            return true;\n        for (var key in this._items) {\n            if (this._items[key].indexOf(prefix) !== -1)\n                return true;\n        }\n        return false;\n    };\n    /**\n     * Adds a prefix string associated with a namespace to the prefix map.\n     *\n     * @param prefix - prefix string\n     * @param ns - namespace\n     */\n    NamespacePrefixMap.prototype.set = function (prefix, ns) {\n        /**\n         * 1. Let candidates list be the result of retrieving a list from map where\n         * there exists a key in map that matches the value of ns or if there is\n         * no such key, then let candidates list be null.\n         */\n        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);\n        /**\n         * 2. If candidates list is null, then create a new list with prefix as the\n         * only item in the list, and associate that list with a new key ns in map.\n         * 3. Otherwise, append prefix to the end of candidates list.\n         *\n         * _Note:_ The steps in retrieve a preferred prefix string use the list to\n         * track the most recently used (MRU) prefix associated with a given\n         * namespace, which will be the prefix at the end of the list. This list\n         * may contain duplicates of the same prefix value seen earlier\n         * (and that's OK).\n         */\n        if (ns !== null && candidatesList === null) {\n            this._items[ns] = [prefix];\n        }\n        else {\n            candidatesList.push(prefix);\n        }\n    };\n    return NamespacePrefixMap;\n}());\nexports.NamespacePrefixMap = NamespacePrefixMap;\n//# sourceMappingURL=NamespacePrefixMap.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../dom/interfaces\");\nvar LocalNameSet_1 = require(\"./LocalNameSet\");\nvar NamespacePrefixMap_1 = require(\"./NamespacePrefixMap\");\nvar DOMException_1 = require(\"../dom/DOMException\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"../algorithm\");\n/**\n * Represents an XML serializer.\n *\n * Implements: https://www.w3.org/TR/DOM-Parsing/#serializing\n */\nvar XMLSerializerImpl = /** @class */ (function () {\n    function XMLSerializerImpl() {\n    }\n    /** @inheritdoc */\n    XMLSerializerImpl.prototype.serializeToString = function (root) {\n        /**\n         * The serializeToString(root) method must produce an XML serialization\n         * of root passing a value of false for the require well-formed parameter,\n         * and return the result.\n         */\n        return this._xmlSerialization(root, false);\n    };\n    /**\n     * Produces an XML serialization of the given node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._xmlSerialization = function (node, requireWellFormed) {\n        // To increase performance, use a namespace-aware serializer only if the\n        // document has namespaced elements\n        if (node._nodeDocument === undefined || node._nodeDocument._hasNamespaces) {\n            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization\n             *\n             * 1. Let namespace be a context namespace with value null.\n             * The context namespace tracks the XML serialization algorithm's current\n             * default namespace. The context namespace is changed when either an Element\n             * Node has a default namespace declaration, or the algorithm generates a\n             * default namespace declaration for the Element Node to match its own\n             * namespace. The algorithm assumes no namespace (null) to start.\n             * 2. Let prefix map be a new namespace prefix map.\n             * 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n             * 4. Let prefix index be a generated namespace prefix index with value 1.\n             * The generated namespace prefix index is used to generate a new unique\n             * prefix value when no suitable existing namespace prefix is available to\n             * serialize a node's namespaceURI (or the namespaceURI of one of node's\n             * attributes). See the generate a prefix algorithm.\n             */\n            var namespace = null;\n            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();\n            prefixMap.set(\"xml\", infra_1.namespace.XML);\n            var prefixIndex = { value: 1 };\n            /**\n             * 5. Return the result of running the XML serialization algorithm on node\n             * passing the context namespace namespace, namespace prefix map prefix map,\n             * generated namespace prefix index reference to prefix index, and the\n             * flag require well-formed. If an exception occurs during the execution\n             * of the algorithm, then catch that exception and throw an\n             * \"InvalidStateError\" DOMException.\n             */\n            try {\n                return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);\n            }\n            catch (_a) {\n                throw new DOMException_1.InvalidStateError();\n            }\n        }\n        else {\n            try {\n                return this._serializeNode(node, requireWellFormed);\n            }\n            catch (_b) {\n                throw new DOMException_1.InvalidStateError();\n            }\n        }\n    };\n    /**\n     * Produces an XML serialization of a node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeNodeNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {\n        switch (node.nodeType) {\n            case interfaces_1.NodeType.Element:\n                return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);\n            case interfaces_1.NodeType.Document:\n                return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);\n            case interfaces_1.NodeType.Comment:\n                return this._serializeComment(node, requireWellFormed);\n            case interfaces_1.NodeType.Text:\n                return this._serializeText(node, requireWellFormed);\n            case interfaces_1.NodeType.DocumentFragment:\n                return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);\n            case interfaces_1.NodeType.DocumentType:\n                return this._serializeDocumentType(node, requireWellFormed);\n            case interfaces_1.NodeType.ProcessingInstruction:\n                return this._serializeProcessingInstruction(node, requireWellFormed);\n            case interfaces_1.NodeType.CData:\n                return this._serializeCData(node, requireWellFormed);\n            default:\n                throw new Error(\"Unknown node type: \" + node.nodeType);\n        }\n    };\n    /**\n     * Produces an XML serialization of a node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeNode = function (node, requireWellFormed) {\n        switch (node.nodeType) {\n            case interfaces_1.NodeType.Element:\n                return this._serializeElement(node, requireWellFormed);\n            case interfaces_1.NodeType.Document:\n                return this._serializeDocument(node, requireWellFormed);\n            case interfaces_1.NodeType.Comment:\n                return this._serializeComment(node, requireWellFormed);\n            case interfaces_1.NodeType.Text:\n                return this._serializeText(node, requireWellFormed);\n            case interfaces_1.NodeType.DocumentFragment:\n                return this._serializeDocumentFragment(node, requireWellFormed);\n            case interfaces_1.NodeType.DocumentType:\n                return this._serializeDocumentType(node, requireWellFormed);\n            case interfaces_1.NodeType.ProcessingInstruction:\n                return this._serializeProcessingInstruction(node, requireWellFormed);\n            case interfaces_1.NodeType.CData:\n                return this._serializeCData(node, requireWellFormed);\n            default:\n                throw new Error(\"Unknown node type: \" + node.nodeType);\n        }\n    };\n    /**\n     * Produces an XML serialization of an element node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeElementNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {\n        var e_1, _a;\n        /**\n         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node\n         *\n         * 1. If the require well-formed flag is set (its value is true), and this\n         * node's localName attribute contains the character \":\" (U+003A COLON) or\n         * does not match the XML Name production, then throw an exception; the\n         * serialization of this node would not be a well-formed element.\n         */\n        if (requireWellFormed && (node.localName.indexOf(\":\") !== -1 ||\n            !algorithm_1.xml_isName(node.localName))) {\n            throw new Error(\"Node local name contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n         * 3. Let qualified name be an empty string.\n         * 4. Let skip end tag be a boolean flag with value false.\n         * 5. Let ignore namespace definition attribute be a boolean flag with value\n         * false.\n         * 6. Given prefix map, copy a namespace prefix map and let map be the\n         * result.\n         * 7. Let local prefixes map be an empty map. The map has unique Node prefix\n         * strings as its keys, with corresponding namespaceURI Node values as the\n         * map's key values (in this map, the null namespace is represented by the\n         * empty string).\n         *\n         * _Note:_ This map is local to each element. It is used to ensure there\n         * are no conflicting prefixes should a new namespace prefix attribute need\n         * to be generated. It is also used to enable skipping of duplicate prefix\n         * definitions when writing an element's attributes: the map allows the\n         * algorithm to distinguish between a prefix in the namespace prefix map\n         * that might be locally-defined (to the current Element) and one that is\n         * not.\n         * 8. Let local default namespace be the result of recording the namespace\n         * information for node given map and local prefixes map.\n         *\n         * _Note:_ The above step will update map with any found namespace prefix\n         * definitions, add the found prefix definitions to the local prefixes map\n         * and return a local default namespace value defined by a default namespace\n         * attribute if one exists. Otherwise it returns null.\n         * 9. Let inherited ns be a copy of namespace.\n         * 10. Let ns be the value of node's namespaceURI attribute.\n         */\n        var markup = \"<\";\n        var qualifiedName = '';\n        var skipEndTag = false;\n        var ignoreNamespaceDefinitionAttribute = false;\n        var map = prefixMap.copy();\n        var localPrefixesMap = {};\n        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);\n        var inheritedNS = namespace;\n        var ns = node.namespaceURI;\n        /** 11. If inherited ns is equal to ns, then: */\n        if (inheritedNS === ns) {\n            /**\n             * 11.1. If local default namespace is not null, then set ignore\n             * namespace definition attribute to true.\n             */\n            if (localDefaultNamespace !== null) {\n                ignoreNamespaceDefinitionAttribute = true;\n            }\n            /**\n             * 11.2. If ns is the XML namespace, then append to qualified name the\n             * concatenation of the string \"xml:\" and the value of node's localName.\n             * 11.3. Otherwise, append to qualified name the value of node's\n             * localName. The node's prefix if it exists, is dropped.\n             */\n            if (ns === infra_1.namespace.XML) {\n                qualifiedName = 'xml:' + node.localName;\n            }\n            else {\n                qualifiedName = node.localName;\n            }\n            /** 11.4. Append the value of qualified name to markup. */\n            markup += qualifiedName;\n        }\n        else {\n            /**\n             * 12. Otherwise, inherited ns is not equal to ns (the node's own\n             * namespace is different from the context namespace of its parent).\n             * Run these sub-steps:\n             *\n             * 12.1. Let prefix be the value of node's prefix attribute.\n             * 12.2. Let candidate prefix be the result of retrieving a preferred\n             * prefix string prefix from map given namespace ns. The above may return\n             * null if no namespace key ns exists in map.\n             */\n            var prefix = node.prefix;\n            /**\n             * We don't need to run \"retrieving a preferred prefix string\" algorithm if\n             * the element has no prefix and its namespace matches to the default\n             * namespace.\n             * See: https://github.com/web-platform-tests/wpt/pull/16703\n             */\n            var candidatePrefix = null;\n            if (prefix !== null || ns !== localDefaultNamespace) {\n                candidatePrefix = map.get(prefix, ns);\n            }\n            /**\n             * 12.3. If the value of prefix matches \"xmlns\", then run the following\n             * steps:\n             */\n            if (prefix === \"xmlns\") {\n                /**\n                 * 12.3.1. If the require well-formed flag is set, then throw an error.\n                 * An Element with prefix \"xmlns\" will not legally round-trip in a\n                 * conforming XML parser.\n                 */\n                if (requireWellFormed) {\n                    throw new Error(\"An element cannot have the 'xmlns' prefix (well-formed required).\");\n                }\n                /**\n                 * 12.3.2. Let candidate prefix be the value of prefix.\n                 */\n                candidatePrefix = prefix;\n            }\n            /**\n             * 12.4.Found a suitable namespace prefix: if candidate prefix is not\n             * null (a namespace prefix is defined which maps to ns), then:\n             */\n            if (candidatePrefix !== null) {\n                /**\n                 * The following may serialize a different prefix than the Element's\n                 * existing prefix if it already had one. However, the retrieving a\n                 * preferred prefix string algorithm already tried to match the\n                 * existing prefix if possible.\n                 *\n                 * 12.4.1. Append to qualified name the concatenation of candidate\n                 * prefix, \":\" (U+003A COLON), and node's localName. There exists on\n                 * this node or the node's ancestry a namespace prefix definition that\n                 * defines the node's namespace.\n                 * 12.4.2. If the local default namespace is not null (there exists a\n                 * locally-defined default namespace declaration attribute) and its\n                 * value is not the XML namespace, then let inherited ns get the value\n                 * of local default namespace unless the local default namespace is the\n                 * empty string in which case let it get null (the context namespace\n                 * is changed to the declared default, rather than this node's own\n                 * namespace).\n                 *\n                 * _Note:_ Any default namespace definitions or namespace prefixes that\n                 * define the XML namespace are omitted when serializing this node's\n                 * attributes.\n                 */\n                qualifiedName = candidatePrefix + ':' + node.localName;\n                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {\n                    inheritedNS = localDefaultNamespace || null;\n                }\n                /**\n                 * 12.4.3. Append the value of qualified name to markup.\n                 */\n                markup += qualifiedName;\n                /** 12.5. Otherwise, if prefix is not null, then: */\n            }\n            else if (prefix !== null) {\n                /**\n                 * _Note:_ By this step, there is no namespace or prefix mapping\n                 * declaration in this node (or any parent node visited by this\n                 * algorithm) that defines prefix otherwise the step labelled Found\n                 * a suitable namespace prefix would have been followed. The sub-steps\n                 * that follow will create a new namespace prefix declaration for prefix\n                 * and ensure that prefix does not conflict with an existing namespace\n                 * prefix declaration of the same localName in node's attribute list.\n                 *\n                 * 12.5.1. If the local prefixes map contains a key matching prefix,\n                 * then let prefix be the result of generating a prefix providing as\n                 * input map, ns, and prefix index.\n                 */\n                if (prefix in localPrefixesMap) {\n                    prefix = this._generatePrefix(ns, map, prefixIndex);\n                }\n                /**\n                 * 12.5.2. Add prefix to map given namespace ns.\n                 * 12.5.3. Append to qualified name the concatenation of prefix, \":\"\n                 * (U+003A COLON), and node's localName.\n                 * 12.5.4. Append the value of qualified name to markup.\n                 */\n                map.set(prefix, ns);\n                qualifiedName += prefix + ':' + node.localName;\n                markup += qualifiedName;\n                /**\n                 * 12.5.5. Append the following to markup, in the order listed:\n                 *\n                 * _Note:_ The following serializes a namespace prefix declaration for\n                 * prefix which was just added to the map.\n                 *\n                 * 12.5.5.1. \" \" (U+0020 SPACE);\n                 * 12.5.5.2. The string \"xmlns:\";\n                 * 12.5.5.3. The value of prefix;\n                 * 12.5.5.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 12.5.5.5. The result of serializing an attribute value given ns and\n                 * the require well-formed flag as input;\n                 * 12.5.5.6. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                markup += \" xmlns:\" + prefix + \"=\\\"\" +\n                    this._serializeAttributeValue(ns, requireWellFormed) + \"\\\"\";\n                /**\n                 * 12.5.5.7. If local default namespace is not null (there exists a\n                 * locally-defined default namespace declaration attribute), then\n                 * let inherited ns get the value of local default namespace unless the\n                 * local default namespace is the empty string in which case let it get\n                 * null.\n                 */\n                if (localDefaultNamespace !== null) {\n                    inheritedNS = localDefaultNamespace || null;\n                }\n                /**\n                 * 12.6. Otherwise, if local default namespace is null, or local\n                 * default namespace is not null and its value is not equal to ns, then:\n                 */\n            }\n            else if (localDefaultNamespace === null ||\n                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {\n                /**\n                 * _Note:_ At this point, the namespace for this node still needs to be\n                 * serialized, but there's no prefix (or candidate prefix) available; the\n                 * following uses the default namespace declaration to define the\n                 * namespace--optionally replacing an existing default declaration\n                 * if present.\n                 *\n                 * 12.6.1. Set the ignore namespace definition attribute flag to true.\n                 * 12.6.2. Append to qualified name the value of node's localName.\n                 * 12.6.3. Let the value of inherited ns be ns.\n                 *\n                 * _Note:_ The new default namespace will be used in the serialization\n                 * to define this node's namespace and act as the context namespace for\n                 * its children.\n                 */\n                ignoreNamespaceDefinitionAttribute = true;\n                qualifiedName += node.localName;\n                inheritedNS = ns;\n                /**\n                 * 12.6.4. Append the value of qualified name to markup.\n                 */\n                markup += qualifiedName;\n                /**\n                 * 12.6.5. Append the following to markup, in the order listed:\n                 *\n                 * _Note:_ The following serializes the new (or replacement) default\n                 * namespace definition.\n                 *\n                 * 12.6.5.1. \" \" (U+0020 SPACE);\n                 * 12.6.5.2. The string \"xmlns\";\n                 * 12.6.5.3. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 12.6.5.4. The result of serializing an attribute value given ns\n                 * and the require well-formed flag as input;\n                 * 12.6.5.5. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                markup += \" xmlns\" + \"=\\\"\" +\n                    this._serializeAttributeValue(ns, requireWellFormed) + \"\\\"\";\n                /**\n                 * 12.7. Otherwise, the node has a local default namespace that matches\n                 * ns. Append to qualified name the value of node's localName, let the\n                 * value of inherited ns be ns, and append the value of qualified name\n                 * to markup.\n                 */\n            }\n            else {\n                qualifiedName += node.localName;\n                inheritedNS = ns;\n                markup += qualifiedName;\n            }\n        }\n        /**\n         * 13. Append to markup the result of the XML serialization of node's\n         * attributes given map, prefix index, local prefixes map, ignore namespace\n         * definition attribute flag, and require well-formed flag.\n         */\n        markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);\n        /**\n         * 14. If ns is the HTML namespace, and the node's list of children is\n         * empty, and the node's localName matches any one of the following void\n         * elements: \"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"embed\",\n         * \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\",\n         * \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup,\n         * in the order listed:\n         * 14.1. \" \" (U+0020 SPACE);\n         * 14.2. \"/\" (U+002F SOLIDUS).\n         * and set the skip end tag flag to true.\n         * 15. If ns is not the HTML namespace, and the node's list of children is\n         * empty, then append \"/\" (U+002F SOLIDUS) to markup and set the skip end\n         * tag flag to true.\n         * 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n         */\n        var isHTML = (ns === infra_1.namespace.HTML);\n        if (isHTML && node.childNodes.length === 0 &&\n            XMLSerializerImpl._VoidElementNames.has(node.localName)) {\n            markup += \" /\";\n            skipEndTag = true;\n        }\n        else if (!isHTML && node.childNodes.length === 0) {\n            markup += \"/\";\n            skipEndTag = true;\n        }\n        markup += \">\";\n        /**\n         * 17. If the value of skip end tag is true, then return the value of markup\n         * and skip the remaining steps. The node is a leaf-node.\n         */\n        if (skipEndTag)\n            return markup;\n        /**\n         * 18. If ns is the HTML namespace, and the node's localName matches the\n         * string \"template\", then this is a template element. Append to markup the\n         * result of XML serializing a DocumentFragment node given the template\n         * element's template contents (a DocumentFragment), providing inherited\n         * ns, map, prefix index, and the require well-formed flag.\n         *\n         * _Note:_ This allows template content to round-trip, given the rules for\n         * parsing XHTML documents.\n         *\n         * 19. Otherwise, append to markup the result of running the XML\n         * serialization algorithm on each of node's children, in tree order,\n         * providing inherited ns, map, prefix index, and the require well-formed\n         * flag.\n         */\n        if (isHTML && node.localName === \"template\") {\n            // TODO: serialize template contents\n        }\n        else {\n            try {\n                for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var childNode = _c.value;\n                    markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        /**\n         * 20. Append the following to markup, in the order listed:\n         * 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n         * 20.2. The value of qualified name;\n         * 20.3. \">\" (U+003E GREATER-THAN SIGN).\n         */\n        markup += \"</\" + qualifiedName + \">\";\n        /**\n         * 21. Return the value of markup.\n         */\n        return markup;\n    };\n    /**\n     * Produces an XML serialization of a document node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeDocumentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {\n        var e_2, _a;\n        /**\n         * If the require well-formed flag is set (its value is true), and this node\n         * has no documentElement (the documentElement attribute's value is null),\n         * then throw an exception; the serialization of this node would not be a\n         * well-formed document.\n         */\n        if (requireWellFormed && node.documentElement === null) {\n            throw new Error(\"Missing document element (well-formed required).\");\n        }\n        /**\n         * Otherwise, run the following steps:\n         * 1. Let serialized document be an empty string.\n         * 2. For each child child of node, in tree order, run the XML\n         * serialization algorithm on the child passing along the provided\n         * arguments, and append the result to serialized document.\n         *\n         * _Note:_ This will serialize any number of ProcessingInstruction and\n         * Comment nodes both before and after the Document's documentElement node,\n         * including at most one DocumentType node. (Text nodes are not allowed as\n         * children of the Document.)\n         *\n         * 3. Return the value of serialized document.\n        */\n        var serializedDocument = \"\";\n        try {\n            for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return serializedDocument;\n    };\n    /**\n     * Produces an XML serialization of a comment node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeComment = function (node, requireWellFormed) {\n        /**\n         * If the require well-formed flag is set (its value is true), and node's\n         * data contains characters that are not matched by the XML Char production\n         * or contains \"--\" (two adjacent U+002D HYPHEN-MINUS characters) or that\n         * ends with a \"-\" (U+002D HYPHEN-MINUS) character, then throw an exception;\n         * the serialization of this node's data would not be well-formed.\n         */\n        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||\n            node.data.indexOf(\"--\") !== -1 || node.data.endsWith(\"-\"))) {\n            throw new Error(\"Comment data contains invalid characters (well-formed required).\");\n        }\n        /**\n         * Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n         */\n        return \"<!--\" + node.data + \"-->\";\n    };\n    /**\n     * Produces an XML serialization of a text node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     * @param level - current depth of the XML tree\n     */\n    XMLSerializerImpl.prototype._serializeText = function (node, requireWellFormed) {\n        /**\n         * 1. If the require well-formed flag is set (its value is true), and\n         * node's data contains characters that are not matched by the XML Char\n         * production, then throw an exception; the serialization of this node's\n         * data would not be well-formed.\n         */\n        if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {\n            throw new Error(\"Text data contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. Let markup be the value of node's data.\n         * 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n         * 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n         * 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n         * 6. Return the value of markup.\n         */\n        var result = \"\";\n        for (var i = 0; i < node.data.length; i++) {\n            var c = node.data[i];\n            if (c === \"&\")\n                result += \"&amp;\";\n            else if (c === \"<\")\n                result += \"&lt;\";\n            else if (c === \">\")\n                result += \"&gt;\";\n            else\n                result += c;\n        }\n        return result;\n    };\n    /**\n     * Produces an XML serialization of a document fragment node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeDocumentFragmentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {\n        var e_3, _a;\n        /**\n         * 1. Let markup the empty string.\n         * 2. For each child child of node, in tree order, run the XML serialization\n         * algorithm on the child given namespace, prefix map, a reference to prefix\n         * index, and flag require well-formed. Concatenate the result to markup.\n         * 3. Return the value of markup.\n         */\n        var markup = \"\";\n        try {\n            for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return markup;\n    };\n    /**\n     * Produces an XML serialization of a document type node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeDocumentType = function (node, requireWellFormed) {\n        /**\n         * 1. If the require well-formed flag is true and the node's publicId\n         * attribute contains characters that are not matched by the XML PubidChar\n         *  production, then throw an exception; the serialization of this node\n         * would not be a well-formed document type declaration.\n         */\n        if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {\n            throw new Error(\"DocType public identifier does not match PubidChar construct (well-formed required).\");\n        }\n        /**\n         * 2. If the require well-formed flag is true and the node's systemId\n         * attribute contains characters that are not matched by the XML Char\n         * production or that contains both a \"\"\" (U+0022 QUOTATION MARK) and a\n         * \"'\" (U+0027 APOSTROPHE), then throw an exception; the serialization\n         * of this node would not be a well-formed document type declaration.\n         */\n        if (requireWellFormed &&\n            (!algorithm_1.xml_isLegalChar(node.systemId) ||\n                (node.systemId.indexOf('\"') !== -1 && node.systemId.indexOf(\"'\") !== -1))) {\n            throw new Error(\"DocType system identifier contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 3. Let markup be an empty string.\n         * 4. Append the string \"<!DOCTYPE\" to markup.\n         * 5. Append \" \" (U+0020 SPACE) to markup.\n         * 6. Append the value of the node's name attribute to markup. For a node\n         * belonging to an HTML document, the value will be all lowercase.\n         * 7. If the node's publicId is not the empty string then append the\n         * following, in the order listed, to markup:\n         * 7.1. \" \" (U+0020 SPACE);\n         * 7.2. The string \"PUBLIC\";\n         * 7.3. \" \" (U+0020 SPACE);\n         * 7.4. \"\"\" (U+0022 QUOTATION MARK);\n         * 7.5. The value of the node's publicId attribute;\n         * 7.6. \"\"\" (U+0022 QUOTATION MARK).\n         * 8. If the node's systemId is not the empty string and the node's publicId\n         * is set to the empty string, then append the following, in the order\n         * listed, to markup:\n         * 8.1. \" \" (U+0020 SPACE);\n         * 8.2. The string \"SYSTEM\".\n         * 9. If the node's systemId is not the empty string then append the\n         * following, in the order listed, to markup:\n         * 9.2. \" \" (U+0020 SPACE);\n         * 9.3. \"\"\" (U+0022 QUOTATION MARK);\n         * 9.3. The value of the node's systemId attribute;\n         * 9.4. \"\"\" (U+0022 QUOTATION MARK).\n         * 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n         * 11. Return the value of markup.\n         */\n        return node.publicId && node.systemId ?\n            \"<!DOCTYPE \" + node.name + \" PUBLIC \\\"\" + node.publicId + \"\\\" \\\"\" + node.systemId + \"\\\">\"\n            : node.publicId ?\n                \"<!DOCTYPE \" + node.name + \" PUBLIC \\\"\" + node.publicId + \"\\\">\"\n                : node.systemId ?\n                    \"<!DOCTYPE \" + node.name + \" SYSTEM \\\"\" + node.systemId + \"\\\">\"\n                    :\n                        \"<!DOCTYPE \" + node.name + \">\";\n    };\n    /**\n     * Produces an XML serialization of a processing instruction node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeProcessingInstruction = function (node, requireWellFormed) {\n        /**\n         * 1. If the require well-formed flag is set (its value is true), and node's\n         * target contains a \":\" (U+003A COLON) character or is an ASCII\n         * case-insensitive match for the string \"xml\", then throw an exception;\n         * the serialization of this node's target would not be well-formed.\n         */\n        if (requireWellFormed && (node.target.indexOf(\":\") !== -1 || (/^xml$/i).test(node.target))) {\n            throw new Error(\"Processing instruction target contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. If the require well-formed flag is set (its value is true), and node's\n         * data contains characters that are not matched by the XML Char production\n         * or contains the string \"?>\" (U+003F QUESTION MARK,\n         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of\n         * this node's data would not be well-formed.\n         */\n        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||\n            node.data.indexOf(\"?>\") !== -1)) {\n            throw new Error(\"Processing instruction data contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 3. Let markup be the concatenation of the following, in the order listed:\n         * 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n         * 3.2. The value of node's target;\n         * 3.3. \" \" (U+0020 SPACE);\n         * 3.4. The value of node's data;\n         * 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n         * 4. Return the value of markup.\n         */\n        return \"<?\" + (node.data === \"\" ? node.target : node.target + \" \" + node.data) + \"?>\";\n    };\n    /**\n     * Produces an XML serialization of a CDATA node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeCData = function (node, requireWellFormed) {\n        if (requireWellFormed && (node.data.indexOf(\"]]>\") !== -1)) {\n            throw new Error(\"CDATA contains invalid characters (well-formed required).\");\n        }\n        return \"<![CDATA[\" + node.data + \"]]>\";\n    };\n    /**\n    * Produces an XML serialization of the attributes of an element node.\n    *\n     * @param node - node to serialize\n     * @param map - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param localPrefixesMap - local prefixes map\n     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace\n     * attributes\n     * @param requireWellFormed - whether to check conformance\n    */\n    XMLSerializerImpl.prototype._serializeAttributesNS = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {\n        var e_4, _a;\n        /**\n         * 1. Let result be the empty string.\n         * 2. Let localname set be a new empty namespace localname set. This\n         * localname set will contain tuples of unique attribute namespaceURI and\n         * localName pairs, and is populated as each attr is processed. This set is\n         * used to [optionally] enforce the well-formed constraint that an element\n         * cannot have two attributes with the same namespaceURI and localName.\n         * This can occur when two otherwise identical attributes on the same\n         * element differ only by their prefix values.\n         */\n        var result = \"\";\n        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;\n        try {\n            /**\n             * 3. Loop: For each attribute attr in element's attributes, in the order\n             * they are specified in the element's attribute list:\n             */\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                // Optimize common case\n                if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {\n                    result += \" \" + attr.localName + \"=\\\"\" +\n                        this._serializeAttributeValue(attr.value, requireWellFormed) + \"\\\"\";\n                    continue;\n                }\n                /**\n                 * 3.1. If the require well-formed flag is set (its value is true), and the\n                 * localname set contains a tuple whose values match those of a new tuple\n                 * consisting of attr's namespaceURI attribute and localName attribute,\n                 * then throw an exception; the serialization of this attr would fail to\n                 * produce a well-formed element serialization.\n                 */\n                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {\n                    throw new Error(\"Element contains duplicate attributes (well-formed required).\");\n                }\n                /**\n                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and\n                 * localName attribute, and add it to the localname set.\n                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n                 * 3.4. Let candidate prefix be null.\n                 */\n                if (requireWellFormed && localNameSet)\n                    localNameSet.set(attr.namespaceURI, attr.localName);\n                var attributeNamespace = attr.namespaceURI;\n                var candidatePrefix = null;\n                /** 3.5. If attribute namespace is not null, then run these sub-steps: */\n                if (attributeNamespace !== null) {\n                    /**\n                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred\n                     * prefix string from map given namespace attribute namespace with\n                     * preferred prefix being attr's prefix value.\n                     */\n                    candidatePrefix = map.get(attr.prefix, attributeNamespace);\n                    /**\n                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,\n                     * then run these steps:\n                     */\n                    if (attributeNamespace === infra_1.namespace.XMLNS) {\n                        /**\n                         * 3.5.2.1. If any of the following are true, then stop running these\n                         * steps and goto Loop to visit the next attribute:\n                         * - the attr's value is the XML namespace;\n                         * _Note:_ The XML namespace cannot be redeclared and survive\n                         * round-tripping (unless it defines the prefix \"xml\"). To avoid this\n                         * problem, this algorithm always prefixes elements in the XML\n                         * namespace with \"xml\" and drops any related definitions as seen\n                         * in the above condition.\n                         * - the attr's prefix is null and the ignore namespace definition\n                         * attribute flag is true (the Element's default namespace attribute\n                         * should be skipped);\n                         * - the attr's prefix is not null and either\n                         *   * the attr's localName is not a key contained in the local\n                         *     prefixes map, or\n                         *   * the attr's localName is present in the local prefixes map but\n                         *     the value of the key does not match attr's value\n                         * and furthermore that the attr's localName (as the prefix to find)\n                         * is found in the namespace prefix map given the namespace consisting\n                         * of the attr's value (the current namespace prefix definition was\n                         * exactly defined previously--on an ancestor element not the current\n                         * element whose attributes are being processed).\n                         */\n                        if (attr.value === infra_1.namespace.XML ||\n                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||\n                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||\n                                localPrefixesMap[attr.localName] !== attr.value) &&\n                                map.has(attr.localName, attr.value)))\n                            continue;\n                        /**\n                         * 3.5.2.2. If the require well-formed flag is set (its value is true),\n                         * and the value of attr's value attribute matches the XMLNS\n                         * namespace, then throw an exception; the serialization of this\n                         * attribute would produce invalid XML because the XMLNS namespace\n                         * is reserved and cannot be applied as an element's namespace via\n                         * XML parsing.\n                         *\n                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS\n                         * namespace but with strict qualifications.\n                         */\n                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {\n                            throw new Error(\"XMLNS namespace is reserved (well-formed required).\");\n                        }\n                        /**\n                         * 3.5.2.3. If the require well-formed flag is set (its value is true),\n                         * and the value of attr's value attribute is the empty string, then\n                         * throw an exception; namespace prefix declarations cannot be used\n                         * to undeclare a namespace (use a default namespace declaration\n                         * instead).\n                         */\n                        if (requireWellFormed && attr.value === '') {\n                            throw new Error(\"Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).\");\n                        }\n                        /**\n                         * 3.5.2.4. the attr's prefix matches the string \"xmlns\", then let\n                         * candidate prefix be the string \"xmlns\".\n                         */\n                        if (attr.prefix === 'xmlns')\n                            candidatePrefix = 'xmlns';\n                        /**\n                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.\n                         * Run these steps:\n                         *\n                         * _Note:_ The (candidatePrefix === null) check is not in the spec.\n                         * We deviate from the spec here. Otherwise a prefix is generated for\n                         * all attributes with namespaces.\n                         */\n                    }\n                    else if (candidatePrefix === null) {\n                        if (attr.prefix !== null &&\n                            (!map.hasPrefix(attr.prefix) ||\n                                map.has(attr.prefix, attributeNamespace))) {\n                            /**\n                             * Check if we can use the attribute's own prefix.\n                             * We deviate from the spec here.\n                             * TODO: This is not an efficient way of searching for prefixes.\n                             * Follow developments to the spec.\n                             */\n                            candidatePrefix = attr.prefix;\n                        }\n                        else {\n                            /**\n                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix\n                             * providing map, attribute namespace, and prefix index as input.\n                             */\n                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);\n                        }\n                        /**\n                         * 3.5.3.2. Append the following to result, in the order listed:\n                         * 3.5.3.2.1. \" \" (U+0020 SPACE);\n                         * 3.5.3.2.2. The string \"xmlns:\";\n                         * 3.5.3.2.3. The value of candidate prefix;\n                         * 3.5.3.2.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                         * 3.5.3.2.5. The result of serializing an attribute value given\n                         * attribute namespace and the require well-formed flag as input;\n                         * 3.5.3.2.6. \"\"\" (U+0022 QUOTATION MARK).\n                        */\n                        result += \" xmlns:\" + candidatePrefix + \"=\\\"\" +\n                            this._serializeAttributeValue(attributeNamespace, requireWellFormed) + \"\\\"\";\n                    }\n                }\n                /**\n                 * 3.6. Append a \" \" (U+0020 SPACE) to result.\n                 * 3.7. If candidate prefix is not null, then append to result the\n                 * concatenation of candidate prefix with \":\" (U+003A COLON).\n                 */\n                result += \" \";\n                if (candidatePrefix !== null) {\n                    result += candidatePrefix + ':';\n                }\n                /**\n                 * 3.8. If the require well-formed flag is set (its value is true), and\n                 * this attr's localName attribute contains the character\n                 * \":\" (U+003A COLON) or does not match the XML Name production or\n                 * equals \"xmlns\" and attribute namespace is null, then throw an\n                 * exception; the serialization of this attr would not be a\n                 * well-formed attribute.\n                 */\n                if (requireWellFormed && (attr.localName.indexOf(\":\") !== -1 ||\n                    !algorithm_1.xml_isName(attr.localName) ||\n                    (attr.localName === \"xmlns\" && attributeNamespace === null))) {\n                    throw new Error(\"Attribute local name contains invalid characters (well-formed required).\");\n                }\n                /**\n                 * 3.9. Append the following strings to result, in the order listed:\n                 * 3.9.1. The value of attr's localName;\n                 * 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 3.9.3. The result of serializing an attribute value given attr's value\n                 * attribute and the require well-formed flag as input;\n                 * 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                result += attr.localName + \"=\\\"\" +\n                    this._serializeAttributeValue(attr.value, requireWellFormed) + \"\\\"\";\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        /**\n         * 4. Return the value of result.\n         */\n        return result;\n    };\n    /**\n    * Records namespace information for the given element and returns the\n    * default namespace attribute value.\n    *\n    * @param node - element node to process\n    * @param map - namespace prefix map\n    * @param localPrefixesMap - local prefixes map\n    */\n    XMLSerializerImpl.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {\n        var e_5, _a;\n        /**\n         * 1. Let default namespace attr value be null.\n         */\n        var defaultNamespaceAttrValue = null;\n        try {\n            /**\n             * 2. Main: For each attribute attr in element's attributes, in the order\n             * they are specified in the element's attribute list:\n             */\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                /**\n                 * _Note:_ The following conditional steps find namespace prefixes. Only\n                 * attributes in the XMLNS namespace are considered (e.g., attributes made\n                 * to look like namespace declarations via\n                 * setAttribute(\"xmlns:pretend-prefix\", \"pretend-namespace\") are not\n                 * included).\n                 */\n                /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */\n                var attributeNamespace = attr.namespaceURI;\n                /** 2.2. Let attribute prefix be the value of attr's prefix. */\n                var attributePrefix = attr.prefix;\n                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */\n                if (attributeNamespace === infra_1.namespace.XMLNS) {\n                    /**\n                     * 2.3.1. If attribute prefix is null, then attr is a default namespace\n                     * declaration. Set the default namespace attr value to attr's value and\n                     * stop running these steps, returning to Main to visit the next\n                     * attribute.\n                     */\n                    if (attributePrefix === null) {\n                        defaultNamespaceAttrValue = attr.value;\n                        continue;\n                        /**\n                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a\n                         * namespace prefix definition. Run the following steps:\n                         */\n                    }\n                    else {\n                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */\n                        var prefixDefinition = attr.localName;\n                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */\n                        var namespaceDefinition = attr.value;\n                        /**\n                         * 2.3.2.3. If namespace definition is the XML namespace, then stop\n                         * running these steps, and return to Main to visit the next\n                         * attribute.\n                         *\n                         * _Note:_ XML namespace definitions in prefixes are completely\n                         * ignored (in order to avoid unnecessary work when there might be\n                         * prefix conflicts). XML namespaced elements are always handled\n                         * uniformly by prefixing (and overriding if necessary) the element's\n                         * localname with the reserved \"xml\" prefix.\n                         */\n                        if (namespaceDefinition === infra_1.namespace.XML) {\n                            continue;\n                        }\n                        /**\n                         * 2.3.2.4. If namespace definition is the empty string (the\n                         * declarative form of having no namespace), then let namespace\n                         * definition be null instead.\n                         */\n                        if (namespaceDefinition === '') {\n                            namespaceDefinition = null;\n                        }\n                        /**\n                         * 2.3.2.5. If prefix definition is found in map given the namespace\n                         * namespace definition, then stop running these steps, and return to\n                         * Main to visit the next attribute.\n                         *\n                         * _Note:_ This step avoids adding duplicate prefix definitions for\n                         * the same namespace in the map. This has the side-effect of avoiding\n                         * later serialization of duplicate namespace prefix declarations in\n                         * any descendant nodes.\n                         */\n                        if (map.has(prefixDefinition, namespaceDefinition)) {\n                            continue;\n                        }\n                        /**\n                         * 2.3.2.6. Add the prefix prefix definition to map given namespace\n                         * namespace definition.\n                         */\n                        map.set(prefixDefinition, namespaceDefinition);\n                        /**\n                         * 2.3.2.7. Add the value of prefix definition as a new key to the\n                         * local prefixes map, with the namespace definition as the key's\n                         * value replacing the value of null with the empty string if\n                         * applicable.\n                         */\n                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';\n                    }\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        /**\n         * 3. Return the value of default namespace attr value.\n         *\n         * _Note:_ The empty string is a legitimate return value and is not\n         * converted to null.\n         */\n        return defaultNamespaceAttrValue;\n    };\n    /**\n    * Generates a new prefix for the given namespace.\n    *\n    * @param newNamespace - a namespace to generate prefix for\n    * @param prefixMap - namespace prefix map\n    * @param prefixIndex - generated namespace prefix index\n    */\n    XMLSerializerImpl.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {\n        /**\n         * 1. Let generated prefix be the concatenation of the string \"ns\" and the\n         * current numerical value of prefix index.\n         * 2. Let the value of prefix index be incremented by one.\n         * 3. Add to map the generated prefix given the new namespace namespace.\n         * 4. Return the value of generated prefix.\n         */\n        var generatedPrefix = \"ns\" + prefixIndex.value;\n        prefixIndex.value++;\n        prefixMap.set(generatedPrefix, newNamespace);\n        return generatedPrefix;\n    };\n    /**\n     * Produces an XML serialization of an attribute value.\n     *\n     * @param value - attribute value\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeAttributeValue = function (value, requireWellFormed) {\n        /**\n         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value\n         *\n         * 1. If the require well-formed flag is set (its value is true), and\n         * attribute value contains characters that are not matched by the XML Char\n         * production, then throw an exception; the serialization of this attribute\n         * value would fail to produce a well-formed element serialization.\n         */\n        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {\n            throw new Error(\"Invalid characters in attribute value.\");\n        }\n        /**\n         * 2. If attribute value is null, then return the empty string.\n         */\n        if (value === null)\n            return \"\";\n        /**\n         * 3. Otherwise, attribute value is a string. Return the value of attribute\n         * value, first replacing any occurrences of the following:\n         * - \"&\" with \"&amp;\"\n         * - \"\"\" with \"&quot;\"\n         * - \"<\" with \"&lt;\"\n         * - \">\" with \"&gt;\"\n         * NOTE\n         * This matches behavior present in browsers, and goes above and beyond the\n         * grammar requirement in the XML specification's AttValue production by\n         * also replacing \">\" characters.\n         */\n        var result = \"\";\n        for (var i = 0; i < value.length; i++) {\n            var c = value[i];\n            if (c === \"\\\"\")\n                result += \"&quot;\";\n            else if (c === \"&\")\n                result += \"&amp;\";\n            else if (c === \"<\")\n                result += \"&lt;\";\n            else if (c === \">\")\n                result += \"&gt;\";\n            else\n                result += c;\n        }\n        return result;\n    };\n    /**\n     * Produces an XML serialization of an element node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeElement = function (node, requireWellFormed) {\n        var e_6, _a;\n        /**\n         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node\n         *\n         * 1. If the require well-formed flag is set (its value is true), and this\n         * node's localName attribute contains the character \":\" (U+003A COLON) or\n         * does not match the XML Name production, then throw an exception; the\n         * serialization of this node would not be a well-formed element.\n         */\n        if (requireWellFormed && (node.localName.indexOf(\":\") !== -1 ||\n            !algorithm_1.xml_isName(node.localName))) {\n            throw new Error(\"Node local name contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n         * 3. Let qualified name be an empty string.\n         * 4. Let skip end tag be a boolean flag with value false.\n         * 5. Let ignore namespace definition attribute be a boolean flag with value\n         * false.\n         * 6. Given prefix map, copy a namespace prefix map and let map be the\n         * result.\n         * 7. Let local prefixes map be an empty map. The map has unique Node prefix\n         * strings as its keys, with corresponding namespaceURI Node values as the\n         * map's key values (in this map, the null namespace is represented by the\n         * empty string).\n         *\n         * _Note:_ This map is local to each element. It is used to ensure there\n         * are no conflicting prefixes should a new namespace prefix attribute need\n         * to be generated. It is also used to enable skipping of duplicate prefix\n         * definitions when writing an element's attributes: the map allows the\n         * algorithm to distinguish between a prefix in the namespace prefix map\n         * that might be locally-defined (to the current Element) and one that is\n         * not.\n         * 8. Let local default namespace be the result of recording the namespace\n         * information for node given map and local prefixes map.\n         *\n         * _Note:_ The above step will update map with any found namespace prefix\n         * definitions, add the found prefix definitions to the local prefixes map\n         * and return a local default namespace value defined by a default namespace\n         * attribute if one exists. Otherwise it returns null.\n         * 9. Let inherited ns be a copy of namespace.\n         * 10. Let ns be the value of node's namespaceURI attribute.\n         */\n        var skipEndTag = false;\n        /** 11. If inherited ns is equal to ns, then: */\n        /**\n         * 11.1. If local default namespace is not null, then set ignore\n         * namespace definition attribute to true.\n         * 11.2. If ns is the XML namespace, then append to qualified name the\n         * concatenation of the string \"xml:\" and the value of node's localName.\n         * 11.3. Otherwise, append to qualified name the value of node's\n         * localName. The node's prefix if it exists, is dropped.\n         */\n        var qualifiedName = node.localName;\n        /** 11.4. Append the value of qualified name to markup. */\n        var markup = \"<\" + qualifiedName;\n        /**\n         * 13. Append to markup the result of the XML serialization of node's\n         * attributes given map, prefix index, local prefixes map, ignore namespace\n         * definition attribute flag, and require well-formed flag.\n         */\n        markup += this._serializeAttributes(node, requireWellFormed);\n        /**\n         * 14. If ns is the HTML namespace, and the node's list of children is\n         * empty, and the node's localName matches any one of the following void\n         * elements: \"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"embed\",\n         * \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\",\n         * \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup,\n         * in the order listed:\n         * 14.1. \" \" (U+0020 SPACE);\n         * 14.2. \"/\" (U+002F SOLIDUS).\n         * and set the skip end tag flag to true.\n         * 15. If ns is not the HTML namespace, and the node's list of children is\n         * empty, then append \"/\" (U+002F SOLIDUS) to markup and set the skip end\n         * tag flag to true.\n         * 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n         */\n        if (node._children.size === 0) {\n            markup += \"/\";\n            skipEndTag = true;\n        }\n        markup += \">\";\n        /**\n         * 17. If the value of skip end tag is true, then return the value of markup\n         * and skip the remaining steps. The node is a leaf-node.\n         */\n        if (skipEndTag)\n            return markup;\n        try {\n            /**\n             * 18. If ns is the HTML namespace, and the node's localName matches the\n             * string \"template\", then this is a template element. Append to markup the\n             * result of XML serializing a DocumentFragment node given the template\n             * element's template contents (a DocumentFragment), providing inherited\n             * ns, map, prefix index, and the require well-formed flag.\n             *\n             * _Note:_ This allows template content to round-trip, given the rules for\n             * parsing XHTML documents.\n             *\n             * 19. Otherwise, append to markup the result of running the XML\n             * serialization algorithm on each of node's children, in tree order,\n             * providing inherited ns, map, prefix index, and the require well-formed\n             * flag.\n             */\n            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                markup += this._serializeNode(childNode, requireWellFormed);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        /**\n         * 20. Append the following to markup, in the order listed:\n         * 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n         * 20.2. The value of qualified name;\n         * 20.3. \">\" (U+003E GREATER-THAN SIGN).\n         */\n        markup += \"</\" + qualifiedName + \">\";\n        /**\n         * 21. Return the value of markup.\n         */\n        return markup;\n    };\n    /**\n     * Produces an XML serialization of a document node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeDocument = function (node, requireWellFormed) {\n        var e_7, _a;\n        /**\n         * If the require well-formed flag is set (its value is true), and this node\n         * has no documentElement (the documentElement attribute's value is null),\n         * then throw an exception; the serialization of this node would not be a\n         * well-formed document.\n         */\n        if (requireWellFormed && node.documentElement === null) {\n            throw new Error(\"Missing document element (well-formed required).\");\n        }\n        /**\n         * Otherwise, run the following steps:\n         * 1. Let serialized document be an empty string.\n         * 2. For each child child of node, in tree order, run the XML\n         * serialization algorithm on the child passing along the provided\n         * arguments, and append the result to serialized document.\n         *\n         * _Note:_ This will serialize any number of ProcessingInstruction and\n         * Comment nodes both before and after the Document's documentElement node,\n         * including at most one DocumentType node. (Text nodes are not allowed as\n         * children of the Document.)\n         *\n         * 3. Return the value of serialized document.\n        */\n        var serializedDocument = \"\";\n        try {\n            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                serializedDocument += this._serializeNode(childNode, requireWellFormed);\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n        return serializedDocument;\n    };\n    /**\n     * Produces an XML serialization of a document fragment node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeDocumentFragment = function (node, requireWellFormed) {\n        var e_8, _a;\n        /**\n         * 1. Let markup the empty string.\n         * 2. For each child child of node, in tree order, run the XML serialization\n         * algorithm on the child given namespace, prefix map, a reference to prefix\n         * index, and flag require well-formed. Concatenate the result to markup.\n         * 3. Return the value of markup.\n         */\n        var markup = \"\";\n        try {\n            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                markup += this._serializeNode(childNode, requireWellFormed);\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n        return markup;\n    };\n    /**\n     * Produces an XML serialization of the attributes of an element node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLSerializerImpl.prototype._serializeAttributes = function (node, requireWellFormed) {\n        var e_9, _a;\n        /**\n         * 1. Let result be the empty string.\n         * 2. Let localname set be a new empty namespace localname set. This\n         * localname set will contain tuples of unique attribute namespaceURI and\n         * localName pairs, and is populated as each attr is processed. This set is\n         * used to [optionally] enforce the well-formed constraint that an element\n         * cannot have two attributes with the same namespaceURI and localName.\n         * This can occur when two otherwise identical attributes on the same\n         * element differ only by their prefix values.\n         */\n        var result = \"\";\n        var localNameSet = requireWellFormed ? {} : undefined;\n        try {\n            /**\n             * 3. Loop: For each attribute attr in element's attributes, in the order\n             * they are specified in the element's attribute list:\n             */\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                /**\n                 * 3.1. If the require well-formed flag is set (its value is true), and the\n                 * localname set contains a tuple whose values match those of a new tuple\n                 * consisting of attr's namespaceURI attribute and localName attribute,\n                 * then throw an exception; the serialization of this attr would fail to\n                 * produce a well-formed element serialization.\n                 */\n                if (requireWellFormed && localNameSet && (attr.localName in localNameSet)) {\n                    throw new Error(\"Element contains duplicate attributes (well-formed required).\");\n                }\n                /**\n                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and\n                 * localName attribute, and add it to the localname set.\n                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n                 * 3.4. Let candidate prefix be null.\n                 */\n                if (requireWellFormed && localNameSet)\n                    localNameSet[attr.localName] = true;\n                /** 3.5. If attribute namespace is not null, then run these sub-steps: */\n                /**\n                 * 3.6. Append a \" \" (U+0020 SPACE) to result.\n                 * 3.7. If candidate prefix is not null, then append to result the\n                 * concatenation of candidate prefix with \":\" (U+003A COLON).\n                 */\n                /**\n                 * 3.8. If the require well-formed flag is set (its value is true), and\n                 * this attr's localName attribute contains the character\n                 * \":\" (U+003A COLON) or does not match the XML Name production or\n                 * equals \"xmlns\" and attribute namespace is null, then throw an\n                 * exception; the serialization of this attr would not be a\n                 * well-formed attribute.\n                 */\n                if (requireWellFormed && (attr.localName.indexOf(\":\") !== -1 ||\n                    !algorithm_1.xml_isName(attr.localName))) {\n                    throw new Error(\"Attribute local name contains invalid characters (well-formed required).\");\n                }\n                /**\n                 * 3.9. Append the following strings to result, in the order listed:\n                 * 3.9.1. The value of attr's localName;\n                 * 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 3.9.3. The result of serializing an attribute value given attr's value\n                 * attribute and the require well-formed flag as input;\n                 * 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                result += \" \" + attr.localName + \"=\\\"\" +\n                    this._serializeAttributeValue(attr.value, requireWellFormed) + \"\\\"\";\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        /**\n         * 4. Return the value of result.\n         */\n        return result;\n    };\n    XMLSerializerImpl._VoidElementNames = new Set(['area', 'base', 'basefont',\n        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',\n        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);\n    return XMLSerializerImpl;\n}());\nexports.XMLSerializerImpl = XMLSerializerImpl;\n//# sourceMappingURL=XMLSerializerImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Export classes\nvar XMLSerializerImpl_1 = require(\"./XMLSerializerImpl\");\nexports.XMLSerializer = XMLSerializerImpl_1.XMLSerializerImpl;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Guard_1 = require(\"./Guard\");\n/**\n * Contains type casts for DOM objects.\n */\nvar Cast = /** @class */ (function () {\n    function Cast() {\n    }\n    /**\n     * Casts the given object to a `Node`.\n     *\n     * @param a - the object to cast\n     */\n    Cast.asNode = function (a) {\n        if (Guard_1.Guard.isNode(a)) {\n            return a;\n        }\n        else {\n            throw new Error(\"Invalid object. Node expected.\");\n        }\n    };\n    return Cast;\n}());\nexports.Cast = Cast;\n//# sourceMappingURL=Cast.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EmptySet = /** @class */ (function () {\n    function EmptySet() {\n    }\n    Object.defineProperty(EmptySet.prototype, \"size\", {\n        get: function () {\n            return 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EmptySet.prototype.add = function (value) {\n        throw new Error(\"Cannot add to an empty set.\");\n    };\n    EmptySet.prototype.clear = function () {\n        // no-op\n    };\n    EmptySet.prototype.delete = function (value) {\n        return false;\n    };\n    EmptySet.prototype.forEach = function (callbackfn, thisArg) {\n        // no-op\n    };\n    EmptySet.prototype.has = function (value) {\n        return false;\n    };\n    EmptySet.prototype[Symbol.iterator] = function () {\n        return new EmptySetIterator();\n    };\n    EmptySet.prototype.entries = function () {\n        return new EmptySetIterator();\n    };\n    EmptySet.prototype.keys = function () {\n        return new EmptySetIterator();\n    };\n    EmptySet.prototype.values = function () {\n        return new EmptySetIterator();\n    };\n    Object.defineProperty(EmptySet.prototype, Symbol.toStringTag, {\n        get: function () {\n            return \"EmptySet\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmptySet;\n}());\nexports.EmptySet = EmptySet;\nvar EmptySetIterator = /** @class */ (function () {\n    function EmptySetIterator() {\n    }\n    EmptySetIterator.prototype[Symbol.iterator] = function () {\n        return this;\n    };\n    EmptySetIterator.prototype.next = function () {\n        return { done: true, value: null };\n    };\n    return EmptySetIterator;\n}());\n//# sourceMappingURL=EmptySet.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../dom/interfaces\");\n/**\n * Contains user-defined type guards for DOM objects.\n */\nvar Guard = /** @class */ (function () {\n    function Guard() {\n    }\n    /**\n     * Determines if the given object is a `Node`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isNode = function (a) {\n        return (!!a && a._nodeType !== undefined);\n    };\n    /**\n     * Determines if the given object is a `Document`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isDocumentNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Document);\n    };\n    /**\n     * Determines if the given object is a `DocumentType`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isDocumentTypeNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType);\n    };\n    /**\n     * Determines if the given object is a `DocumentFragment`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isDocumentFragmentNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment);\n    };\n    /**\n     * Determines if the given object is a `Attr`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isAttrNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute);\n    };\n    /**\n     * Determines if the given node is a `CharacterData` node.\n     *\n     * @param a - the object to check\n     */\n    Guard.isCharacterDataNode = function (a) {\n        if (!Guard.isNode(a))\n            return false;\n        var type = a._nodeType;\n        return (type === interfaces_1.NodeType.Text ||\n            type === interfaces_1.NodeType.ProcessingInstruction ||\n            type === interfaces_1.NodeType.Comment ||\n            type === interfaces_1.NodeType.CData);\n    };\n    /**\n     * Determines if the given object is a `Text` or a `CDATASection`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isTextNode = function (a) {\n        return (Guard.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData));\n    };\n    /**\n     * Determines if the given object is a `Text`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isExclusiveTextNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Text);\n    };\n    /**\n     * Determines if the given object is a `CDATASection`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isCDATASectionNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.CData);\n    };\n    /**\n     * Determines if the given object is a `Comment`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isCommentNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment);\n    };\n    /**\n     * Determines if the given object is a `ProcessingInstruction`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isProcessingInstructionNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction);\n    };\n    /**\n     * Determines if the given object is an `Element`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isElementNode = function (a) {\n        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Element);\n    };\n    /**\n     * Determines if the given object is a custom `Element`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isCustomElementNode = function (a) {\n        return (Guard.isElementNode(a) && a._customElementState === \"custom\");\n    };\n    /**\n     * Determines if the given object is a `ShadowRoot`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isShadowRoot = function (a) {\n        return (!!a && a.host !== undefined);\n    };\n    /**\n     * Determines if the given object is a `MouseEvent`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isMouseEvent = function (a) {\n        return (!!a && a.screenX !== undefined && a.screenY != undefined);\n    };\n    /**\n     * Determines if the given object is a slotable.\n     *\n     * Element and Text nodes are slotables. A slotable has an associated name\n     * (a string).\n     *\n     * @param a - the object to check\n     */\n    Guard.isSlotable = function (a) {\n        return (!!a && a._name !== undefined && a._assignedSlot !== undefined &&\n            (Guard.isTextNode(a) || Guard.isElementNode(a)));\n    };\n    /**\n     * Determines if the given object is a slot.\n     *\n     * @param a - the object to check\n     */\n    Guard.isSlot = function (a) {\n        return (!!a && a._name !== undefined && a._assignedNodes !== undefined &&\n            Guard.isElementNode(a));\n    };\n    /**\n     * Determines if the given object is a `Window`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isWindow = function (a) {\n        return (!!a && a.navigator !== undefined);\n    };\n    /**\n     * Determines if the given object is an `EventListener`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isEventListener = function (a) {\n        return (!!a && a.handleEvent !== undefined);\n    };\n    /**\n     * Determines if the given object is a `RegisteredObserver`.\n     *\n     * @param a - the object to check\n     */\n    Guard.isRegisteredObserver = function (a) {\n        return (!!a && a.observer !== undefined && a.options !== undefined);\n    };\n    /**\n   * Determines if the given object is a `TransientRegisteredObserver`.\n   *\n   * @param a - the object to check\n   */\n    Guard.isTransientRegisteredObserver = function (a) {\n        return (!!a && a.source !== undefined && Guard.isRegisteredObserver(a));\n    };\n    return Guard;\n}());\nexports.Guard = Guard;\n//# sourceMappingURL=Guard.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Cast_1 = require(\"./Cast\");\nexports.Cast = Cast_1.Cast;\nvar Guard_1 = require(\"./Guard\");\nexports.Guard = Guard_1.Guard;\nvar EmptySet_1 = require(\"./EmptySet\");\nexports.EmptySet = EmptySet_1.EmptySet;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CodePoints_1 = require(\"./CodePoints\");\n/**\n * Base-64 encodes the given string.\n *\n * @param input - a string\n */\nfunction forgivingBase64Encode(input) {\n    /**\n     * To forgiving-base64 encode given a byte sequence data, apply the base64\n     * algorithm defined in section 4 of RFC 4648 to data and return the result.\n     * [RFC4648]\n     */\n    return Buffer.from(input).toString('base64');\n}\nexports.forgivingBase64Encode = forgivingBase64Encode;\n/**\n * Decodes a base-64 string.\n *\n * @param input - a string\n */\nfunction forgivingBase64Decode(input) {\n    if (input === \"\")\n        return \"\";\n    /**\n     * 1. Remove all ASCII whitespace from data.\n     */\n    input = input.replace(CodePoints_1.ASCIIWhiteSpace, '');\n    /**\n     * 2. If data’s length divides by 4 leaving no remainder, then:\n     * 2.1. If data ends with one or two U+003D (=) code points, then remove them from data.\n     */\n    if (input.length % 4 === 0) {\n        if (input.endsWith(\"==\")) {\n            input = input.substr(0, input.length - 2);\n        }\n        else if (input.endsWith(\"=\")) {\n            input = input.substr(0, input.length - 1);\n        }\n    }\n    /**\n     * 3. If data’s length divides by 4 leaving a remainder of 1, then return failure.\n     */\n    if (input.length % 4 === 1)\n        return null;\n    /**\n     * 4. If data contains a code point that is not one of\n     * - U+002B (+)\n     * - U+002F (/)\n     * - ASCII alphanumeric\n     * then return failure.\n     */\n    if (!/[0-9A-Za-z+/]/.test(input))\n        return null;\n    /**\n     * 5. Let output be an empty byte sequence.\n     * 6. Let buffer be an empty buffer that can have bits appended to it.\n     * 7. Let position be a position variable for data, initially pointing at the\n     * start of data.\n     * 8. While position does not point past the end of data:\n     * 8.1. Find the code point pointed to by position in the second column of\n     * Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in the\n     * first cell of the same row. [RFC4648]\n     * 8.2. Append the six bits corresponding to n, most significant bit first,\n     * to buffer.\n     * 8.3. If buffer has accumulated 24 bits, interpret them as three 8-bit\n     * big-endian numbers. Append three bytes with values equal to those numbers\n     * to output, in the same order, and then empty buffer.\n     * 8.4. Advance position by 1.\n     * 9. If buffer is not empty, it contains either 12 or 18 bits. If it contains\n     * 12 bits, then discard the last four and interpret the remaining eight as an\n     * 8-bit big-endian number. If it contains 18 bits, then discard the last two\n     * and interpret the remaining 16 as two 8-bit big-endian numbers. Append the\n     * one or two bytes with values equal to those one or two numbers to output,\n     * in the same order.\n     * 10. Return output.\n     */\n    return Buffer.from(input, 'base64').toString('utf8');\n}\nexports.forgivingBase64Decode = forgivingBase64Decode;\n//# sourceMappingURL=Base64.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Determines if the given number is an ASCII byte.\n *\n * @param byte - a byte\n */\nfunction isASCIIByte(byte) {\n    /**\n     * An ASCII byte is a byte in the range 0x00 (NUL) to 0x7F (DEL), inclusive.\n     */\n    return byte >= 0x00 && byte <= 0x7F;\n}\nexports.isASCIIByte = isASCIIByte;\n//# sourceMappingURL=Byte.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the count of bytes in a sequence.\n *\n * @param list - a byte sequence\n */\nfunction length(list) {\n    /**\n     * A byte sequence’s length is the number of bytes it contains.\n     */\n    return list.length;\n}\nexports.length = length;\n/**\n * Converts each byte to lowercase.\n *\n * @param list - a byte sequence\n */\nfunction byteLowercase(list) {\n    /**\n     * To byte-lowercase a byte sequence, increase each byte it contains, in the\n     * range 0x41 (A) to 0x5A (Z), inclusive, by 0x20.\n     */\n    for (var i = 0; i < list.length; i++) {\n        var c = list[i];\n        if (c >= 0x41 && c <= 0x5A) {\n            list[i] = c + 0x20;\n        }\n    }\n}\nexports.byteLowercase = byteLowercase;\n/**\n * Converts each byte to uppercase.\n *\n * @param list - a byte sequence\n */\nfunction byteUppercase(list) {\n    /**\n     * To byte-uppercase a byte sequence, subtract each byte it contains, in the\n     * range 0x61 (a) to 0x7A (z), inclusive, by 0x20.\n     */\n    for (var i = 0; i < list.length; i++) {\n        var c = list[i];\n        if (c >= 0x61 && c <= 0x7A) {\n            list[i] = c - 0x20;\n        }\n    }\n}\nexports.byteUppercase = byteUppercase;\n/**\n * Compares two byte sequences.\n *\n * @param listA - a byte sequence\n * @param listB - a byte sequence\n */\nfunction byteCaseInsensitiveMatch(listA, listB) {\n    /**\n     * A byte sequence A is a byte-case-insensitive match for a byte sequence B,\n     * if the byte-lowercase of A is the byte-lowercase of B.\n     */\n    if (listA.length !== listB.length)\n        return false;\n    for (var i = 0; i < listA.length; i++) {\n        var a = listA[i];\n        var b = listB[i];\n        if (a >= 0x41 && a <= 0x5A)\n            a += 0x20;\n        if (b >= 0x41 && b <= 0x5A)\n            b += 0x20;\n        if (a !== b)\n            return false;\n    }\n    return true;\n}\nexports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;\n/**\n * Determines if `listA` starts with `listB`.\n *\n * @param listA - a byte sequence\n * @param listB - a byte sequence\n */\nfunction startsWith(listA, listB) {\n    /**\n     * 1. Let i be 0.\n     * 2. While true:\n     * 2.1. Let aByte be the ith byte of a if i is less than a’s length; otherwise null.\n     * 2.3. Let bByte be the ith byte of b if i is less than b’s length; otherwise null.\n     * 2.4. If bByte is null, then return true.\n     * 2.5. Return false if aByte is not bByte.\n     * 2.6. Set i to i + 1.\n     */\n    var i = 0;\n    while (true) {\n        if (i >= listA.length)\n            return false;\n        if (i >= listB.length)\n            return true;\n        if (listA[i] !== listB[i])\n            return false;\n        i++;\n    }\n}\nexports.startsWith = startsWith;\n/**\n * Determines if `listA` is less than `listB`.\n *\n * @param listA - a byte sequence\n * @param listB - a byte sequence\n */\nfunction byteLessThan(listA, listB) {\n    /**\n     * 1. If b starts with a, then return false.\n     * 2. If a starts with b, then return true.\n     * 3. Let n be the smallest index such that the nth byte of a is different\n     * from the nth byte of b. (There has to be such an index, since neither byte\n     * sequence starts with the other.)\n     * 4. If the nth byte of a is less than the nth byte of b, then return true.\n     * 5. Return false.\n     */\n    var i = 0;\n    while (true) {\n        if (i >= listA.length)\n            return false;\n        if (i >= listB.length)\n            return true;\n        var a = listA[i];\n        var b = listB[i];\n        if (a < b)\n            return true;\n        else if (a > b)\n            return false;\n        i++;\n    }\n}\nexports.byteLessThan = byteLessThan;\n/**\n * Decodes a byte sequence into a string.\n *\n * @param list - a byte sequence\n */\nfunction isomorphicDecode(list) {\n    /**\n     * To isomorphic decode a byte sequence input, return a string whose length is\n     * equal to input’s length and whose code points have the same values as\n     * input’s bytes, in the same order.\n     */\n    return String.fromCodePoint.apply(String, __spread(list));\n}\nexports.isomorphicDecode = isomorphicDecode;\n//# sourceMappingURL=ByteSequence.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A surrogate is a code point that is in the range U+D800 to U+DFFF, inclusive.\n */\nexports.Surrogate = /[\\uD800-\\uDFFF]/;\n/**\n * A scalar value is a code point that is not a surrogate.\n */\nexports.ScalarValue = /[\\uD800-\\uDFFF]/;\n/**\n * A noncharacter is a code point that is in the range U+FDD0 to U+FDEF,\n * inclusive, or U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,\n * U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE,\n * U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE,\n * U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE,\n * U+FFFFF, U+10FFFE, or U+10FFFF.\n */\nexports.NonCharacter = /[\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]/;\n/**\n * An ASCII code point is a code point in the range U+0000 NULL to U+007F\n * DELETE, inclusive.\n */\nexports.ASCIICodePoint = /[\\u0000-\\u007F]/;\n/**\n * An ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.\n */\nexports.ASCIITabOrNewLine = /[\\t\\n\\r]/;\n/**\n * ASCII whitespace is U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, or\n * U+0020 SPACE.\n */\nexports.ASCIIWhiteSpace = /[\\t\\n\\f\\r ]/;\n/**\n * A C0 control is a code point in the range U+0000 NULL to U+001F\n * INFORMATION SEPARATOR ONE, inclusive.\n */\nexports.C0Control = /[\\u0000-\\u001F]/;\n/**\n * A C0 control or space is a C0 control or U+0020 SPACE.\n */\nexports.C0ControlOrSpace = /[\\u0000-\\u001F ]/;\n/**\n * A control is a C0 control or a code point in the range U+007F DELETE to\n * U+009F APPLICATION PROGRAM COMMAND, inclusive.\n */\nexports.Control = /[\\u0000-\\u001F\\u007F-\\u009F]/;\n/**\n * An ASCII digit is a code point in the range U+0030 (0) to U+0039 (9),\n * inclusive.\n */\nexports.ASCIIDigit = /[0-9]/;\n/**\n * An ASCII upper hex digit is an ASCII digit or a code point in the range\n * U+0041 (A) to U+0046 (F), inclusive.\n */\nexports.ASCIIUpperHexDigit = /[0-9A-F]/;\n/**\n * An ASCII lower hex digit is an ASCII digit or a code point in the range\n * U+0061 (a) to U+0066 (f), inclusive.\n */\nexports.ASCIILowerHexDigit = /[0-9a-f]/;\n/**\n * An ASCII hex digit is an ASCII upper hex digit or ASCII lower hex digit.\n */\nexports.ASCIIHexDigit = /[0-9A-Fa-f]/;\n/**\n * An ASCII upper alpha is a code point in the range U+0041 (A) to U+005A (Z),\n * inclusive.\n */\nexports.ASCIIUpperAlpha = /[A-Z]/;\n/**\n * An ASCII lower alpha is a code point in the range U+0061 (a) to U+007A (z),\n * inclusive.\n */\nexports.ASCIILowerAlpha = /[a-z]/;\n/**\n * An ASCII alpha is an ASCII upper alpha or ASCII lower alpha.\n */\nexports.ASCIIAlpha = /[A-Za-z]/;\n/**\n * An ASCII alphanumeric is an ASCII digit or ASCII alpha.\n */\nexports.ASCIIAlphanumeric = /[0-9A-Za-z]/;\n//# sourceMappingURL=CodePoints.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Parses the given byte sequence representing a JSON string into an object.\n *\n * @param bytes - a byte sequence\n */\nfunction parseJSONFromBytes(bytes) {\n    /**\n     * 1. Let jsonText be the result of running UTF-8 decode on bytes. [ENCODING]\n     * 2. Return ? Call(%JSONParse%, undefined, « jsonText »).\n     */\n    var jsonText = util_1.utf8Decode(bytes);\n    return JSON.parse.call(undefined, jsonText);\n}\nexports.parseJSONFromBytes = parseJSONFromBytes;\n/**\n * Serialize the given JavaScript value into a byte sequence.\n *\n * @param value - a JavaScript value\n */\nfunction serializeJSONToBytes(value) {\n    /**\n     * 1. Let jsonString be ? Call(%JSONStringify%, undefined, « value »).\n     * 2. Return the result of running UTF-8 encode on jsonString. [ENCODING]\n     */\n    var jsonString = JSON.stringify.call(undefined, value);\n    return util_1.utf8Encode(jsonString);\n}\nexports.serializeJSONToBytes = serializeJSONToBytes;\n/**\n * Parses the given JSON string into a Realm-independent JavaScript value.\n *\n * @param jsonText - a JSON string\n */\nfunction parseJSONIntoInfraValues(jsonText) {\n    /**\n     * 1. Let jsValue be ? Call(%JSONParse%, undefined, « jsonText »).\n     * 2. Return the result of converting a JSON-derived JavaScript value to an\n     * Infra value, given jsValue.\n     */\n    var jsValue = JSON.parse.call(undefined, jsonText);\n    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);\n}\nexports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;\n/**\n * Parses the value into a Realm-independent JavaScript value.\n *\n * @param jsValue - a JavaScript value\n */\nfunction convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {\n    var e_1, _a;\n    /**\n     * 1. If Type(jsValue) is Null, String, or Number, then return jsValue.\n     */\n    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))\n        return jsValue;\n    /**\n     * 2. If IsArray(jsValue) is true, then:\n     * 2.1. Let result be an empty list.\n     * 2.2. Let length be ! ToLength(! Get(jsValue, \"length\")).\n     * 2.3. For each index of the range 0 to length − 1, inclusive:\n     * 2.3.1. Let indexName be ! ToString(index).\n     * 2.3.2. Let jsValueAtIndex be ! Get(jsValue, indexName).\n     * 2.3.3. Let infraValueAtIndex be the result of converting a JSON-derived\n     * JavaScript value to an Infra value, given jsValueAtIndex.\n     * 2.3.4. Append infraValueAtIndex to result.\n     * 2.8. Return result.\n     */\n    if (util_1.isArray(jsValue)) {\n        var result = new Array();\n        try {\n            for (var jsValue_1 = __values(jsValue), jsValue_1_1 = jsValue_1.next(); !jsValue_1_1.done; jsValue_1_1 = jsValue_1.next()) {\n                var jsValueAtIndex = jsValue_1_1.value;\n                result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (jsValue_1_1 && !jsValue_1_1.done && (_a = jsValue_1.return)) _a.call(jsValue_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    }\n    else if (util_1.isObject(jsValue)) {\n        /**\n         * 3. Let result be an empty ordered map.\n         * 4. For each key of ! jsValue.[[OwnPropertyKeys]]():\n         * 4.1. Let jsValueAtKey be ! Get(jsValue, key).\n         * 4.2. Let infraValueAtKey be the result of converting a JSON-derived\n         * JavaScript value to an Infra value, given jsValueAtKey.\n         * 4.3. Set result[key] to infraValueAtKey.\n         * 5. Return result.\n         */\n        var result = new Map();\n        for (var key in jsValue) {\n            /* istanbul ignore else */\n            if (jsValue.hasOwnProperty(key)) {\n                var jsValueAtKey = jsValue[key];\n                result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));\n            }\n        }\n        return result;\n    }\n    /* istanbul ignore next */\n    return jsValue;\n}\nexports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;\n//# sourceMappingURL=JSON.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Adds the given item to the end of the list.\n *\n * @param list - a list\n * @param item - an item\n */\nfunction append(list, item) {\n    list.push(item);\n}\nexports.append = append;\n/**\n * Extends a list by appending all items from another list.\n *\n * @param listA - a list to extend\n * @param listB - a list containing items to append to `listA`\n */\nfunction extend(listA, listB) {\n    listA.push.apply(listA, __spread(listB));\n}\nexports.extend = extend;\n/**\n * Inserts the given item to the start of the list.\n *\n * @param list - a list\n * @param item - an item\n */\nfunction prepend(list, item) {\n    list.unshift(item);\n}\nexports.prepend = prepend;\n/**\n * Replaces the given item or all items matching condition with a new item.\n *\n * @param list - a list\n * @param conditionOrItem - an item to replace or a condition matching items\n * to replace\n * @param item - an item\n */\nfunction replace(list, conditionOrItem, newItem) {\n    var e_1, _a;\n    var i = 0;\n    try {\n        for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {\n            var oldItem = list_1_1.value;\n            if (util_1.isFunction(conditionOrItem)) {\n                if (!!conditionOrItem.call(null, oldItem)) {\n                    list[i] = newItem;\n                }\n            }\n            else if (oldItem === conditionOrItem) {\n                list[i] = newItem;\n                return;\n            }\n            i++;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\nexports.replace = replace;\n/**\n * Inserts the given item before the given index.\n *\n * @param list - a list\n * @param item - an item\n */\nfunction insert(list, item, index) {\n    list.splice(index, 0, item);\n}\nexports.insert = insert;\n/**\n * Removes the given item or all items matching condition.\n *\n * @param list - a list\n * @param conditionOrItem - an item to remove or a condition matching items\n * to remove\n */\nfunction remove(list, conditionOrItem) {\n    var i = list.length;\n    while (i--) {\n        var oldItem = list[i];\n        if (util_1.isFunction(conditionOrItem)) {\n            if (!!conditionOrItem.call(null, oldItem)) {\n                list.splice(i, 1);\n            }\n        }\n        else if (oldItem === conditionOrItem) {\n            list.splice(i, 1);\n            return;\n        }\n    }\n}\nexports.remove = remove;\n/**\n * Removes all items from the list.\n */\nfunction empty(list) {\n    list.length = 0;\n}\nexports.empty = empty;\n/**\n * Determines if the list contains the given item or any items matching\n * condition.\n *\n * @param list - a list\n * @param conditionOrItem - an item to a condition to match\n */\nfunction contains(list, conditionOrItem) {\n    var e_2, _a;\n    try {\n        for (var list_2 = __values(list), list_2_1 = list_2.next(); !list_2_1.done; list_2_1 = list_2.next()) {\n            var oldItem = list_2_1.value;\n            if (util_1.isFunction(conditionOrItem)) {\n                if (!!conditionOrItem.call(null, oldItem)) {\n                    return true;\n                }\n            }\n            else if (oldItem === conditionOrItem) {\n                return true;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (list_2_1 && !list_2_1.done && (_a = list_2.return)) _a.call(list_2);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return false;\n}\nexports.contains = contains;\n/**\n * Returns the count of items in the list matching the given condition.\n *\n * @param list - a list\n * @param condition - an optional condition to match\n */\nfunction size(list, condition) {\n    var e_3, _a;\n    if (condition === undefined) {\n        return list.length;\n    }\n    else {\n        var count = 0;\n        try {\n            for (var list_3 = __values(list), list_3_1 = list_3.next(); !list_3_1.done; list_3_1 = list_3.next()) {\n                var item = list_3_1.value;\n                if (!!condition.call(null, item)) {\n                    count++;\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (list_3_1 && !list_3_1.done && (_a = list_3.return)) _a.call(list_3);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return count;\n    }\n}\nexports.size = size;\n/**\n * Determines if the list is empty.\n *\n * @param list - a list\n */\nfunction isEmpty(list) {\n    return list.length === 0;\n}\nexports.isEmpty = isEmpty;\n/**\n * Returns an iterator for the items of the list.\n *\n * @param list - a list\n * @param condition - an optional condition to match\n */\nfunction forEach(list, condition) {\n    var list_4, list_4_1, item, e_4_1;\n    var e_4, _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!(condition === undefined)) return [3 /*break*/, 2];\n                return [5 /*yield**/, __values(list)];\n            case 1:\n                _b.sent();\n                return [3 /*break*/, 9];\n            case 2:\n                _b.trys.push([2, 7, 8, 9]);\n                list_4 = __values(list), list_4_1 = list_4.next();\n                _b.label = 3;\n            case 3:\n                if (!!list_4_1.done) return [3 /*break*/, 6];\n                item = list_4_1.value;\n                if (!!!condition.call(null, item)) return [3 /*break*/, 5];\n                return [4 /*yield*/, item];\n            case 4:\n                _b.sent();\n                _b.label = 5;\n            case 5:\n                list_4_1 = list_4.next();\n                return [3 /*break*/, 3];\n            case 6: return [3 /*break*/, 9];\n            case 7:\n                e_4_1 = _b.sent();\n                e_4 = { error: e_4_1 };\n                return [3 /*break*/, 9];\n            case 8:\n                try {\n                    if (list_4_1 && !list_4_1.done && (_a = list_4.return)) _a.call(list_4);\n                }\n                finally { if (e_4) throw e_4.error; }\n                return [7 /*endfinally*/];\n            case 9: return [2 /*return*/];\n        }\n    });\n}\nexports.forEach = forEach;\n/**\n * Creates and returns a shallow clone of list.\n *\n * @param list - a list\n */\nfunction clone(list) {\n    return new (Array.bind.apply(Array, __spread([void 0], list)))();\n}\nexports.clone = clone;\n/**\n * Returns a new list containing items from the list sorted in ascending\n * order.\n *\n * @param list - a list\n * @param lessThanAlgo - a function that returns `true` if its first argument\n * is less than its second argument, and `false` otherwise.\n */\nfunction sortInAscendingOrder(list, lessThanAlgo) {\n    return list.sort(function (itemA, itemB) {\n        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;\n    });\n}\nexports.sortInAscendingOrder = sortInAscendingOrder;\n/**\n * Returns a new list containing items from the list sorted in descending\n * order.\n *\n * @param list - a list\n * @param lessThanAlgo - a function that returns `true` if its first argument\n * is less than its second argument, and `false` otherwise.\n */\nfunction sortInDescendingOrder(list, lessThanAlgo) {\n    return list.sort(function (itemA, itemB) {\n        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;\n    });\n}\nexports.sortInDescendingOrder = sortInDescendingOrder;\n//# sourceMappingURL=List.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Gets the value corresponding to the given key.\n *\n * @param map - a map\n * @param key - a key\n */\nfunction get(map, key) {\n    return map.get(key);\n}\nexports.get = get;\n/**\n * Sets the value corresponding to the given key.\n *\n * @param map - a map\n * @param key - a key\n * @param val - a value\n */\nfunction set(map, key, val) {\n    map.set(key, val);\n}\nexports.set = set;\n/**\n * Removes the item with the given key or all items matching condition.\n *\n * @param map - a map\n * @param conditionOrItem - the key of an item to remove or a condition matching\n * items to remove\n */\nfunction remove(map, conditionOrItem) {\n    var e_1, _a, e_2, _b;\n    if (!util_1.isFunction(conditionOrItem)) {\n        map.delete(conditionOrItem);\n    }\n    else {\n        var toRemove = [];\n        try {\n            for (var map_1 = __values(map), map_1_1 = map_1.next(); !map_1_1.done; map_1_1 = map_1.next()) {\n                var item = map_1_1.value;\n                if (!!conditionOrItem.call(null, item)) {\n                    toRemove.push(item[0]);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (map_1_1 && !map_1_1.done && (_a = map_1.return)) _a.call(map_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        try {\n            for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {\n                var key = toRemove_1_1.value;\n                map.delete(key);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n}\nexports.remove = remove;\n/**\n * Determines if the map contains a value with the given key.\n *\n * @param map - a map\n * @param conditionOrItem - the key of an item to match or a condition matching\n * items\n */\nfunction contains(map, conditionOrItem) {\n    var e_3, _a;\n    if (!util_1.isFunction(conditionOrItem)) {\n        return map.has(conditionOrItem);\n    }\n    else {\n        try {\n            for (var map_2 = __values(map), map_2_1 = map_2.next(); !map_2_1.done; map_2_1 = map_2.next()) {\n                var item = map_2_1.value;\n                if (!!conditionOrItem.call(null, item)) {\n                    return true;\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (map_2_1 && !map_2_1.done && (_a = map_2.return)) _a.call(map_2);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return false;\n    }\n}\nexports.contains = contains;\n/**\n * Gets the keys of the map.\n *\n * @param map - a map\n */\nfunction keys(map) {\n    return new Set(map.keys());\n}\nexports.keys = keys;\n/**\n * Gets the values of the map.\n *\n * @param map - a map\n */\nfunction values(map) {\n    return __spread(map.values());\n}\nexports.values = values;\n/**\n * Gets the size of the map.\n *\n * @param map - a map\n * @param condition - an optional condition to match\n */\nfunction size(map, condition) {\n    var e_4, _a;\n    if (condition === undefined) {\n        return map.size;\n    }\n    else {\n        var count = 0;\n        try {\n            for (var map_3 = __values(map), map_3_1 = map_3.next(); !map_3_1.done; map_3_1 = map_3.next()) {\n                var item = map_3_1.value;\n                if (!!condition.call(null, item)) {\n                    count++;\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (map_3_1 && !map_3_1.done && (_a = map_3.return)) _a.call(map_3);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return count;\n    }\n}\nexports.size = size;\n/**\n * Determines if the map is empty.\n *\n * @param map - a map\n */\nfunction isEmpty(map) {\n    return map.size === 0;\n}\nexports.isEmpty = isEmpty;\n/**\n * Returns an iterator for the items of the map.\n *\n * @param map - a map\n * @param condition - an optional condition to match\n */\nfunction forEach(map, condition) {\n    var map_4, map_4_1, item, e_5_1;\n    var e_5, _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!(condition === undefined)) return [3 /*break*/, 2];\n                return [5 /*yield**/, __values(map)];\n            case 1:\n                _b.sent();\n                return [3 /*break*/, 9];\n            case 2:\n                _b.trys.push([2, 7, 8, 9]);\n                map_4 = __values(map), map_4_1 = map_4.next();\n                _b.label = 3;\n            case 3:\n                if (!!map_4_1.done) return [3 /*break*/, 6];\n                item = map_4_1.value;\n                if (!!!condition.call(null, item)) return [3 /*break*/, 5];\n                return [4 /*yield*/, item];\n            case 4:\n                _b.sent();\n                _b.label = 5;\n            case 5:\n                map_4_1 = map_4.next();\n                return [3 /*break*/, 3];\n            case 6: return [3 /*break*/, 9];\n            case 7:\n                e_5_1 = _b.sent();\n                e_5 = { error: e_5_1 };\n                return [3 /*break*/, 9];\n            case 8:\n                try {\n                    if (map_4_1 && !map_4_1.done && (_a = map_4.return)) _a.call(map_4);\n                }\n                finally { if (e_5) throw e_5.error; }\n                return [7 /*endfinally*/];\n            case 9: return [2 /*return*/];\n        }\n    });\n}\nexports.forEach = forEach;\n/**\n * Creates and returns a shallow clone of map.\n *\n * @param map - a map\n */\nfunction clone(map) {\n    return new Map(map);\n}\nexports.clone = clone;\n/**\n * Returns a new map containing items from the map sorted in ascending\n * order.\n *\n * @param map - a map\n * @param lessThanAlgo - a function that returns `true` if its first argument\n * is less than its second argument, and `false` otherwise.\n */\nfunction sortInAscendingOrder(map, lessThanAlgo) {\n    var list = new (Array.bind.apply(Array, __spread([void 0], map)))();\n    list.sort(function (itemA, itemB) {\n        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;\n    });\n    return new Map(list);\n}\nexports.sortInAscendingOrder = sortInAscendingOrder;\n/**\n * Returns a new map containing items from the map sorted in descending\n * order.\n *\n * @param map - a map\n * @param lessThanAlgo - a function that returns `true` if its first argument\n * is less than its second argument, and `false` otherwise.\n */\nfunction sortInDescendingOrder(map, lessThanAlgo) {\n    var list = new (Array.bind.apply(Array, __spread([void 0], map)))();\n    list.sort(function (itemA, itemB) {\n        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;\n    });\n    return new Map(list);\n}\nexports.sortInDescendingOrder = sortInDescendingOrder;\n//# sourceMappingURL=Map.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTML = \"http://www.w3.org/1999/xhtml\";\nexports.XML = \"http://www.w3.org/XML/1998/namespace\";\nexports.XMLNS = \"http://www.w3.org/2000/xmlns/\";\nexports.MathML = \"http://www.w3.org/1998/Math/MathML\";\nexports.SVG = \"http://www.w3.org/2000/svg\";\nexports.XLink = \"http://www.w3.org/1999/xlink\";\n//# sourceMappingURL=Namespace.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Appends the given item to the queue.\n *\n * @param list - a list\n * @param item - an item\n */\nfunction enqueue(list, item) {\n    list.push(item);\n}\nexports.enqueue = enqueue;\n/**\n * Removes and returns an item from the queue.\n *\n * @param list - a list\n */\nfunction dequeue(list) {\n    return list.shift() || null;\n}\nexports.dequeue = dequeue;\n//# sourceMappingURL=Queue.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Adds the given item to the end of the set.\n *\n * @param set - a set\n * @param item - an item\n */\nfunction append(set, item) {\n    set.add(item);\n}\nexports.append = append;\n/**\n * Extends a set by appending all items from another set.\n *\n * @param setA - a list to extend\n * @param setB - a list containing items to append to `setA`\n */\nfunction extend(setA, setB) {\n    setB.forEach(setA.add, setA);\n}\nexports.extend = extend;\n/**\n * Inserts the given item to the start of the set.\n *\n * @param set - a set\n * @param item - an item\n */\nfunction prepend(set, item) {\n    var cloned = new Set(set);\n    set.clear();\n    set.add(item);\n    cloned.forEach(set.add, set);\n}\nexports.prepend = prepend;\n/**\n * Replaces the given item or all items matching condition with a new item.\n *\n * @param set - a set\n * @param conditionOrItem - an item to replace or a condition matching items\n * to replace\n * @param item - an item\n */\nfunction replace(set, conditionOrItem, newItem) {\n    var e_1, _a;\n    var newSet = new Set();\n    try {\n        for (var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {\n            var oldItem = set_1_1.value;\n            if (util_1.isFunction(conditionOrItem)) {\n                if (!!conditionOrItem.call(null, oldItem)) {\n                    newSet.add(newItem);\n                }\n                else {\n                    newSet.add(oldItem);\n                }\n            }\n            else if (oldItem === conditionOrItem) {\n                newSet.add(newItem);\n            }\n            else {\n                newSet.add(oldItem);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    set.clear();\n    newSet.forEach(set.add, set);\n}\nexports.replace = replace;\n/**\n * Inserts the given item before the given index.\n *\n * @param set - a set\n * @param item - an item\n */\nfunction insert(set, item, index) {\n    var e_2, _a;\n    var newSet = new Set();\n    var i = 0;\n    try {\n        for (var set_2 = __values(set), set_2_1 = set_2.next(); !set_2_1.done; set_2_1 = set_2.next()) {\n            var oldItem = set_2_1.value;\n            if (i === index)\n                newSet.add(item);\n            newSet.add(oldItem);\n            i++;\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (set_2_1 && !set_2_1.done && (_a = set_2.return)) _a.call(set_2);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    set.clear();\n    newSet.forEach(set.add, set);\n}\nexports.insert = insert;\n/**\n * Removes the given item or all items matching condition.\n *\n * @param set - a set\n * @param conditionOrItem - an item to remove or a condition matching items\n * to remove\n */\nfunction remove(set, conditionOrItem) {\n    var e_3, _a, e_4, _b;\n    if (!util_1.isFunction(conditionOrItem)) {\n        set.delete(conditionOrItem);\n    }\n    else {\n        var toRemove = [];\n        try {\n            for (var set_3 = __values(set), set_3_1 = set_3.next(); !set_3_1.done; set_3_1 = set_3.next()) {\n                var item = set_3_1.value;\n                if (!!conditionOrItem.call(null, item)) {\n                    toRemove.push(item);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (set_3_1 && !set_3_1.done && (_a = set_3.return)) _a.call(set_3);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        try {\n            for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {\n                var oldItem = toRemove_1_1.value;\n                set.delete(oldItem);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    }\n}\nexports.remove = remove;\n/**\n * Removes all items from the set.\n */\nfunction empty(set) {\n    set.clear();\n}\nexports.empty = empty;\n/**\n * Determines if the set contains the given item or any items matching\n * condition.\n *\n * @param set - a set\n * @param conditionOrItem - an item to a condition to match\n */\nfunction contains(set, conditionOrItem) {\n    var e_5, _a;\n    if (!util_1.isFunction(conditionOrItem)) {\n        return set.has(conditionOrItem);\n    }\n    else {\n        try {\n            for (var set_4 = __values(set), set_4_1 = set_4.next(); !set_4_1.done; set_4_1 = set_4.next()) {\n                var oldItem = set_4_1.value;\n                if (!!conditionOrItem.call(null, oldItem)) {\n                    return true;\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (set_4_1 && !set_4_1.done && (_a = set_4.return)) _a.call(set_4);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n    }\n    return false;\n}\nexports.contains = contains;\n/**\n * Returns the count of items in the set matching the given condition.\n *\n * @param set - a set\n * @param condition - an optional condition to match\n */\nfunction size(set, condition) {\n    var e_6, _a;\n    if (condition === undefined) {\n        return set.size;\n    }\n    else {\n        var count = 0;\n        try {\n            for (var set_5 = __values(set), set_5_1 = set_5.next(); !set_5_1.done; set_5_1 = set_5.next()) {\n                var item = set_5_1.value;\n                if (!!condition.call(null, item)) {\n                    count++;\n                }\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (set_5_1 && !set_5_1.done && (_a = set_5.return)) _a.call(set_5);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        return count;\n    }\n}\nexports.size = size;\n/**\n * Determines if the set is empty.\n *\n * @param set - a set\n */\nfunction isEmpty(set) {\n    return set.size === 0;\n}\nexports.isEmpty = isEmpty;\n/**\n * Returns an iterator for the items of the set.\n *\n * @param set - a set\n * @param condition - an optional condition to match\n */\nfunction forEach(set, condition) {\n    var set_6, set_6_1, item, e_7_1;\n    var e_7, _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!(condition === undefined)) return [3 /*break*/, 2];\n                return [5 /*yield**/, __values(set)];\n            case 1:\n                _b.sent();\n                return [3 /*break*/, 9];\n            case 2:\n                _b.trys.push([2, 7, 8, 9]);\n                set_6 = __values(set), set_6_1 = set_6.next();\n                _b.label = 3;\n            case 3:\n                if (!!set_6_1.done) return [3 /*break*/, 6];\n                item = set_6_1.value;\n                if (!!!condition.call(null, item)) return [3 /*break*/, 5];\n                return [4 /*yield*/, item];\n            case 4:\n                _b.sent();\n                _b.label = 5;\n            case 5:\n                set_6_1 = set_6.next();\n                return [3 /*break*/, 3];\n            case 6: return [3 /*break*/, 9];\n            case 7:\n                e_7_1 = _b.sent();\n                e_7 = { error: e_7_1 };\n                return [3 /*break*/, 9];\n            case 8:\n                try {\n                    if (set_6_1 && !set_6_1.done && (_a = set_6.return)) _a.call(set_6);\n                }\n                finally { if (e_7) throw e_7.error; }\n                return [7 /*endfinally*/];\n            case 9: return [2 /*return*/];\n        }\n    });\n}\nexports.forEach = forEach;\n/**\n * Creates and returns a shallow clone of set.\n *\n * @param set - a set\n */\nfunction clone(set) {\n    return new Set(set);\n}\nexports.clone = clone;\n/**\n * Returns a new set containing items from the set sorted in ascending\n * order.\n *\n * @param set - a set\n * @param lessThanAlgo - a function that returns `true` if its first argument\n * is less than its second argument, and `false` otherwise.\n */\nfunction sortInAscendingOrder(set, lessThanAlgo) {\n    var list = new (Array.bind.apply(Array, __spread([void 0], set)))();\n    list.sort(function (itemA, itemB) {\n        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;\n    });\n    return new Set(list);\n}\nexports.sortInAscendingOrder = sortInAscendingOrder;\n/**\n * Returns a new set containing items from the set sorted in descending\n * order.\n *\n * @param set - a set\n * @param lessThanAlgo - a function that returns `true` if its first argument\n * is less than its second argument, and `false` otherwise.\n */\nfunction sortInDescendingOrder(set, lessThanAlgo) {\n    var list = new (Array.bind.apply(Array, __spread([void 0], set)))();\n    list.sort(function (itemA, itemB) {\n        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;\n    });\n    return new Set(list);\n}\nexports.sortInDescendingOrder = sortInDescendingOrder;\n/**\n * Determines if a set is a subset of another set.\n *\n * @param subset - a set\n * @param superset - a superset possibly containing all items from `subset`.\n */\nfunction isSubsetOf(subset, superset) {\n    var e_8, _a;\n    try {\n        for (var subset_1 = __values(subset), subset_1_1 = subset_1.next(); !subset_1_1.done; subset_1_1 = subset_1.next()) {\n            var item = subset_1_1.value;\n            if (!superset.has(item))\n                return false;\n        }\n    }\n    catch (e_8_1) { e_8 = { error: e_8_1 }; }\n    finally {\n        try {\n            if (subset_1_1 && !subset_1_1.done && (_a = subset_1.return)) _a.call(subset_1);\n        }\n        finally { if (e_8) throw e_8.error; }\n    }\n    return true;\n}\nexports.isSubsetOf = isSubsetOf;\n/**\n * Determines if a set is a superset of another set.\n *\n * @param superset - a set\n * @param subset - a subset possibly contained within `superset`.\n */\nfunction isSupersetOf(superset, subset) {\n    return isSubsetOf(subset, superset);\n}\nexports.isSupersetOf = isSupersetOf;\n/**\n * Returns a new set with items that are contained in both sets.\n *\n * @param setA - a set\n * @param setB - a set\n */\nfunction intersection(setA, setB) {\n    var e_9, _a;\n    var newSet = new Set();\n    try {\n        for (var setA_1 = __values(setA), setA_1_1 = setA_1.next(); !setA_1_1.done; setA_1_1 = setA_1.next()) {\n            var item = setA_1_1.value;\n            if (setB.has(item))\n                newSet.add(item);\n        }\n    }\n    catch (e_9_1) { e_9 = { error: e_9_1 }; }\n    finally {\n        try {\n            if (setA_1_1 && !setA_1_1.done && (_a = setA_1.return)) _a.call(setA_1);\n        }\n        finally { if (e_9) throw e_9.error; }\n    }\n    return newSet;\n}\nexports.intersection = intersection;\n/**\n * Returns a new set with items from both sets.\n *\n * @param setA - a set\n * @param setB - a set\n */\nfunction union(setA, setB) {\n    var newSet = new Set(setA);\n    setB.forEach(newSet.add, newSet);\n    return newSet;\n}\nexports.union = union;\n/**\n * Returns a set of integers from `n` to `m` inclusive.\n *\n * @param n - starting number\n * @param m - ending number\n */\nfunction range(n, m) {\n    var newSet = new Set();\n    for (var i = n; i <= m; i++) {\n        newSet.add(i);\n    }\n    return newSet;\n}\nexports.range = range;\n//# sourceMappingURL=Set.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Pushes the given item to the stack.\n *\n * @param list - a list\n * @param item - an item\n */\nfunction push(list, item) {\n    list.push(item);\n}\nexports.push = push;\n/**\n * Pops and returns an item from the stack.\n *\n * @param list - a list\n */\nfunction pop(list) {\n    return list.pop() || null;\n}\nexports.pop = pop;\n//# sourceMappingURL=Stack.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CodePoints_1 = require(\"./CodePoints\");\nvar ByteSequence_1 = require(\"./ByteSequence\");\nvar Byte_1 = require(\"./Byte\");\nvar util_1 = require(\"@oozcitak/util\");\n/**\n * Determines if the string `a` is a code unit prefix of string `b`.\n *\n * @param a - a string\n * @param b - a string\n */\nfunction isCodeUnitPrefix(a, b) {\n    /**\n     * 1. Let i be 0.\n     * 2. While true:\n     * 2.1. Let aCodeUnit be the ith code unit of a if i is less than a’s length;\n     * otherwise null.\n     * 2.2. Let bCodeUnit be the ith code unit of b if i is less than b’s length;\n     * otherwise null.\n     * 2.3. If bCodeUnit is null, then return true.\n     * 2.4. Return false if aCodeUnit is different from bCodeUnit.\n     * 2.5. Set i to i + 1.\n     */\n    var i = 0;\n    while (true) {\n        var aCodeUnit = i < a.length ? a.charCodeAt(i) : null;\n        var bCodeUnit = i < b.length ? b.charCodeAt(i) : null;\n        if (aCodeUnit === null)\n            return true;\n        if (aCodeUnit !== bCodeUnit)\n            return false;\n        i++;\n    }\n}\nexports.isCodeUnitPrefix = isCodeUnitPrefix;\n/**\n * Determines if the string `a` is a code unit less than string `b`.\n *\n * @param a - a string\n * @param b - a string\n */\nfunction isCodeUnitLessThan(a, b) {\n    /**\n     * 1. If b is a code unit prefix of a, then return false.\n     * 2. If a is a code unit prefix of b, then return true.\n     * 3. Let n be the smallest index such that the nth code unit of a is\n     * different from the nth code unit of b. (There has to be such an index,\n     * since neither string is a prefix of the other.)\n     * 4. If the nth code unit of a is less than the nth code unit of b, then\n     * return true.\n     * 5. Return false.\n     */\n    if (isCodeUnitPrefix(b, a))\n        return false;\n    if (isCodeUnitPrefix(a, b))\n        return true;\n    for (var i = 0; i < Math.min(a.length, b.length); i++) {\n        var aCodeUnit = a.charCodeAt(i);\n        var bCodeUnit = b.charCodeAt(i);\n        if (aCodeUnit === bCodeUnit)\n            continue;\n        return (aCodeUnit < bCodeUnit);\n    }\n    /* istanbul ignore next */\n    return false;\n}\nexports.isCodeUnitLessThan = isCodeUnitLessThan;\n/**\n * Isomorphic encodes the given string.\n *\n * @param str - a string\n */\nfunction isomorphicEncode(str) {\n    var e_1, _a;\n    /**\n     * 1. Assert: input contains no code points greater than U+00FF.\n     * 2. Return a byte sequence whose length is equal to input’s length and whose\n     * bytes have the same values as input’s code points, in the same order.\n     */\n    var codePoints = Array.from(str);\n    var bytes = new Uint8Array(codePoints.length);\n    var i = 0;\n    try {\n        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n            var codePoint = str_1_1.value;\n            var byte = codePoint.codePointAt(0);\n            console.assert(byte !== undefined && byte <= 0x00FF, \"isomorphicEncode requires string bytes to be less than or equal to 0x00FF.\");\n            if (byte !== undefined && byte <= 0x00FF) {\n                bytes[i++] = byte;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return bytes;\n}\nexports.isomorphicEncode = isomorphicEncode;\n/**\n * Determines if the given string is An ASCII string.\n *\n * @param str - a string\n */\nfunction isASCIIString(str) {\n    /**\n     * An ASCII string is a string whose code points are all ASCII code points.\n     */\n    return /^[\\u0000-\\u007F]*$/.test(str);\n}\nexports.isASCIIString = isASCIIString;\n/**\n * Converts all uppercase ASCII code points to lowercase.\n *\n * @param str - a string\n */\nfunction asciiLowercase(str) {\n    var e_2, _a;\n    /**\n     * To ASCII lowercase a string, replace all ASCII upper alphas in the string\n     * with their corresponding code point in ASCII lower alpha.\n     */\n    var result = \"\";\n    try {\n        for (var str_2 = __values(str), str_2_1 = str_2.next(); !str_2_1.done; str_2_1 = str_2.next()) {\n            var c = str_2_1.value;\n            var code = c.codePointAt(0);\n            if (code !== undefined && code >= 0x41 && code <= 0x5A) {\n                result += String.fromCodePoint(code + 0x20);\n            }\n            else {\n                result += c;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (str_2_1 && !str_2_1.done && (_a = str_2.return)) _a.call(str_2);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return result;\n}\nexports.asciiLowercase = asciiLowercase;\n/**\n * Converts all uppercase ASCII code points to uppercase.\n *\n * @param str - a string\n */\nfunction asciiUppercase(str) {\n    var e_3, _a;\n    /**\n     * To ASCII uppercase a string, replace all ASCII lower alphas in the string\n     * with their corresponding code point in ASCII upper alpha.\n     */\n    var result = \"\";\n    try {\n        for (var str_3 = __values(str), str_3_1 = str_3.next(); !str_3_1.done; str_3_1 = str_3.next()) {\n            var c = str_3_1.value;\n            var code = c.codePointAt(0);\n            if (code !== undefined && code >= 0x61 && code <= 0x7A) {\n                result += String.fromCodePoint(code - 0x20);\n            }\n            else {\n                result += c;\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (str_3_1 && !str_3_1.done && (_a = str_3.return)) _a.call(str_3);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return result;\n}\nexports.asciiUppercase = asciiUppercase;\n/**\n * Compares two ASCII strings case-insensitively.\n *\n * @param a - a string\n * @param b - a string\n */\nfunction asciiCaseInsensitiveMatch(a, b) {\n    /**\n     * A string A is an ASCII case-insensitive match for a string B, if the ASCII\n     * lowercase of A is the ASCII lowercase of B.\n     */\n    return asciiLowercase(a) === asciiLowercase(b);\n}\nexports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;\n/**\n * ASCII encodes a string.\n *\n * @param str - a string\n */\nfunction asciiEncode(str) {\n    /**\n     * 1. Assert: input is an ASCII string.\n     * 2. Return the isomorphic encoding of input.\n     */\n    console.assert(isASCIIString(str), \"asciiEncode requires an ASCII string.\");\n    return isomorphicEncode(str);\n}\nexports.asciiEncode = asciiEncode;\n/**\n * ASCII decodes a byte sequence.\n *\n * @param bytes - a byte sequence\n */\nfunction asciiDecode(bytes) {\n    var e_4, _a;\n    try {\n        /**\n         * 1. Assert: All bytes in input are ASCII bytes.\n         * 2. Return the isomorphic decoding of input.\n         */\n        for (var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {\n            var byte = bytes_1_1.value;\n            console.assert(Byte_1.isASCIIByte(byte), \"asciiDecode requires an ASCII byte sequence.\");\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return ByteSequence_1.isomorphicDecode(bytes);\n}\nexports.asciiDecode = asciiDecode;\n/**\n * Strips newline characters from a string.\n *\n * @param str - a string\n */\nfunction stripNewlines(str) {\n    /**\n     * To strip newlines from a string, remove any U+000A LF and U+000D CR code\n     * points from the string.\n     */\n    return str.replace(/[\\n\\r]/g, \"\");\n}\nexports.stripNewlines = stripNewlines;\n/**\n * Normalizes newline characters in a string by converting consecutive\n * carriage-return newline characters and also single carriage return characters\n * into a single newline.\n *\n * @param str - a string\n */\nfunction normalizeNewlines(str) {\n    /**\n     * To normalize newlines in a string, replace every U+000D CR U+000A LF code\n     * point pair with a single U+000A LF code point, and then replace every\n     * remaining U+000D CR code point with a U+000A LF code point.\n     */\n    return str.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n}\nexports.normalizeNewlines = normalizeNewlines;\n/**\n * Removes leading and trailing whitespace characters from a string.\n *\n * @param str - a string\n */\nfunction stripLeadingAndTrailingASCIIWhitespace(str) {\n    /**\n     * To strip leading and trailing ASCII whitespace from a string, remove all\n     * ASCII whitespace that are at the start or the end of the string.\n     */\n    return str.replace(/^[\\t\\n\\f\\r ]+/, \"\").replace(/[\\t\\n\\f\\r ]+$/, \"\");\n}\nexports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;\n/**\n * Removes consecutive newline characters from a string.\n *\n * @param str - a string\n */\nfunction stripAndCollapseASCIIWhitespace(str) {\n    /**\n     * To strip and collapse ASCII whitespace in a string, replace any sequence of\n     * one or more consecutive code points that are ASCII whitespace in the string\n     * with a single U+0020 SPACE code point, and then remove any leading and\n     * trailing ASCII whitespace from that string.\n     */\n    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\\t\\n\\f\\r ]{2,}/g, \" \"));\n}\nexports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;\n/**\n * Collects a sequence of code points matching a given condition from the input\n * string.\n *\n * @param condition - a condition to match\n * @param input - a string\n * @param options - starting position\n */\nfunction collectASequenceOfCodePoints(condition, input, options) {\n    /**\n     * 1. Let result be the empty string.\n     * 2. While position doesn’t point past the end of input and the code point at\n     * position within input meets the condition condition:\n     * 2.1. Append that code point to the end of result.\n     * 2.2. Advance position by 1.\n     * 3. Return result.\n     */\n    if (!util_1.isArray(input))\n        return collectASequenceOfCodePoints(condition, Array.from(input), options);\n    var result = \"\";\n    while (options.position < input.length && !!condition.call(null, input[options.position])) {\n        result += input[options.position];\n        options.position++;\n    }\n    return result;\n}\nexports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;\n/**\n * Skips over ASCII whitespace.\n *\n * @param input - input string\n * @param options - starting position\n */\nfunction skipASCIIWhitespace(input, options) {\n    /**\n     * To skip ASCII whitespace within a string input given a position variable\n     * position, collect a sequence of code points that are ASCII whitespace from\n     * input given position. The collected code points are not used, but position\n     * is still updated.\n     */\n    collectASequenceOfCodePoints(function (str) { return CodePoints_1.ASCIIWhiteSpace.test(str); }, input, options);\n}\nexports.skipASCIIWhitespace = skipASCIIWhitespace;\n/**\n * Solits a string at the given delimiter.\n *\n * @param input - input string\n * @param delimiter - a delimiter string\n */\nfunction strictlySplit(input, delimiter) {\n    /**\n     * 1. Let position be a position variable for input, initially pointing at the\n     * start of input.\n     * 2. Let tokens be a list of strings, initially empty.\n     * 3. Let token be the result of collecting a sequence of code points that are\n     * not equal to delimiter from input, given position.\n     * 4. Append token to tokens.\n     * 5. While position is not past the end of input:\n     * 5.1. Assert: the code point at position within input is delimiter.\n     * 5.2. Advance position by 1.\n     * 5.3. Let token be the result of collecting a sequence of code points that\n     * are not equal to delimiter from input, given position.\n     * 5.4. Append token to tokens.\n     * 6. Return tokens.\n     */\n    if (!util_1.isArray(input))\n        return strictlySplit(Array.from(input), delimiter);\n    var options = { position: 0 };\n    var tokens = [];\n    var token = collectASequenceOfCodePoints(function (str) { return delimiter !== str; }, input, options);\n    tokens.push(token);\n    while (options.position < input.length) {\n        console.assert(input[options.position] === delimiter, \"strictlySplit found no delimiter in input string.\");\n        options.position++;\n        token = collectASequenceOfCodePoints(function (str) { return delimiter !== str; }, input, options);\n        tokens.push(token);\n    }\n    return tokens;\n}\nexports.strictlySplit = strictlySplit;\n/**\n * Splits a string on ASCII whitespace.\n *\n * @param input - a string\n */\nfunction splitAStringOnASCIIWhitespace(input) {\n    /**\n     * 1. Let position be a position variable for input, initially pointing at the\n     * start of input.\n     * 2. Let tokens be a list of strings, initially empty.\n     * 3. Skip ASCII whitespace within input given position.\n     * 4. While position is not past the end of input:\n     * 4.1. Let token be the result of collecting a sequence of code points that\n     * are not ASCII whitespace from input, given position.\n     * 4.2. Append token to tokens.\n     * 4.3. Skip ASCII whitespace within input given position.\n     * 5. Return tokens.\n     */\n    if (!util_1.isArray(input))\n        return splitAStringOnASCIIWhitespace(Array.from(input));\n    var options = { position: 0 };\n    var tokens = [];\n    skipASCIIWhitespace(input, options);\n    while (options.position < input.length) {\n        var token = collectASequenceOfCodePoints(function (str) { return !CodePoints_1.ASCIIWhiteSpace.test(str); }, input, options);\n        tokens.push(token);\n        skipASCIIWhitespace(input, options);\n    }\n    return tokens;\n}\nexports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;\n/**\n * Splits a string on commas.\n *\n * @param input - a string\n */\nfunction splitAStringOnCommas(input) {\n    /**\n     * 1. Let position be a position variable for input, initially pointing at the\n     * start of input.\n     * 2. Let tokens be a list of strings, initially empty.\n     * 3. While position is not past the end of input:\n     * 3.1. Let token be the result of collecting a sequence of code points that\n     * are not U+002C (,) from input, given position.\n     * 3.2. Strip leading and trailing ASCII whitespace from token.\n     * 3.3. Append token to tokens.\n     * 3.4. If position is not past the end of input, then:\n     * 3.4.1. Assert: the code point at position within input is U+002C (,).\n     * 3.4.2. Advance position by 1.\n     * 4. Return tokens.\n     */\n    if (!util_1.isArray(input))\n        return splitAStringOnCommas(Array.from(input));\n    var options = { position: 0 };\n    var tokens = [];\n    while (options.position < input.length) {\n        var token = collectASequenceOfCodePoints(function (str) { return str !== ','; }, input, options);\n        tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));\n        if (options.position < input.length) {\n            console.assert(input[options.position] === ',', \"splitAStringOnCommas found no delimiter in input string.\");\n            options.position++;\n        }\n    }\n    return tokens;\n}\nexports.splitAStringOnCommas = splitAStringOnCommas;\n/**\n * Concatenates a list of strings with the given separator.\n *\n * @param list - a list of strings\n * @param separator - a separator string\n */\nfunction concatenate(list, separator) {\n    if (separator === void 0) { separator = \"\"; }\n    /**\n     * 1. If list is empty, then return the empty string.\n     * 2. If separator is not given, then set separator to the empty string.\n     * 3. Return a string whose contents are list’s items, in order, separated\n     * from each other by separator.\n     */\n    if (list.length === 0)\n        return \"\";\n    return list.join(separator);\n}\nexports.concatenate = concatenate;\n//# sourceMappingURL=String.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base64 = __importStar(require(\"./Base64\"));\nexports.base64 = base64;\nvar byte = __importStar(require(\"./Byte\"));\nexports.byte = byte;\nvar byteSequence = __importStar(require(\"./ByteSequence\"));\nexports.byteSequence = byteSequence;\nvar codePoint = __importStar(require(\"./CodePoints\"));\nexports.codePoint = codePoint;\nvar json = __importStar(require(\"./JSON\"));\nexports.json = json;\nvar list = __importStar(require(\"./List\"));\nexports.list = list;\nvar map = __importStar(require(\"./Map\"));\nexports.map = map;\nvar namespace = __importStar(require(\"./Namespace\"));\nexports.namespace = namespace;\nvar queue = __importStar(require(\"./Queue\"));\nexports.queue = queue;\nvar set = __importStar(require(\"./Set\"));\nexports.set = set;\nvar stack = __importStar(require(\"./Stack\"));\nexports.stack = stack;\nvar string = __importStar(require(\"./String\"));\nexports.string = string;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar interfaces_1 = require(\"./interfaces\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar url_1 = require(\"url\");\nvar _validationErrorCallback;\n/**\n * Default ports for a special URL scheme.\n */\nvar _defaultPorts = {\n    \"ftp\": 21,\n    \"file\": null,\n    \"http\": 80,\n    \"https\": 443,\n    \"ws\": 80,\n    \"wss\": 443\n};\n/**\n * The C0 control percent-encode set are the C0 controls and all code points\n * greater than U+007E (~).\n */\nvar _c0ControlPercentEncodeSet = /[\\0-\\x1F\\x7F-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n/**\n * The fragment percent-encode set is the C0 control percent-encode set and\n * U+0020 SPACE, U+0022 (\"), U+003C (<), U+003E (>), and U+0060 (`).\n */\nvar _fragmentPercentEncodeSet = /[ \"<>`]|[\\0-\\x1F\\x7F-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n/**\n * The path percent-encode set is the fragment percent-encode set and\n * U+0023 (#), U+003F (?), U+007B ({), and U+007D (}).\n */\nvar _pathPercentEncodeSet = /[ \"<>`#?{}]|[\\0-\\x1F\\x7F-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n/**\n * The userinfo percent-encode set is the path percent-encode set and\n * U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([),\n * U+005C (\\), U+005D (]), U+005E (^), and U+007C (|).\n */\nvar _userInfoPercentEncodeSet = /[ \"<>`#?{}/:;=@\\[\\]\\\\\\^\\|]|[\\0-\\x1F\\x7F-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n/**\n * The URL code points are ASCII alphanumeric, U+0021 (!), U+0024 ($),\n * U+0026 (&), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS,\n * U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/),\n * U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_),\n * U+007E (~), and code points in the range U+00A0 to U+10FFFD, inclusive,\n * excluding surrogates and noncharacters.\n */\nvar _urlCodePoints = /[0-9A-Za-z!\\$&-\\/:;=\\?@_~\\xA0-\\uD7FF\\uE000-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB40-\\uDB7E\\uDB80-\\uDBBE\\uDBC0-\\uDBFE][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDC00-\\uDFFD]/;\n/**\n * A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF,\n * U+000D CR, U+0020 SPACE, U+0023 (#), U+0025 (%), U+002F (/), U+003A (:),\n * U+003F (?), U+0040 (@), U+005B ([), U+005C (\\), or U+005D (]).\n */\nvar _forbiddenHostCodePoint = /[\\0\\t\\f\\r #%/:?@\\[\\\\\\]]/;\n/**\n * Sets the callback function for validation errors.\n *\n * @param validationErrorCallback - a callback function to be called when a\n * validation error occurs\n */\nfunction setValidationErrorCallback(validationErrorCallback) {\n    _validationErrorCallback = validationErrorCallback;\n}\nexports.setValidationErrorCallback = setValidationErrorCallback;\n/**\n * Generates a validation error.\n *\n * @param message - error message\n */\nfunction validationError(message) {\n    if (_validationErrorCallback !== undefined) {\n        _validationErrorCallback.call(null, \"Validation Error: \" + message);\n    }\n}\n/**\n * Creates a new URL.\n */\nfunction newURL() {\n    return {\n        scheme: '',\n        username: '',\n        password: '',\n        host: null,\n        port: null,\n        path: [],\n        query: null,\n        fragment: null,\n        _cannotBeABaseURLFlag: false,\n        _blobURLEntry: null\n    };\n}\nexports.newURL = newURL;\n/**\n * Determines if the scheme is a special scheme.\n *\n * @param scheme - a scheme\n */\nfunction isSpecialScheme(scheme) {\n    return (scheme in _defaultPorts);\n}\nexports.isSpecialScheme = isSpecialScheme;\n/**\n * Determines if the URL has a special scheme.\n *\n * @param url - an URL\n */\nfunction isSpecial(url) {\n    return isSpecialScheme(url.scheme);\n}\nexports.isSpecial = isSpecial;\n/**\n * Returns the default port for a special scheme.\n *\n * @param scheme - a scheme\n */\nfunction defaultPort(scheme) {\n    return _defaultPorts[scheme] || null;\n}\nexports.defaultPort = defaultPort;\n/**\n * Determines if the URL has credentials.\n *\n * @param url - an URL\n */\nfunction includesCredentials(url) {\n    return url.username !== '' || url.password !== '';\n}\nexports.includesCredentials = includesCredentials;\n/**\n * Determines if an URL cannot have credentials.\n *\n * @param url - an URL\n */\nfunction cannotHaveAUsernamePasswordPort(url) {\n    /**\n     * A URL cannot have a username/password/port if its host is null or the\n     * empty string, its cannot-be-a-base-URL flag is set, or its scheme is\n     * \"file\".\n     */\n    return (url.host === null || url.host === \"\" || url._cannotBeABaseURLFlag ||\n        url.scheme === \"file\");\n}\nexports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\n/**\n * Serializes an URL into a string.\n *\n * @param url - an URL\n */\nfunction urlSerializer(url, excludeFragmentFlag) {\n    var e_1, _a;\n    if (excludeFragmentFlag === void 0) { excludeFragmentFlag = false; }\n    /**\n     * 1. Let output be url’s scheme and U+003A (:) concatenated.\n     */\n    var output = url.scheme + ':';\n    /**\n     * 2. If url’s host is non-null:\n     */\n    if (url.host !== null) {\n        /**\n         * 2.1. Append \"//\" to output.\n         */\n        output += '//';\n        /**\n         * 2.2. If url includes credentials, then:\n         */\n        if (includesCredentials(url)) {\n            /**\n             * 2.2.1. Append url’s username to output.\n             * 2.2.2. If url’s password is not the empty string, then append U+003A (:),\n             * followed by url’s password, to output.\n             * 2.2.3. Append U+0040 (@) to output.\n             */\n            output += url.username;\n            if (url.password !== '') {\n                output += ':' + url.password;\n            }\n            output += '@';\n        }\n        /**\n         * 2.3. Append url’s host, serialized, to output.\n         * 2.4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n         * serialized, to output.\n         */\n        output += hostSerializer(url.host);\n        if (url.port !== null) {\n            output += ':' + url.port;\n        }\n    }\n    else if (url.host === null && url.scheme === \"file\") {\n        /**\n         * 3. Otherwise, if url’s host is null and url’s scheme is \"file\", append \"//\" to output.\n         */\n        output += '//';\n    }\n    /**\n     * 4. If url’s cannot-be-a-base-URL flag is set, append url’s path[0] to\n     * output.\n     * 5. Otherwise, then for each string in url’s path, append U+002F (/)\n     * followed by the string to output.\n     */\n    if (url._cannotBeABaseURLFlag) {\n        output += url.path[0];\n    }\n    else {\n        try {\n            for (var _b = __values(url.path), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var str = _c.value;\n                output += '/' + str;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    /**\n     * 6. If url’s query is non-null, append U+003F (?), followed by url’s\n     * query, to output.\n     * 7. If the exclude fragment flag is unset and url’s fragment is non-null,\n     * append U+0023 (#), followed by url’s fragment, to output.\n     * 8. Return output.\n     */\n    if (url.query !== null) {\n        output += '?' + url.query;\n    }\n    if (!excludeFragmentFlag && url.fragment !== null) {\n        output += '#' + url.fragment;\n    }\n    return output;\n}\nexports.urlSerializer = urlSerializer;\n/**\n * Serializes a host into a string.\n *\n * @param host - a host\n */\nfunction hostSerializer(host) {\n    /**\n     * 1. If host is an IPv4 address, return the result of running the IPv4\n     * serializer on host.\n     * 2. Otherwise, if host is an IPv6 address, return U+005B ([), followed\n     * by the result of running the IPv6 serializer on host, followed by\n     * U+005D (]).\n     * 3. Otherwise, host is a domain, opaque host, or empty host, return host.\n     */\n    if (util_1.isNumber(host)) {\n        return iPv4Serializer(host);\n    }\n    else if (util_1.isArray(host)) {\n        return '[' + iPv6Serializer(host) + ']';\n    }\n    else {\n        return host;\n    }\n}\nexports.hostSerializer = hostSerializer;\n/**\n * Serializes an IPv4 address into a string.\n *\n * @param address  - an IPv4 address\n */\nfunction iPv4Serializer(address) {\n    /**\n     * 1. Let output be the empty string.\n     * 2. Let n be the value of address.\n     * 3. For each i in the range 1 to 4, inclusive:\n     * 3.1. Prepend n % 256, serialized, to output.\n     * 3.2. If i is not 4, then prepend U+002E (.) to output.\n     * 3.3. Set n to floor(n / 256).\n     * 4. Return output.\n     */\n    var output = \"\";\n    var n = address;\n    for (var i = 1; i <= 4; i++) {\n        output = (n % 256).toString() + output;\n        if (i !== 4) {\n            output = '.' + output;\n        }\n        n = Math.floor(n / 256);\n    }\n    return output;\n}\nexports.iPv4Serializer = iPv4Serializer;\n/**\n * Serializes an IPv6 address into a string.\n *\n * @param address  - an IPv6 address represented as a list of eight numbers\n */\nfunction iPv6Serializer(address) {\n    /**\n     * 1. Let output be the empty string.\n     * 2. Let compress be an index to the first IPv6 piece in the first longest\n     * sequences of address’s IPv6 pieces that are 0.\n     * In 0:f:0:0:f:f:0:0 it would point to the second 0.\n     * 3. If there is no sequence of address’s IPv6 pieces that are 0 that is\n     * longer than 1, then set compress to null.\n     */\n    var output = \"\";\n    var compress = null;\n    var lastIndex = -1;\n    var count = 0;\n    var lastCount = 0;\n    for (var i = 0; i < 8; i++) {\n        if (address[i] !== 0)\n            continue;\n        count = 1;\n        for (var j = i + 1; j < 8; j++) {\n            if (address[j] !== 0)\n                break;\n            count++;\n            continue;\n        }\n        if (count > lastCount) {\n            lastCount = count;\n            lastIndex = i;\n        }\n    }\n    if (lastCount > 1)\n        compress = lastIndex;\n    /**\n     * 4. Let ignore0 be false.\n     * 5. For each pieceIndex in the range 0 to 7, inclusive:\n     */\n    var ignore0 = false;\n    for (var pieceIndex = 0; pieceIndex < 8; pieceIndex++) {\n        /**\n         * 5.1. If ignore0 is true and address[pieceIndex] is 0, then continue.\n         * 5.2. Otherwise, if ignore0 is true, set ignore0 to false.\n         * 5.3. If compress is pieceIndex, then:\n         */\n        if (ignore0 && address[pieceIndex] === 0)\n            continue;\n        if (ignore0)\n            ignore0 = false;\n        if (compress === pieceIndex) {\n            /**\n             * 5.3.1. Let separator be \"::\" if pieceIndex is 0, and U+003A (:) otherwise.\n             * 5.3.2. Append separator to output.\n             * 5.3.3. Set ignore0 to true and continue.\n             */\n            output += (pieceIndex === 0 ? '::' : ':');\n            ignore0 = true;\n            continue;\n        }\n        /**\n         * 5.4. Append address[pieceIndex], represented as the shortest possible\n         * lowercase hexadecimal number, to output.\n         * 5.5. If pieceIndex is not 7, then append U+003A (:) to output.\n         */\n        output += address[pieceIndex].toString(16);\n        if (pieceIndex !== 7)\n            output += ':';\n    }\n    /**\n     * 6. Return output.\n     */\n    return output;\n}\nexports.iPv6Serializer = iPv6Serializer;\n/**\n * Parses an URL string.\n *\n * @param input - input string\n * @param baseURL - base URL\n * @param encodingOverride - encoding override\n */\nfunction urlParser(input, baseURL, encodingOverride) {\n    /**\n     * 1. Let url be the result of running the basic URL parser on input with\n     * base, and encoding override as provided.\n     * 2. If url is failure, return failure.\n     * 3. If url’s scheme is not \"blob\", return url.\n     * 4. Set url’s blob URL entry to the result of resolving the blob URL url,\n     * if that did not return failure, and null otherwise.\n     * 5. Return url.\n     */\n    var url = basicURLParser(input, baseURL, encodingOverride);\n    if (url === null)\n        return null;\n    if (url.scheme !== \"blob\")\n        return url;\n    var entry = resolveABlobURL(url);\n    if (entry !== null) {\n        url._blobURLEntry = entry;\n    }\n    else {\n        url._blobURLEntry = null;\n    }\n    return url;\n}\nexports.urlParser = urlParser;\n/**\n * Parses an URL string.\n *\n * @param input - input string\n * @param baseURL - base URL\n * @param encodingOverride - encoding override\n */\nfunction basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {\n    var e_2, _a, e_3, _b;\n    /**\n     * 1. If url is not given:\n     * 1.1. Set url to a new URL.\n     * 1.2. If input contains any leading or trailing C0 control or space,\n     * validation error.\n     * 1.3. Remove any leading and trailing C0 control or space from input.\n     */\n    if (url === undefined) {\n        url = newURL();\n        // leading\n        var leadingControlOrSpace = /^[\\u0000-\\u001F\\u0020]+/;\n        var trailingControlOrSpace = /[\\u0000-\\u001F\\u0020]+$/;\n        if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {\n            validationError(\"Input string contains leading or trailing control characters or space.\");\n        }\n        input = input.replace(leadingControlOrSpace, '');\n        input = input.replace(trailingControlOrSpace, '');\n    }\n    /**\n     * 2. If input contains any ASCII tab or newline, validation error.\n     * 3. Remove all ASCII tab or newline from input.\n     */\n    var tabOrNewline = /[\\u0009\\u000A\\u000D]/g;\n    if (tabOrNewline.test(input)) {\n        validationError(\"Input string contains tab or newline characters.\");\n    }\n    input = input.replace(tabOrNewline, '');\n    /**\n     * 4. Let state be state override if given, or scheme start state otherwise.\n     * 5. If base is not given, set it to null.\n     * 6. Let encoding be UTF-8.\n     * 7. If encoding override is given, set encoding to the result of getting\n     * an output encoding from encoding override.\n     */\n    var state = (stateOverride === undefined ? interfaces_1.ParserState.SchemeStart : stateOverride);\n    if (baseURL === undefined)\n        baseURL = null;\n    var encoding = (encodingOverride === undefined ||\n        encodingOverride === \"replacement\" || encodingOverride === \"UTF-16BE\" ||\n        encodingOverride === \"UTF-16LE\" ? \"UTF-8\" : encodingOverride);\n    /**\n     * 8. Let buffer be the empty string.\n     * 9. Let the @ flag, [] flag, and passwordTokenSeenFlag be unset.\n     * 10. Let pointer be a pointer to first code point in input.\n     */\n    var buffer = \"\";\n    var atFlag = false;\n    var arrayFlag = false;\n    var passwordTokenSeenFlag = false;\n    var EOF = \"\";\n    var walker = new util_1.StringWalker(input);\n    /**\n     * 11. Keep running the following state machine by switching on state. If\n     * after a run pointer points to the EOF code point, go to the next step.\n     * Otherwise, increase pointer by one and continue with the state machine.\n     */\n    while (true) {\n        switch (state) {\n            case interfaces_1.ParserState.SchemeStart:\n                /**\n                 * 1. If c is an ASCII alpha, append c, lowercased, to buffer, and set\n                 * state to scheme state.\n                 * 2. Otherwise, if state override is not given, set state to no scheme\n                 * state, and decrease pointer by one.\n                 * 3. Otherwise, validation error, return failure.\n                 */\n                if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {\n                    buffer += walker.c().toLowerCase();\n                    state = interfaces_1.ParserState.Scheme;\n                }\n                else if (stateOverride === undefined) {\n                    state = interfaces_1.ParserState.NoScheme;\n                    walker.pointer--;\n                }\n                else {\n                    validationError(\"Invalid scheme start character.\");\n                    return null;\n                }\n                break;\n            case interfaces_1.ParserState.Scheme:\n                /**\n                 * 1. If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E\n                 * (.), append c, lowercased, to buffer.\n                 */\n                if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) ||\n                    walker.c() === '+' || walker.c() === '-' || walker.c() === '.') {\n                    buffer += walker.c().toLowerCase();\n                }\n                else if (walker.c() === ':') {\n                    /**\n                     * 2. Otherwise, if c is U+003A (:), then:\n                     * 2.1. If state override is given, then:\n                     * 2.1.1. If url’s scheme is a special scheme and buffer is not a\n                     * special scheme, then return.\n                     * 2.1.2. If url’s scheme is not a special scheme and buffer is a\n                     * special scheme, then return.\n                     * 2.1.3. If url includes credentials or has a non-null port, and\n                     * buffer is \"file\", then return.\n                     * 2.1.4. If url’s scheme is \"file\" and its host is an empty host or\n                     * null, then return.\n                     */\n                    if (stateOverride !== undefined) {\n                        if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))\n                            return url;\n                        if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))\n                            return url;\n                        if ((includesCredentials(url) || url.port !== null) && buffer === \"file\")\n                            return url;\n                        if (url.scheme === \"file\" && (url.host === \"\" || url.host === null))\n                            return url;\n                    }\n                    /**\n                     * 2.2. Set url’s scheme to buffer.\n                     */\n                    url.scheme = buffer;\n                    /**\n                     * 2.3. If state override is given, then:\n                     * 2.3.1. If url’s port is url’s scheme’s default port, then set\n                     * url’s port to null.\n                     * 2.3.2. Return.\n                     */\n                    if (stateOverride !== undefined) {\n                        if (url.port === defaultPort(url.scheme)) {\n                            url.port = null;\n                        }\n                        return url;\n                    }\n                    /**\n                     * 2.4. Set buffer to the empty string.\n                     */\n                    buffer = \"\";\n                    if (url.scheme === \"file\") {\n                        /**\n                         * 2.5. If url’s scheme is \"file\", then:\n                         * 2.5.1. If remaining does not start with \"//\", validation error.\n                         * 2.5.2. Set state to file state.\n                         */\n                        if (!walker.remaining().startsWith(\"//\")) {\n                            validationError(\"Invalid file URL scheme, '//' expected.\");\n                        }\n                        state = interfaces_1.ParserState.File;\n                    }\n                    else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {\n                        /**\n                         * 2.6. Otherwise, if url is special, base is non-null, and base’s\n                         * scheme is equal to url’s scheme, set state to special relative\n                         * or authority state.\n                         */\n                        state = interfaces_1.ParserState.SpecialRelativeOrAuthority;\n                    }\n                    else if (isSpecial(url)) {\n                        /**\n                         * 2.7. Otherwise, if url is special, set state to special\n                         * authority slashes state.\n                         */\n                        state = interfaces_1.ParserState.SpecialAuthoritySlashes;\n                    }\n                    else if (walker.remaining().startsWith(\"/\")) {\n                        /**\n                         * 2.8. Otherwise, if remaining starts with an U+002F (/), set state\n                         * to path or authority state and increase pointer by one.\n                         */\n                        state = interfaces_1.ParserState.PathOrAuthority;\n                        walker.pointer++;\n                    }\n                    else {\n                        /**\n                         * 2.9. Otherwise, set url’s cannot-be-a-base-URL flag, append an\n                         * empty string to url’s path, and set state to\n                         * cannot-be-a-base-URL path state.\n                         */\n                        url._cannotBeABaseURLFlag = true;\n                        url.path.push(\"\");\n                        state = interfaces_1.ParserState.CannotBeABaseURLPath;\n                    }\n                }\n                else if (stateOverride === undefined) {\n                    /**\n                     * 3. Otherwise, if state override is not given, set buffer to the\n                     * empty string, state to no scheme state, and start over (from the\n                     * first code point in input).\n                     */\n                    buffer = \"\";\n                    state = interfaces_1.ParserState.NoScheme;\n                    walker.pointer = 0;\n                    continue;\n                }\n                else {\n                    /**\n                     * 4. Otherwise, validation error, return failure.\n                     */\n                    validationError(\"Invalid input string.\");\n                    return null;\n                }\n                break;\n            case interfaces_1.ParserState.NoScheme:\n                /**\n                 * 1. If base is null, or base’s cannot-be-a-base-URL flag is set\n                 * and c is not U+0023 (#), validation error, return failure.\n                 * 2. Otherwise, if base’s cannot-be-a-base-URL flag is set and\n                 * c is U+0023 (#), set url’s scheme to base’s scheme, url’s path to\n                 * a copy of base’s path, url’s query to base’s query, url’s\n                 * fragment to the empty string, set url’s cannot-be-a-base-URL\n                 * flag, and set state to fragment state.\n                 * 3. Otherwise, if base’s scheme is not \"file\", set state to\n                 * relative state and decrease pointer by one.\n                 * 4. Otherwise, set state to file state and decrease pointer by one.\n                 */\n                if (baseURL === null || (baseURL._cannotBeABaseURLFlag && walker.c() !== '#')) {\n                    validationError(\"Invalid input string.\");\n                    return null;\n                }\n                else if (baseURL._cannotBeABaseURLFlag && walker.c() === '#') {\n                    url.scheme = baseURL.scheme;\n                    url.path = infra_1.list.clone(baseURL.path);\n                    url.query = baseURL.query;\n                    url.fragment = \"\";\n                    url._cannotBeABaseURLFlag = true;\n                    state = interfaces_1.ParserState.Fragment;\n                }\n                else if (baseURL.scheme !== \"file\") {\n                    state = interfaces_1.ParserState.Relative;\n                    walker.pointer--;\n                }\n                else {\n                    state = interfaces_1.ParserState.File;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.SpecialRelativeOrAuthority:\n                /**\n                 * If c is U+002F (/) and remaining starts with U+002F (/), then set\n                 * state to special authority ignore slashes state and increase\n                 * pointer by one.\n                 * Otherwise, validation error, set state to relative state and\n                 * decrease pointer by one.\n                 */\n                if (walker.c() === '/' && walker.remaining().startsWith('/')) {\n                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;\n                    walker.pointer++;\n                }\n                else {\n                    validationError(\"Invalid input string.\");\n                    state = interfaces_1.ParserState.Relative;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.PathOrAuthority:\n                /**\n                 * If c is U+002F (/), then set state to authority state.\n                 * Otherwise, set state to path state, and decrease pointer by one.\n                 */\n                if (walker.c() === '/') {\n                    state = interfaces_1.ParserState.Authority;\n                }\n                else {\n                    state = interfaces_1.ParserState.Path;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.Relative:\n                /**\n                 * Set url’s scheme to base’s scheme, and then, switching on c:\n                 */\n                if (baseURL === null) {\n                    throw new Error(\"Invalid parser state. Base URL is null.\");\n                }\n                url.scheme = baseURL.scheme;\n                switch (walker.c()) {\n                    case EOF: // EOF\n                        /**\n                         * Set url’s username to base’s username, url’s password to base’s\n                         * password, url’s host to base’s host, url’s port to base’s port,\n                         * url’s path to a copy of base’s path, and url’s query to base’s\n                         * query.\n                         */\n                        url.username = baseURL.username;\n                        url.password = baseURL.password;\n                        url.host = baseURL.host;\n                        url.port = baseURL.port;\n                        url.path = infra_1.list.clone(baseURL.path);\n                        url.query = baseURL.query;\n                        break;\n                    case '/':\n                        /**\n                         * Set state to relative slash state.\n                         */\n                        state = interfaces_1.ParserState.RelativeSlash;\n                        break;\n                    case '?':\n                        /**\n                         * Set url’s username to base’s username, url’s password to base’s\n                         * password, url’s host to base’s host, url’s port to base’s port,\n                         * url’s path to a copy of base’s path, url’s query to the empty\n                         * string, and state to query state.\n                         */\n                        url.username = baseURL.username;\n                        url.password = baseURL.password;\n                        url.host = baseURL.host;\n                        url.port = baseURL.port;\n                        url.path = infra_1.list.clone(baseURL.path);\n                        url.query = \"\";\n                        state = interfaces_1.ParserState.Query;\n                        break;\n                    case '#':\n                        /**\n                         * Set url’s username to base’s username, url’s password to base’s\n                         * password, url’s host to base’s host, url’s port to base’s port,\n                         * url’s path to a copy of base’s path, url’s query to base’s\n                         * query, url’s fragment to the empty string, and state to\n                         * fragment state.\n                         */\n                        url.username = baseURL.username;\n                        url.password = baseURL.password;\n                        url.host = baseURL.host;\n                        url.port = baseURL.port;\n                        url.path = infra_1.list.clone(baseURL.path);\n                        url.query = baseURL.query;\n                        url.fragment = \"\";\n                        state = interfaces_1.ParserState.Fragment;\n                        break;\n                    default:\n                        /**\n                         * If url is special and c is U+005C (\\), validation error,\n                         * set state to relative slash state.\n                         * Otherwise, run these steps:\n                         * 1. Set url’s username to base’s username, url’s password to\n                         * base’s password, url’s host to base’s host, url’s port to\n                         * base’s port, url’s path to a copy of base’s path, and then\n                         * remove url’s path’s last item, if any.\n                         * 2. Set state to path state, and decrease pointer by one.\n                         */\n                        if (isSpecial(url) && walker.c() === '\\\\') {\n                            validationError(\"Invalid input string.\");\n                            state = interfaces_1.ParserState.RelativeSlash;\n                        }\n                        else {\n                            url.username = baseURL.username;\n                            url.password = baseURL.password;\n                            url.host = baseURL.host;\n                            url.port = baseURL.port;\n                            url.path = infra_1.list.clone(baseURL.path);\n                            if (url.path.length !== 0)\n                                url.path.splice(url.path.length - 1, 1);\n                            state = interfaces_1.ParserState.Path;\n                            walker.pointer--;\n                        }\n                        break;\n                }\n                break;\n            case interfaces_1.ParserState.RelativeSlash:\n                /**\n                 * 1. If url is special and c is U+002F (/) or U+005C (\\), then:\n                 * 1.1. If c is U+005C (\\), validation error.\n                 * 1.2. Set state to special authority ignore slashes state.\n                 * 2. Otherwise, if c is U+002F (/), then set state to authority state.\n                 * 3. Otherwise, set url’s username to base’s username, url’s password\n                 * to base’s password, url’s host to base’s host, url’s port to base’s\n                 * port, state to path state, and then, decrease pointer by one.\n                 */\n                if (isSpecial(url) && (walker.c() === '/' || walker.c() === '\\\\')) {\n                    if (walker.c() === '\\\\') {\n                        validationError(\"Invalid input string.\");\n                    }\n                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;\n                }\n                else if (walker.c() === '/') {\n                    state = interfaces_1.ParserState.Authority;\n                }\n                else {\n                    if (baseURL === null) {\n                        throw new Error(\"Invalid parser state. Base URL is null.\");\n                    }\n                    url.username = baseURL.username;\n                    url.password = baseURL.password;\n                    url.host = baseURL.host;\n                    url.port = baseURL.port;\n                    state = interfaces_1.ParserState.Path;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.SpecialAuthoritySlashes:\n                /**\n                 * If c is U+002F (/) and remaining starts with U+002F (/), then set\n                 * state to special authority ignore slashes state and increase\n                 * pointer by one.\n                 * Otherwise, validation error, set state to special authority ignore\n                 * slashes state, and decrease pointer by one.\n                 */\n                if (walker.c() === '/' && walker.remaining().startsWith('/')) {\n                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;\n                    walker.pointer++;\n                }\n                else {\n                    validationError(\"Expected '//'.\");\n                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:\n                /**\n                 * If c is neither U+002F (/) nor U+005C (\\), then set state to\n                 * authority state and decrease pointer by one.\n                 * Otherwise, validation error.\n                 */\n                if (walker.c() !== '/' && walker.c() !== '\\\\') {\n                    state = interfaces_1.ParserState.Authority;\n                    walker.pointer--;\n                }\n                else {\n                    validationError(\"Unexpected '/' or '\\\\'.\");\n                }\n                break;\n            case interfaces_1.ParserState.Authority:\n                /**\n                 * 1. If c is U+0040 (@), then:\n                 */\n                if (walker.c() === '@') {\n                    /**\n                     * 1.1. Validation error.\n                     * 1.2. If the @ flag is set, prepend \"%40\" to buffer.\n                     * 1.3. Set the @ flag.\n                     * 1.4. For each codePoint in buffer:\n                     */\n                    validationError(\"Unexpected '@'.\");\n                    if (atFlag)\n                        buffer = '%40' + buffer;\n                    atFlag = true;\n                    try {\n                        for (var buffer_1 = (e_2 = void 0, __values(buffer)), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {\n                            var codePoint = buffer_1_1.value;\n                            /**\n                             * 1.4.1. If codePoint is U+003A (:) and passwordTokenSeenFlag is\n                             * unset, then set passwordTokenSeenFlag and continue.\n                             * 1.4.2. Let encodedCodePoints be the result of running UTF-8\n                             * percent encode codePoint using the userinfo percent-encode set.\n                             * 1.4.3. If passwordTokenSeenFlag is set, then append\n                             * encodedCodePoints to url’s password.\n                             * 1.4.4. Otherwise, append encodedCodePoints to url’s username.\n                             */\n                            if (codePoint === ':' && !passwordTokenSeenFlag) {\n                                passwordTokenSeenFlag = true;\n                                continue;\n                            }\n                            var encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);\n                            if (passwordTokenSeenFlag) {\n                                url.password += encodedCodePoints;\n                            }\n                            else {\n                                url.username += encodedCodePoints;\n                            }\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    /**\n                     * 1.5. Set buffer to the empty string.\n                     */\n                    buffer = \"\";\n                }\n                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||\n                    (isSpecial(url) && walker.c() === '\\\\')) {\n                    /**\n                     * 2. Otherwise, if one of the following is true\n                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)\n                     * - url is special and c is U+005C (\\)\n                     * then:\n                     * 2.1. If @ flag is set and buffer is the empty string, validation\n                     * error, return failure.\n                     * 2.2. Decrease pointer by the number of code points in buffer plus\n                     * one, set buffer to the empty string, and set state to host state.\n                     */\n                    if (atFlag && buffer === \"\") {\n                        validationError(\"Invalid input string.\");\n                        return null;\n                    }\n                    walker.pointer -= (buffer.length + 1);\n                    buffer = \"\";\n                    state = interfaces_1.ParserState.Host;\n                }\n                else {\n                    /**\n                     * 3. Otherwise, append c to buffer.\n                     */\n                    buffer += walker.c();\n                }\n                break;\n            case interfaces_1.ParserState.Host:\n            case interfaces_1.ParserState.Hostname:\n                if (stateOverride !== undefined && url.scheme === \"file\") {\n                    /**\n                     * 1. If state override is given and url’s scheme is \"file\", then\n                     * decrease pointer by one and set state to file host state.\n                     */\n                    walker.pointer--;\n                    state = interfaces_1.ParserState.FileHost;\n                }\n                else if (walker.c() === ':' && !arrayFlag) {\n                    /**\n                     * 2. Otherwise, if c is U+003A (:) and the [] flag is unset, then:\n                     * 2.1. If buffer is the empty string, validation error, return\n                     * failure.\n                     * 2.2. Let host be the result of host parsing buffer with url is\n                     * not special.\n                     * 2.3. If host is failure, then return failure.\n                     * 2.4. Set url’s host to host, buffer to the empty string, and\n                     * state to port state.\n                     * 2.5. If state override is given and state override is hostname\n                     * state, then return.\n                     */\n                    if (buffer === \"\") {\n                        validationError(\"Invalid input string.\");\n                        return null;\n                    }\n                    var host = hostParser(buffer, !isSpecial(url));\n                    if (host === null)\n                        return null;\n                    url.host = host;\n                    buffer = \"\";\n                    state = interfaces_1.ParserState.Port;\n                    if (stateOverride === interfaces_1.ParserState.Hostname)\n                        return url;\n                }\n                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||\n                    (isSpecial(url) && walker.c() === '\\\\')) {\n                    /**\n                     * 3. Otherwise, if one of the following is true\n                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)\n                     * - url is special and c is U+005C (\\)\n                     * then decrease pointer by one, and then:\n                     * 3.1. If url is special and buffer is the empty string, validation\n                     * error, return failure.\n                     * 3.2. Otherwise, if state override is given, buffer is the empty\n                     * string, and either url includes credentials or url’s port is\n                     * non-null, validation error, return.\n                     * 3.3. Let host be the result of host parsing buffer with url is\n                     * not special.\n                     * 3.4. If host is failure, then return failure.\n                     * 3.5. Set url’s host to host, buffer to the empty string, and\n                     * state to path start state.\n                     * 3.6. If state override is given, then return.\n                     */\n                    walker.pointer--;\n                    if (isSpecial(url) && buffer === \"\") {\n                        validationError(\"Invalid input string.\");\n                        return null;\n                    }\n                    else if (stateOverride !== undefined && buffer === \"\" &&\n                        (includesCredentials(url) || url.port !== null)) {\n                        validationError(\"Invalid input string.\");\n                        return url;\n                    }\n                    var host = hostParser(buffer, !isSpecial(url));\n                    if (host === null)\n                        return null;\n                    url.host = host;\n                    buffer = \"\";\n                    state = interfaces_1.ParserState.PathStart;\n                    if (stateOverride !== undefined)\n                        return url;\n                }\n                else {\n                    /**\n                     * 4. Otherwise:\n                     * 4.1. If c is U+005B ([), then set the [] flag.\n                     * 4.2. If c is U+005D (]), then unset the [] flag.\n                     * 4.3. Append c to buffer.\n                     */\n                    if (walker.c() === '[')\n                        arrayFlag = true;\n                    if (walker.c() === ']')\n                        arrayFlag = false;\n                    buffer += walker.c();\n                }\n                break;\n            case interfaces_1.ParserState.Port:\n                if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {\n                    /**\n                     * 1. If c is an ASCII digit, append c to buffer.\n                     */\n                    buffer += walker.c();\n                }\n                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||\n                    (isSpecial(url) && walker.c() === '\\\\') || stateOverride) {\n                    /**\n                     * 2. Otherwise, if one of the following is true\n                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)\n                     * - url is special and c is U+005C (\\)\n                     * - state override is given\n                     * then:\n                     */\n                    if (buffer !== \"\") {\n                        /**\n                         * 2.1. If buffer is not the empty string, then:\n                         * 2.1.1. Let port be the mathematical integer value that is\n                         * represented by buffer in radix-10 using ASCII digits for digits\n                         * with values 0 through 9.\n                         * 2.1.2. If port is greater than 2**16 − 1, validation error,\n                         * return failure.\n                         * 2.1.3. Set url’s port to null, if port is url’s scheme’s default\n                         * port, and to port otherwise.\n                         * 2.1.4. Set buffer to the empty string.\n                         */\n                        if (buffer !== \"\") {\n                            var port = parseInt(buffer, 10);\n                            if (port > Math.pow(2, 16) - 1) {\n                                validationError(\"Invalid port number.\");\n                                return null;\n                            }\n                            url.port = (port === defaultPort(url.scheme) ? null : port);\n                            buffer = \"\";\n                        }\n                    }\n                    /**\n                     * 2.2. If state override is given, then return.\n                     * 2.3. Set state to path start state, and decrease pointer by one.\n                     */\n                    if (stateOverride !== undefined) {\n                        return url;\n                    }\n                    state = interfaces_1.ParserState.PathStart;\n                    walker.pointer--;\n                }\n                else {\n                    /**\n                     * 3. Otherwise, validation error, return failure.\n                     */\n                    validationError(\"Invalid input string.\");\n                    return null;\n                }\n                break;\n            case interfaces_1.ParserState.File:\n                /**\n                 * 1. Set url’s scheme to \"file\".\n                 */\n                url.scheme = \"file\";\n                if (walker.c() === '/' || walker.c() === '\\\\') {\n                    /**\n                     * 2. If c is U+002F (/) or U+005C (\\), then:\n                     * 2.1. If c is U+005C (\\), validation error.\n                     * 2.2. Set state to file slash state.\n                     */\n                    if (walker.c() === '\\\\') {\n                        validationError(\"Invalid input string.\");\n                    }\n                    state = interfaces_1.ParserState.FileSlash;\n                }\n                else if (baseURL !== null && baseURL.scheme === \"file\") {\n                    /**\n                     * 3. Otherwise, if base is non-null and base’s scheme is \"file\",\n                     * switch on c:\n                     */\n                    switch (walker.c()) {\n                        case EOF:\n                            /**\n                             * Set url’s host to base’s host, url’s path to a copy of base’s\n                             * path, and url’s query to base’s query.\n                             */\n                            url.host = baseURL.host;\n                            url.path = infra_1.list.clone(baseURL.path);\n                            url.query = baseURL.query;\n                            break;\n                        case '?':\n                            /**\n                             * Set url’s host to base’s host, url’s path to a copy of base’s\n                             * path, url’s query to the empty string, and state to query\n                             * state.\n                             */\n                            url.host = baseURL.host;\n                            url.path = infra_1.list.clone(baseURL.path);\n                            url.query = \"\";\n                            state = interfaces_1.ParserState.Query;\n                            break;\n                        case '#':\n                            /**\n                             * Set url’s host to base’s host, url’s path to a copy of base’s\n                             * path, url’s query to base’s query, url’s fragment to the\n                             * empty string, and state to fragment state.\n                             */\n                            url.host = baseURL.host;\n                            url.path = infra_1.list.clone(baseURL.path);\n                            url.query = baseURL.query;\n                            url.fragment = \"\";\n                            state = interfaces_1.ParserState.Fragment;\n                            break;\n                        default:\n                            /**\n                             * 1. If the substring from pointer in input does not start\n                             * with a Windows drive letter, then set url’s host to base’s\n                             * host, url’s path to a copy of base’s path, and then shorten\n                             * url’s path.\n                             * _Note:_ is a (platform-independent) Windows drive letter\n                             * quirk.\n                             * 2. Otherwise, validation error.\n                             * 3. Set state to path state, and decrease pointer by one.\n                             */\n                            if (!startsWithAWindowsDriveLetter(walker.substring())) {\n                                url.host = baseURL.host;\n                                url.path = infra_1.list.clone(baseURL.path);\n                                shorten(url);\n                            }\n                            else {\n                                validationError(\"Unexpected windows drive letter in input string.\");\n                            }\n                            state = interfaces_1.ParserState.Path;\n                            walker.pointer--;\n                            break;\n                    }\n                }\n                else {\n                    /**\n                     * 4. Otherwise, set state to path state, and decrease pointer by\n                     * one.\n                     */\n                    state = interfaces_1.ParserState.Path;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.FileSlash:\n                if (walker.c() === '/' || walker.c() === '\\\\') {\n                    /**\n                     * 1. If c is U+002F (/) or U+005C (\\), then:\n                     * 1.1. If c is U+005C (\\), validation error.\n                     * 1.2. Set state to file host state.\n                     */\n                    if (walker.c() === '\\\\') {\n                        validationError(\"Invalid input string.\");\n                    }\n                    state = interfaces_1.ParserState.FileHost;\n                }\n                else {\n                    /**\n                     * 2. Otherwise:\n                     * 2.1. If base is non-null, base’s scheme is \"file\", and the\n                     * substring from pointer in input does not start with a Windows\n                     * drive letter, then:\n                     * 2.1.1. If base’s path[0] is a normalized Windows drive letter,\n                     * then append base’s path[0] to url’s path.\n                     * _Note:_ is a (platform-independent) Windows drive letter\n                     * quirk. Both url’s and base’s host are null under these conditions\n                     * and therefore not copied.\n                     * 2.1.2. Otherwise, set url’s host to base’s host.\n                     * 2.2. Set state to path state, and decrease pointer by one.\n                     */\n                    if (baseURL !== null && baseURL.scheme === \"file\" &&\n                        !startsWithAWindowsDriveLetter(walker.substring())) {\n                        if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {\n                            url.path.push(baseURL.path[0]);\n                        }\n                        else {\n                            url.host = baseURL.host;\n                        }\n                    }\n                    state = interfaces_1.ParserState.Path;\n                    walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.FileHost:\n                if (walker.c() === EOF || walker.c() === '/' || walker.c() === '\\\\' ||\n                    walker.c() === '?' || walker.c() === '#') {\n                    /**\n                     * 1. If c is the EOF code point, U+002F (/), U+005C (\\), U+003F (?),\n                     * or U+0023 (#), then decrease pointer by one and then:\n                     */\n                    walker.pointer--;\n                    if (stateOverride === undefined && isWindowsDriveLetter(buffer)) {\n                        /**\n                         * 1.1. If state override is not given and buffer is a Windows drive\n                         * letter, validation error, set state to path state.\n                         * _Note:_ is a (platform-independent) Windows drive letter\n                         * quirk. buffer is not reset here and instead used in the path state.\n                         */\n                        validationError(\"Unexpected windows drive letter in input string.\");\n                        state = interfaces_1.ParserState.Path;\n                    }\n                    else if (buffer === \"\") {\n                        /**\n                         * 1.2. Otherwise, if buffer is the empty string, then:\n                         * 1.2.1. Set url’s host to the empty string.\n                         * 1.2.2. If state override is given, then return.\n                         * 1.2.3. Set state to path start state.\n                         */\n                        url.host = \"\";\n                        if (stateOverride !== undefined)\n                            return url;\n                        state = interfaces_1.ParserState.PathStart;\n                    }\n                    else {\n                        /**\n                         * 1.3. Otherwise, run these steps:\n                         * 1.3.1. Let host be the result of host parsing buffer with url\n                         * is not special.\n                         * 1.3.2. If host is failure, then return failure.\n                         * 1.3.3. If host is \"localhost\", then set host to the empty\n                         * string.\n                         * 1.3.4. Set url’s host to host.\n                         * 1.3.5. If state override is given, then return.\n                         * 1.3.6. Set buffer to the empty string and state to path start\n                         * state.\n                         */\n                        var host = hostParser(buffer, !isSpecial(url));\n                        if (host === null)\n                            return null;\n                        if (host === \"localhost\")\n                            host = \"\";\n                        url.host = host;\n                        if (stateOverride !== undefined)\n                            return url;\n                        buffer = \"\";\n                        state = interfaces_1.ParserState.PathStart;\n                    }\n                }\n                else {\n                    /**\n                     * 2. Otherwise, append c to buffer.\n                     */\n                    buffer += walker.c();\n                }\n                break;\n            case interfaces_1.ParserState.PathStart:\n                if (isSpecial(url)) {\n                    /**\n                     * 1. If url is special, then:\n                     * 1.1. If c is U+005C (\\), validation error.\n                     * 1.2. Set state to path state.\n                     * 1.3. If c is neither U+002F (/) nor U+005C (\\), then decrease\n                     * pointer by one.\n                     */\n                    if (walker.c() === '\\\\') {\n                        validationError(\"Invalid input string.\");\n                    }\n                    state = interfaces_1.ParserState.Path;\n                    if (walker.c() !== '/' && walker.c() !== '\\\\')\n                        walker.pointer--;\n                }\n                else if (stateOverride === undefined && walker.c() === '?') {\n                    /**\n                     * 2. Otherwise, if state override is not given and c is U+003F (?),\n                     * set url’s query to the empty string and state to query state.\n                     */\n                    url.query = \"\";\n                    state = interfaces_1.ParserState.Query;\n                }\n                else if (stateOverride === undefined && walker.c() === '#') {\n                    /**\n                     * 3. Otherwise, if state override is not given and c is U+0023 (#),\n                     * set url’s fragment to the empty string and state to fragment\n                     * state.\n                     */\n                    url.fragment = \"\";\n                    state = interfaces_1.ParserState.Fragment;\n                }\n                else if (walker.c() !== EOF) {\n                    /**\n                     * 4. Otherwise, if c is not the EOF code point:\n                     * 4.1. Set state to path state.\n                     * 4.2. If c is not U+002F (/), then decrease pointer by one.\n                     */\n                    state = interfaces_1.ParserState.Path;\n                    if (walker.c() !== '/')\n                        walker.pointer--;\n                }\n                break;\n            case interfaces_1.ParserState.Path:\n                if ((walker.c() === EOF || walker.c() === '/') ||\n                    (isSpecial(url) && walker.c() === '\\\\') ||\n                    (stateOverride === undefined && (walker.c() === '?' || walker.c() === '#'))) {\n                    /**\n                     * 1. If one of the following is true\n                     * - c is the EOF code point or U+002F (/)\n                     * - url is special and c is U+005C (\\)\n                     * - state override is not given and c is U+003F (?) or U+0023 (#)\n                     * then:\n                     */\n                    if (isSpecial(url) && walker.c() === '\\\\') {\n                        /**\n                         * 1.1 If url is special and c is U+005C (\\), validation error.\n                         */\n                        validationError(\"Invalid input string.\");\n                    }\n                    if (isDoubleDotPathSegment(buffer)) {\n                        /**\n                         * 1.2. If buffer is a double-dot path segment, shorten url’s path,\n                         * and then if neither c is U+002F (/), nor url is special and c is\n                         * U+005C (\\), append the empty string to url’s path.\n                         */\n                        shorten(url);\n                        if (walker.c() !== '/' && !(isSpecial(url) && walker.c() === '\\\\')) {\n                            url.path.push(\"\");\n                        }\n                    }\n                    else if (isSingleDotPathSegment(buffer) && walker.c() !== '/' &&\n                        !(isSpecial(url) && walker.c() === '\\\\')) {\n                        /**\n                         * 1.3. Otherwise, if buffer is a single-dot path segment and if\n                         * neither c is U+002F (/), nor url is special and c is U+005C (\\),\n                         * append the empty string to url’s path.\n                         */\n                        url.path.push(\"\");\n                    }\n                    else if (!isSingleDotPathSegment(buffer)) {\n                        /**\n                         * 1.4. Otherwise, if buffer is not a single-dot path segment, then:\n                         */\n                        if (url.scheme === \"file\" && url.path.length === 0 &&\n                            isWindowsDriveLetter(buffer)) {\n                            /**\n                             * 1.4.1. If url’s scheme is \"file\", url’s path is empty, and\n                             * buffer is a Windows drive letter, then:\n                             * 1.4.1.1. If url’s host is neither the empty string nor null,\n                             * validation error, set url’s host to the empty string.\n                             * 1.4.1.2. Replace the second code point in buffer with U+003A (:).\n                             * _Note:_ is a (platform-independent) Windows drive letter quirk.\n                             */\n                            if (url.host !== null && url.host !== \"\") {\n                                validationError(\"Invalid input string.\");\n                                url.host = \"\";\n                            }\n                            var bufferCodePoints = Array.from(buffer);\n                            buffer = bufferCodePoints.slice(0, 1) + ':' + bufferCodePoints.slice(2);\n                        }\n                        /**\n                         * 1.4.2. Append buffer to url’s path.\n                         */\n                        url.path.push(buffer);\n                    }\n                    /**\n                     * 1.5. Set buffer to the empty string.\n                     */\n                    buffer = \"\";\n                    /**\n                     * 1.6. If url’s scheme is \"file\" and c is the EOF code point,\n                     * U+003F (?), or U+0023 (#), then while url’s path’s size is\n                     * greater than 1 and url’s path[0] is the empty string, validation\n                     * error, remove the first item from url’s path.\n                     */\n                    if (url.scheme === \"file\" && (walker.c() === EOF || walker.c() === '?' || walker.c() === '#')) {\n                        while (url.path.length > 1 && url.path[0] === \"\") {\n                            validationError(\"Invalid input string.\");\n                            url.path.splice(0, 1);\n                        }\n                    }\n                    /**\n                     * 1.7. If c is U+003F (?), then set url’s query to the empty string\n                     * and state to query state.\n                     * 1.8. If c is U+0023 (#), then set url’s fragment to the empty\n                     * string and state to fragment state.\n                     */\n                    if (walker.c() === '?') {\n                        url.query = \"\";\n                        state = interfaces_1.ParserState.Query;\n                    }\n                    if (walker.c() === '#') {\n                        url.fragment = \"\";\n                        state = interfaces_1.ParserState.Fragment;\n                    }\n                }\n                else {\n                    /**\n                     * 2. Otherwise, run these steps:\n                     * 2.1. If c is not a URL code point and not U+0025 (%), validation\n                     * error.\n                     * 2.2. If c is U+0025 (%) and remaining does not start with two\n                     * ASCII hex digits, validation error.\n                     * 2.3. UTF-8 percent encode c using the path percent-encode set,\n                     * and append the result to buffer.\n                     */\n                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {\n                        validationError(\"Character is not a URL code point or a percent encoded character.\");\n                    }\n                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {\n                        validationError(\"Percent encoded character must be followed by two hex digits.\");\n                    }\n                    buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);\n                }\n                break;\n            case interfaces_1.ParserState.CannotBeABaseURLPath:\n                /**\n                 * 1. If c is U+003F (?), then set url’s query to the empty string and\n                 * state to query state.\n                 * 2. Otherwise, if c is U+0023 (#), then set url’s fragment to the\n                 * empty string and state to fragment state.\n                 * 3. Otherwise:\n                 * 3.1. If c is not the EOF code point, not a URL code point, and not\n                 * U+0025 (%), validation error.\n                 * 3.2. If c is U+0025 (%) and remaining does not start with two ASCII\n                 * hex digits, validation error.\n                 * 3.3. If c is not the EOF code point, UTF-8 percent encode c using\n                 * the C0 control percent-encode set, and append the result to url’s\n                 * path[0].\n                 */\n                if (walker.c() === '?') {\n                    url.query = \"\";\n                    state = interfaces_1.ParserState.Query;\n                }\n                else if (walker.c() === '#') {\n                    url.fragment = \"\";\n                    state = interfaces_1.ParserState.Fragment;\n                }\n                else {\n                    if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== '%') {\n                        validationError(\"Character is not a URL code point or a percent encoded character.\");\n                    }\n                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {\n                        validationError(\"Percent encoded character must be followed by two hex digits.\");\n                    }\n                    if (walker.c() !== EOF) {\n                        url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);\n                    }\n                }\n                break;\n            case interfaces_1.ParserState.Query:\n                /**\n                 * 1. If encoding is not UTF-8 and one of the following is true\n                 * - url is not special\n                 * - url’s scheme is \"ws\" or \"wss\"\n                 * then set encoding to UTF-8.\n                 */\n                if (encoding !== \"UTF-8\" && (!isSpecial(url) ||\n                    url.scheme === \"ws\" || url.scheme === \"wss\")) {\n                    encoding = \"UTF-8\";\n                }\n                if (stateOverride === undefined && walker.c() === '#') {\n                    /**\n                     * 2. If state override is not given and c is U+0023 (#), then set\n                     * url’s fragment to the empty string and state to fragment state.\n                     */\n                    url.fragment = \"\";\n                    state = interfaces_1.ParserState.Fragment;\n                }\n                else if (walker.c() !== EOF) {\n                    /**\n                     * 3. Otherwise, if c is not the EOF code point:\n                     * 3.1. If c is not a URL code point and not U+0025 (%), validation\n                     * error.\n                     */\n                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {\n                        validationError(\"Character is not a URL code point or a percent encoded character.\");\n                    }\n                    /**\n                     * 3.2. If c is U+0025 (%) and remaining does not start with two\n                     * ASCII hex digits, validation error.\n                     */\n                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {\n                        validationError(\"Percent encoded character must be followed by two hex digits.\");\n                    }\n                    /**\n                     * 3.3. Let bytes be the result of encoding c using encoding.\n                     */\n                    if (encoding.toUpperCase() !== \"UTF-8\") {\n                        throw new Error(\"Only UTF-8 encoding is supported.\");\n                    }\n                    var bytes = util_1.utf8Encode(walker.c());\n                    /**\n                     * 3.4. If bytes starts with `&#` and ends with 0x3B (;), then:\n                     */\n                    if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 &&\n                        bytes[bytes.length - 1] === 59) {\n                        /**\n                         * 3.4.1. Replace `&#` at the start of bytes with `%26%23`.\n                         * 3.4.2. Replace 0x3B (;) at the end of bytes with `%3B`.\n                         * 3.4.4. Append bytes, isomorphic decoded, to url’s query.\n                         * _Note:_ can happen when encoding code points using a\n                         * non-UTF-8 encoding.\n                         */\n                        bytes = bytes.subarray(2, bytes.length - 1);\n                        url.query += \"%26%23\" + infra_1.byteSequence.isomorphicDecode(bytes) + \"%3B\";\n                    }\n                    else {\n                        try {\n                            /**\n                             * 3.5. Otherwise, for each byte in bytes:\n                             * 3.5.1. If one of the following is true\n                             * - byte is less than 0x21 (!)\n                             * - byte is greater than 0x7E (~)\n                             * - byte is 0x22 (\"), 0x23 (#), 0x3C (<), or 0x3E (>)\n                             * - byte is 0x27 (') and url is special\n                             * then append byte, percent encoded, to url’s query.\n                             * 3.5.2. Otherwise, append a code point whose value is byte to\n                             * url’s query.\n                             */\n                            for (var bytes_1 = (e_3 = void 0, __values(bytes)), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {\n                                var byte = bytes_1_1.value;\n                                if (byte < 0x21 || byte > 0x7E || byte === 0x22 ||\n                                    byte === 0x23 || byte === 0x3C || byte === 0x3E ||\n                                    (byte === 0x27 && isSpecial(url))) {\n                                    url.query += percentEncode(byte);\n                                }\n                                else {\n                                    url.query += String.fromCharCode(byte);\n                                }\n                            }\n                        }\n                        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                        finally {\n                            try {\n                                if (bytes_1_1 && !bytes_1_1.done && (_b = bytes_1.return)) _b.call(bytes_1);\n                            }\n                            finally { if (e_3) throw e_3.error; }\n                        }\n                    }\n                }\n                break;\n            case interfaces_1.ParserState.Fragment:\n                /**\n                 * Switching on c:\n                 * - The EOF code point\n                 * Do nothing.\n                 * - U+0000 NULL\n                 * Validation error.\n                 * - Otherwise\n                 * 1. If c is not a URL code point and not U+0025 (%), validation\n                 * error.\n                 * 2. If c is U+0025 (%) and remaining does not start with two ASCII\n                 * hex digits, validation error.\n                 * 3. UTF-8 percent encode c using the fragment percent-encode set and\n                 * append the result to url’s fragment.\n                 */\n                if (walker.c() === EOF) {\n                    //\n                }\n                else if (walker.c() === \"\\u0000\") {\n                    validationError(\"NULL character in input string.\");\n                }\n                else {\n                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {\n                        validationError(\"Unexpected character in fragment string.\");\n                    }\n                    if (walker.c() === '%' && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {\n                        validationError(\"Unexpected character in fragment string.\");\n                    }\n                    url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);\n                }\n                break;\n        }\n        if (walker.eof)\n            break;\n        else\n            walker.pointer++;\n    }\n    /**\n     * 12. Return url.\n     */\n    return url;\n}\nexports.basicURLParser = basicURLParser;\n/**\n * Sets a URL's username.\n *\n * @param url - a URL\n * @param username - username string\n */\nfunction setTheUsername(url, username) {\n    var e_4, _a;\n    /**\n     * 1. Set url’s username to the empty string.\n     * 2. For each code point in username, UTF-8 percent encode it using the\n     * userinfo percent-encode set, and append the result to url’s username.\n     */\n    var result = \"\";\n    try {\n        for (var username_1 = __values(username), username_1_1 = username_1.next(); !username_1_1.done; username_1_1 = username_1.next()) {\n            var codePoint = username_1_1.value;\n            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (username_1_1 && !username_1_1.done && (_a = username_1.return)) _a.call(username_1);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    url.username = result;\n}\nexports.setTheUsername = setTheUsername;\n/**\n * Sets a URL's password.\n *\n * @param url - a URL\n * @param username - password string\n */\nfunction setThePassword(url, password) {\n    var e_5, _a;\n    /**\n     * 1. Set url’s password to the empty string.\n     * 2. For each code point in password, UTF-8 percent encode it using the\n     * userinfo percent-encode set, and append the result to url’s password.\n     */\n    var result = \"\";\n    try {\n        for (var password_1 = __values(password), password_1_1 = password_1.next(); !password_1_1.done; password_1_1 = password_1.next()) {\n            var codePoint = password_1_1.value;\n            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);\n        }\n    }\n    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n    finally {\n        try {\n            if (password_1_1 && !password_1_1.done && (_a = password_1.return)) _a.call(password_1);\n        }\n        finally { if (e_5) throw e_5.error; }\n    }\n    url.password = result;\n}\nexports.setThePassword = setThePassword;\n/**\n * Determines if the string represents a single dot path.\n *\n * @param str - a string\n */\nfunction isSingleDotPathSegment(str) {\n    return str === '.' || str.toLowerCase() === \"%2e\";\n}\nexports.isSingleDotPathSegment = isSingleDotPathSegment;\n/**\n * Determines if the string represents a double dot path.\n *\n * @param str - a string\n */\nfunction isDoubleDotPathSegment(str) {\n    var lowerStr = str.toLowerCase();\n    return lowerStr === \"..\" || lowerStr === \".%2e\" ||\n        lowerStr === \"%2e.\" || lowerStr === \"%2e%2e\";\n}\nexports.isDoubleDotPathSegment = isDoubleDotPathSegment;\n/**\n * Shorten's URL's path.\n *\n * @param url - an URL\n */\nfunction shorten(url) {\n    /**\n     * 1. Let path be url’s path.\n     * 2. If path is empty, then return.\n     * 3. If url’s scheme is \"file\", path’s size is 1, and path[0] is a\n     * normalized Windows drive letter, then return.\n     * 4. Remove path’s last item.\n     */\n    var path = url.path;\n    if (path.length === 0)\n        return;\n    if (url.scheme === \"file\" && path.length === 1 &&\n        isNormalizedWindowsDriveLetter(path[0]))\n        return;\n    url.path.splice(url.path.length - 1, 1);\n}\nexports.shorten = shorten;\n/**\n * Determines if a string is a normalized Windows drive letter.\n *\n * @param str - a string\n */\nfunction isNormalizedWindowsDriveLetter(str) {\n    /**\n     * A normalized Windows drive letter is a Windows drive letter of which the\n     * second code point is U+003A (:).\n     */\n    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) &&\n        str[1] === ':';\n}\nexports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;\n/**\n * Determines if a string is a Windows drive letter.\n *\n * @param str - a string\n */\nfunction isWindowsDriveLetter(str) {\n    /**\n     * A Windows drive letter is two code points, of which the first is an ASCII\n     * alpha and the second is either U+003A (:) or U+007C (|).\n     */\n    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) &&\n        (str[1] === ':' || str[1] === '|');\n}\nexports.isWindowsDriveLetter = isWindowsDriveLetter;\n/**\n * Determines if a string starts with a Windows drive letter.\n *\n * @param str - a string\n */\nfunction startsWithAWindowsDriveLetter(str) {\n    /**\n     * A string starts with a Windows drive letter if all of the following are\n     * true:\n     * - its length is greater than or equal to 2\n     * - its first two code points are a Windows drive letter\n     * - its length is 2 or its third code point is U+002F (/), U+005C (\\),\n     * U+003F (?), or U+0023 (#).\n     */\n    return str.length >= 2 && isWindowsDriveLetter(str) &&\n        (str.length === 2 || (str[2] === '/' || str[2] === '\\\\' ||\n            str[2] === '?' || str[2] === '#'));\n}\nexports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;\n/**\n * Parses a host string.\n *\n * @param input - input string\n * @param isNotSpecial - `true` if the source URL is not special; otherwise\n * `false`.\n */\nfunction hostParser(input, isNotSpecial) {\n    if (isNotSpecial === void 0) { isNotSpecial = false; }\n    /**\n     * 1. If isNotSpecial is not given, then set isNotSpecial to false.\n     * 2. If input starts with U+005B ([), then:\n     * 2.1. If input does not end with U+005D (]), validation error, return\n     * failure.\n     * 2.2. Return the result of IPv6 parsing input with its leading U+005B ([)\n     * and trailing U+005D (]) removed.\n     */\n    if (input.startsWith('[')) {\n        if (!input.endsWith(']')) {\n            validationError(\"Expected ']' after '['.\");\n            return null;\n        }\n        return iPv6Parser(input.substring(1, input.length - 1));\n    }\n    /**\n     * 3. If isNotSpecial is true, then return the result of opaque-host parsing\n     * input.\n     */\n    if (isNotSpecial) {\n        return opaqueHostParser(input);\n    }\n    /**\n     * 4. Let domain be the result of running UTF-8 decode without BOM on the\n     * string percent decoding of input.\n     * _Note:_ Alternatively UTF-8 decode without BOM or fail can be used,\n     * coupled with an early return for failure, as domain to ASCII fails\n     * on U+FFFD REPLACEMENT CHARACTER.\n     */\n    var domain = util_1.utf8Decode(stringPercentDecode(input));\n    /**\n     * 5. Let asciiDomain be the result of running domain to ASCII on domain.\n     * 6. If asciiDomain is failure, validation error, return failure.\n     * 7. If asciiDomain contains a forbidden host code point, validation error,\n     * return failure.\n     */\n    var asciiDomain = domainToASCII(domain);\n    if (asciiDomain === null) {\n        validationError(\"Invalid domain.\");\n        return null;\n    }\n    if (_forbiddenHostCodePoint.test(asciiDomain)) {\n        validationError(\"Invalid domain.\");\n        return null;\n    }\n    /**\n     * 8. Let ipv4Host be the result of IPv4 parsing asciiDomain.\n     * 9. If ipv4Host is an IPv4 address or failure, return ipv4Host.\n     * 10. Return asciiDomain.\n     */\n    var ipv4Host = iPv4Parser(asciiDomain);\n    if (ipv4Host === null || util_1.isNumber(ipv4Host))\n        return ipv4Host;\n    return asciiDomain;\n}\nexports.hostParser = hostParser;\n/**\n * Parses a string containing an IP v4 address.\n *\n * @param input - input string\n * @param isNotSpecial - `true` if the source URL is not special; otherwise\n * `false`.\n */\nfunction iPv4NumberParser(input, validationErrorFlag) {\n    if (validationErrorFlag === void 0) { validationErrorFlag = { value: false }; }\n    /**\n     * 1. Let R be 10.\n     */\n    var R = 10;\n    if (input.startsWith(\"0x\") || input.startsWith(\"0X\")) {\n        /**\n         * 2. If input contains at least two code points and the first two code\n         * points are either \"0x\" or \"0X\", then:\n         * 2.1. Set validationErrorFlag.\n         * 2.2. Remove the first two code points from input.\n         * 2.3. Set R to 16.\n         */\n        validationErrorFlag.value = true;\n        input = input.substr(2);\n        R = 16;\n    }\n    else if (input.length >= 2 && input[0] === '0') {\n        /**\n         * 3. Otherwise, if input contains at least two code points and the first\n         * code point is U+0030 (0), then:\n         * 3.1. Set validationErrorFlag.\n         * 3.2. Remove the first code point from input.\n         * 3.3. Set R to 8.\n         */\n        validationErrorFlag.value = true;\n        input = input.substr(1);\n        R = 8;\n    }\n    /**\n     * 4. If input is the empty string, then return zero.\n     * 5. If input contains a code point that is not a radix-R digit, then\n     * return failure.\n     */\n    if (input === \"\")\n        return 0;\n    var radixRDigits = (R === 10 ? /^[0-9]+$/ : (R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/));\n    if (!radixRDigits.test(input))\n        return null;\n    /**\n     * 6. Return the mathematical integer value that is represented by input in\n     * radix-R notation, using ASCII hex digits for digits with values\n     * 0 through 15.\n     */\n    return parseInt(input, R);\n}\nexports.iPv4NumberParser = iPv4NumberParser;\n/**\n * Parses a string containing an IP v4 address.\n *\n * @param input - input string\n */\nfunction iPv4Parser(input) {\n    var e_6, _a, e_7, _b;\n    /**\n     * 1. Let validationErrorFlag be unset.\n     * 2. Let parts be input split on U+002E (.).\n     */\n    var validationErrorFlag = { value: false };\n    var parts = input.split('.');\n    /**\n     * 3. If the last item in parts is the empty string, then:\n     * 3.1. Set validationErrorFlag.\n     * 3.2. If parts has more than one item, then remove the last item from\n     * parts.\n     */\n    if (parts[parts.length - 1] === \"\") {\n        validationErrorFlag.value = true;\n        if (parts.length > 1)\n            parts.pop();\n    }\n    /**\n     * 4. If parts has more than four items, return input.\n     */\n    if (parts.length > 4)\n        return input;\n    /**\n     * 5. Let numbers be the empty list.\n     * 6. For each part in parts:\n     * 6.1. If part is the empty string, return input.\n     * 6.2. Let n be the result of parsing part using validationErrorFlag.\n     * 6.3. If n is failure, return input.\n     * 6.4. Append n to numbers.\n     */\n    var numbers = [];\n    try {\n        for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {\n            var part = parts_1_1.value;\n            if (part === \"\")\n                return input;\n            var n = iPv4NumberParser(part, validationErrorFlag);\n            if (n === null)\n                return input;\n            numbers.push(n);\n        }\n    }\n    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n    finally {\n        try {\n            if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);\n        }\n        finally { if (e_6) throw e_6.error; }\n    }\n    /**\n     * 7. If validationErrorFlag is set, validation error.\n     * 8. If any item in numbers is greater than 255, validation error.\n     * 9. If any but the last item in numbers is greater than 255, return\n     * failure.\n     * 10. If the last item in numbers is greater than or equal to\n     * 256**(5 − the number of items in numbers), validation error, return failure.\n     */\n    if (validationErrorFlag.value)\n        validationError(\"Invalid IP v4 address.\");\n    for (var i = 0; i < numbers.length; i++) {\n        var item = numbers[i];\n        if (item > 255) {\n            validationError(\"Invalid IP v4 address.\");\n            if (i < numbers.length - 1)\n                return null;\n        }\n    }\n    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\n        validationError(\"Invalid IP v4 address.\");\n        return null;\n    }\n    /**\n     * 11. Let ipv4 be the last item in numbers.\n     * 12. Remove the last item from numbers.\n     */\n    var ipv4 = numbers[numbers.length - 1];\n    numbers.pop();\n    /**\n     * 13. Let counter be zero.\n     * 14. For each n in numbers:\n     * 14.2. Increment ipv4 by n × 256**(3 − counter).\n     * 14.2. Increment counter by 1.\n     */\n    var counter = 0;\n    try {\n        for (var numbers_1 = __values(numbers), numbers_1_1 = numbers_1.next(); !numbers_1_1.done; numbers_1_1 = numbers_1.next()) {\n            var n = numbers_1_1.value;\n            ipv4 += n * Math.pow(256, 3 - counter);\n            counter++;\n        }\n    }\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\n    finally {\n        try {\n            if (numbers_1_1 && !numbers_1_1.done && (_b = numbers_1.return)) _b.call(numbers_1);\n        }\n        finally { if (e_7) throw e_7.error; }\n    }\n    /**\n     * 15. Return ipv4.\n     */\n    return ipv4;\n}\nexports.iPv4Parser = iPv4Parser;\n/**\n * Parses a string containing an IP v6 address.\n *\n * @param input - input string\n */\nfunction iPv6Parser(input) {\n    var _a;\n    /**\n     * 1. Let address be a new IPv6 address whose IPv6 pieces are all 0.\n     * 2. Let pieceIndex be 0.\n     * 3. Let compress be null.\n     * 4. Let pointer be a pointer into input, initially 0 (pointing to the\n     * first code point).\n     */\n    var EOF = \"\";\n    var address = [0, 0, 0, 0, 0, 0, 0, 0];\n    var pieceIndex = 0;\n    var compress = null;\n    var walker = new util_1.StringWalker(input);\n    /**\n     * 5. If c is U+003A (:), then:\n     * 5.1. If remaining does not start with U+003A (:), validation error,\n     * return failure.\n     * 5.2. Increase pointer by 2.\n     * 5.3. Increase pieceIndex by 1 and then set compress to pieceIndex.\n     */\n    if (walker.c() === ':') {\n        if (!walker.remaining().startsWith(':')) {\n            validationError(\"Invalid IP v6 address.\");\n            return null;\n        }\n        walker.pointer += 2;\n        pieceIndex += 1;\n        compress = pieceIndex;\n    }\n    /**\n     * 6. While c is not the EOF code point:\n     */\n    while (walker.c() !== EOF) {\n        /**\n         * 6.1. If pieceIndex is 8, validation error, return failure.\n         */\n        if (pieceIndex === 8) {\n            validationError(\"Invalid IP v6 address.\");\n            return null;\n        }\n        /**\n         * 6.2. If c is U+003A (:), then:\n         * 6.2.1. If compress is non-null, validation error, return failure.\n         * 6.2.2. Increase pointer and pieceIndex by 1, set compress to pieceIndex,\n         * and then continue.\n         */\n        if (walker.c() === ':') {\n            if (compress !== null) {\n                validationError(\"Invalid IP v6 address.\");\n                return null;\n            }\n            walker.pointer++;\n            pieceIndex++;\n            compress = pieceIndex;\n            continue;\n        }\n        /**\n         * 6.3. Let value and length be 0.\n         * 6.4. While length is less than 4 and c is an ASCII hex digit, set value\n         * to value × 0x10 + c interpreted as hexadecimal number, and increase\n         * pointer and length by 1.\n         */\n        var value = 0;\n        var length = 0;\n        while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {\n            value = value * 0x10 + parseInt(walker.c(), 16);\n            walker.pointer++;\n            length++;\n        }\n        /**\n         * 6.5. If c is U+002E (.), then:\n         */\n        if (walker.c() === '.') {\n            /**\n             * 6.5.1. If length is 0, validation error, return failure.\n             * 6.5.2. Decrease pointer by length.\n             * 6.5.3. If pieceIndex is greater than 6, validation error, return\n             * failure.\n             * 6.5.4. Let numbersSeen be 0.\n             */\n            if (length === 0) {\n                validationError(\"Invalid IP v6 address.\");\n                return null;\n            }\n            walker.pointer -= length;\n            if (pieceIndex > 6) {\n                validationError(\"Invalid IP v6 address.\");\n                return null;\n            }\n            var numbersSeen = 0;\n            /**\n             * 6.5.5. While c is not the EOF code point:\n             */\n            while (walker.c() !== EOF) {\n                /**\n                 * 6.5.5.1. Let ipv4Piece be null.\n                 */\n                var ipv4Piece = null;\n                /**\n                 * 6.5.5.2. If numbersSeen is greater than 0, then:\n                 * 6.5.5.2.1. If c is a U+002E (.) and numbersSeen is less than 4, then\n                 * increase pointer by 1.\n                 * 6.5.5.2.1. Otherwise, validation error, return failure.\n                 */\n                if (numbersSeen > 0) {\n                    if (walker.c() === '.' && numbersSeen < 4) {\n                        walker.pointer++;\n                    }\n                    else {\n                        validationError(\"Invalid IP v6 address.\");\n                        return null;\n                    }\n                }\n                /**\n                 * 6.5.5.3. If c is not an ASCII digit, validation error, return\n                 * failure.\n                 */\n                if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {\n                    validationError(\"Invalid IP v6 address.\");\n                    return null;\n                }\n                /**\n                 * 6.5.5.4. While c is an ASCII digit:\n                 */\n                while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {\n                    /**\n                     * 6.5.5.4.1. Let number be c interpreted as decimal number.\n                     */\n                    var number = parseInt(walker.c(), 10);\n                    /**\n                     * 6.5.5.4.2. If ipv4Piece is null, then set ipv4Piece to number.\n                     * Otherwise, if ipv4Piece is 0, validation error, return failure.\n                     * Otherwise, set ipv4Piece to ipv4Piece × 10 + number.\n                     */\n                    if (ipv4Piece === null) {\n                        ipv4Piece = number;\n                    }\n                    else if (ipv4Piece === 0) {\n                        validationError(\"Invalid IP v6 address.\");\n                        return null;\n                    }\n                    else {\n                        ipv4Piece = ipv4Piece * 10 + number;\n                    }\n                    /**\n                     * 6.5.5.4.3. If ipv4Piece is greater than 255, validation error, return failure.\n                     * 6.5.5.4.4. Increase pointer by 1.\n                     */\n                    if (ipv4Piece > 255) {\n                        validationError(\"Invalid IP v6 address.\");\n                        return null;\n                    }\n                    walker.pointer++;\n                }\n                /**\n                 * 6.5.5.5. Set address[pieceIndex] to address[pieceIndex] × 0x100 + ipv4Piece.\n                 * 6.5.5.6. Increase numbersSeen by 1.\n                 * 6.5.5.7. If numbersSeen is 2 or 4, then increase pieceIndex by 1.\n                 */\n                if (ipv4Piece === null) {\n                    validationError(\"Invalid IP v6 address.\");\n                    return null;\n                }\n                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\n                numbersSeen++;\n                if (numbersSeen === 2 || numbersSeen === 4)\n                    pieceIndex++;\n            }\n            /**\n             * 6.5.6. If numbersSeen is not 4, validation error, return failure.\n             */\n            if (numbersSeen !== 4) {\n                validationError(\"Invalid IP v6 address.\");\n                return null;\n            }\n            /**\n             * 6.5.7. Break.\n             */\n            break;\n        }\n        else if (walker.c() === ':') {\n            /**\n             * 6.6. Otherwise, if c is U+003A (:):\n             * 6.6.1. Increase pointer by 1.\n             * 6.6.2. If c is the EOF code point, validation error, return failure.\n             */\n            walker.pointer++;\n            if (walker.c() === EOF) {\n                validationError(\"Invalid IP v6 address.\");\n                return null;\n            }\n        }\n        else if (walker.c() !== EOF) {\n            /**\n             * 6.7. Otherwise, if c is not the EOF code point, validation error,\n             * return failure.\n             */\n            validationError(\"Invalid IP v6 address.\");\n            return null;\n        }\n        /**\n         * 6.8. Set address[pieceIndex] to value.\n         * 6.9. Increase pieceIndex by 1.\n         */\n        address[pieceIndex] = value;\n        pieceIndex++;\n    }\n    /**\n     * 7. If compress is non-null, then:\n     * 7.1. Let swaps be pieceIndex − compress.\n     * 7.2. Set pieceIndex to 7.\n     * 7.3. While pieceIndex is not 0 and swaps is greater than 0, swap\n     * address[pieceIndex] with address[compress + swaps − 1], and then decrease\n     * both pieceIndex and swaps by 1.\n     */\n    if (compress !== null) {\n        var swaps = pieceIndex - compress;\n        pieceIndex = 7;\n        while (pieceIndex !== 0 && swaps > 0) {\n            _a = __read([address[compress + swaps - 1], address[pieceIndex]], 2), address[pieceIndex] = _a[0], address[compress + swaps - 1] = _a[1];\n            pieceIndex--;\n            swaps--;\n        }\n    }\n    else if (compress === null && pieceIndex !== 8) {\n        /**\n         * 8. Otherwise, if compress is null and pieceIndex is not 8,\n         * validation error, return failure.\n         */\n        validationError(\"Invalid IP v6 address.\");\n        return null;\n    }\n    /**\n     * 9. Return address.\n     */\n    return address;\n}\nexports.iPv6Parser = iPv6Parser;\n/**\n * Parses an opaque host string.\n *\n * @param input - a string\n */\nfunction opaqueHostParser(input) {\n    var e_8, _a;\n    /**\n     * 1. If input contains a forbidden host code point excluding U+0025 (%),\n     * validation error, return failure.\n     * 2. Let output be the empty string.\n     * 3. For each code point in input, UTF-8 percent encode it using the C0\n     * control percent-encode set, and append the result to output.\n     * 4. Return output.\n     */\n    var forbiddenChars = /[\\x00\\t\\f\\r #/:?@\\[\\\\\\]]/;\n    if (forbiddenChars.test(input)) {\n        validationError(\"Invalid host string.\");\n        return null;\n    }\n    var output = \"\";\n    try {\n        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {\n            var codePoint = input_1_1.value;\n            output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);\n        }\n    }\n    catch (e_8_1) { e_8 = { error: e_8_1 }; }\n    finally {\n        try {\n            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);\n        }\n        finally { if (e_8) throw e_8.error; }\n    }\n    return output;\n}\nexports.opaqueHostParser = opaqueHostParser;\n/**\n * Resolves a Blob URL from the user agent's Blob URL store.\n * function is not implemented.\n * See: https://w3c.github.io/FileAPI/#blob-url-resolve\n *\n * @param url - an url\n */\nfunction resolveABlobURL(url) {\n    return null;\n}\nexports.resolveABlobURL = resolveABlobURL;\n/**\n * Percent encodes a byte.\n *\n * @param value - a byte\n */\nfunction percentEncode(value) {\n    /**\n     * To percent encode a byte into a percent-encoded byte, return a string\n     * consisting of U+0025 (%), followed by two ASCII upper hex digits\n     * representing byte.\n     */\n    return '%' + ('00' + value.toString(16).toUpperCase()).slice(-2);\n}\nexports.percentEncode = percentEncode;\n/**\n * Percent decodes a byte sequence input.\n *\n * @param input - a byte sequence\n */\nfunction percentDecode(input) {\n    var isHexDigit = function (byte) {\n        return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) ||\n            (byte >= 0x61 && byte <= 0x66);\n    };\n    /**\n     * 1. Let output be an empty byte sequence.\n     * 2. For each byte byte in input:\n     */\n    var output = new Uint8Array(input.length);\n    var n = 0;\n    for (var i = 0; i < input.length; i++) {\n        var byte = input[i];\n        /**\n         * 2.1. If byte is not 0x25 (%), then append byte to output.\n         * 2.2. Otherwise, if byte is 0x25 (%) and the next two bytes after byte\n         * in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A)\n         * to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte\n         * to output.\n         * 2.3. Otherwise:\n         * 2.3.1. Let bytePoint be the two bytes after byte in input, decoded,\n         * and then interpreted as hexadecimal number.\n         * 2.3.2. Append a byte whose value is bytePoint to output.\n         * 2.3.3. Skip the next two bytes in input.\n         */\n        if (byte !== 0x25) {\n            output[n] = byte;\n            n++;\n        }\n        else if (byte === 0x25 && i >= input.length - 2) {\n            output[n] = byte;\n            n++;\n        }\n        else if (byte === 0x25 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {\n            output[n] = byte;\n            n++;\n        }\n        else {\n            var bytePoint = parseInt(util_1.utf8Decode(Uint8Array.of(input[i + 1], input[i + 2])), 16);\n            output[n] = bytePoint;\n            n++;\n            i += 2;\n        }\n    }\n    return output.subarray(0, n);\n}\nexports.percentDecode = percentDecode;\n/**\n * String percent decodes a string.\n *\n * @param input - a string\n */\nfunction stringPercentDecode(input) {\n    /**\n     * 1. Let bytes be the UTF-8 encoding of input.\n     * 2. Return the percent decoding of bytes.\n     */\n    return percentDecode(util_1.utf8Encode(input));\n}\nexports.stringPercentDecode = stringPercentDecode;\n/**\n * UTF-8 percent encodes a code point, using a percent encode set.\n *\n * @param codePoint - a code point\n * @param percentEncodeSet - a percent encode set\n */\nfunction utf8PercentEncode(codePoint, percentEncodeSet) {\n    var e_9, _a;\n    /**\n     * 1. If codePoint is not in percentEncodeSet, then return codePoint.\n     * 2. Let bytes be the result of running UTF-8 encode on codePoint.\n     * 3. Percent encode each byte in bytes, and then return the results\n     * concatenated, in the same order.\n     */\n    if (!percentEncodeSet.test(codePoint))\n        return codePoint;\n    var bytes = util_1.utf8Encode(codePoint);\n    var result = \"\";\n    try {\n        for (var bytes_2 = __values(bytes), bytes_2_1 = bytes_2.next(); !bytes_2_1.done; bytes_2_1 = bytes_2.next()) {\n            var byte = bytes_2_1.value;\n            result += percentEncode(byte);\n        }\n    }\n    catch (e_9_1) { e_9 = { error: e_9_1 }; }\n    finally {\n        try {\n            if (bytes_2_1 && !bytes_2_1.done && (_a = bytes_2.return)) _a.call(bytes_2);\n        }\n        finally { if (e_9) throw e_9.error; }\n    }\n    return result;\n}\nexports.utf8PercentEncode = utf8PercentEncode;\n/**\n * Determines if two hosts are considered equal.\n *\n * @param hostA - a host\n * @param hostB - a host\n */\nfunction hostEquals(hostA, hostB) {\n    return hostA === hostB;\n}\nexports.hostEquals = hostEquals;\n/**\n * Determines if two URLs are considered equal.\n *\n * @param urlA - a URL\n * @param urlB - a URL\n * @param excludeFragmentsFlag - whether to ignore fragments while comparing\n */\nfunction urlEquals(urlA, urlB, excludeFragmentsFlag) {\n    if (excludeFragmentsFlag === void 0) { excludeFragmentsFlag = false; }\n    /**\n     * 1. Let serializedA be the result of serializing A, with the exclude\n     * fragment flag set if the exclude fragments flag is set.\n     * 2. Let serializedB be the result of serializing B, with the exclude\n     * fragment flag set if the exclude fragments flag is set.\n     * 3. Return true if serializedA is serializedB, and false otherwise.\n     */\n    return urlSerializer(urlA, excludeFragmentsFlag) ===\n        urlSerializer(urlB, excludeFragmentsFlag);\n}\nexports.urlEquals = urlEquals;\n/**\n * Parses an `application/x-www-form-urlencoded` string.\n *\n * @param input - a string\n */\nfunction urlEncodedStringParser(input) {\n    /**\n     * The application/x-www-form-urlencoded string parser takes a string input,\n     * UTF-8 encodes it, and then returns the result of\n     * application/x-www-form-urlencoded parsing it.\n     */\n    return urlEncodedParser(util_1.utf8Encode(input));\n}\nexports.urlEncodedStringParser = urlEncodedStringParser;\n/**\n * Parses `application/x-www-form-urlencoded` bytes.\n *\n * @param input - a byte sequence\n */\nfunction urlEncodedParser(input) {\n    var e_10, _a, e_11, _b;\n    /**\n     * 1. Let sequences be the result of splitting input on 0x26 (&).\n     */\n    var sequences = [];\n    var currentSequence = [];\n    try {\n        for (var input_2 = __values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {\n            var byte = input_2_1.value;\n            if (byte === 0x26) {\n                sequences.push(Uint8Array.from(currentSequence));\n                currentSequence = [];\n            }\n            else {\n                currentSequence.push(byte);\n            }\n        }\n    }\n    catch (e_10_1) { e_10 = { error: e_10_1 }; }\n    finally {\n        try {\n            if (input_2_1 && !input_2_1.done && (_a = input_2.return)) _a.call(input_2);\n        }\n        finally { if (e_10) throw e_10.error; }\n    }\n    if (currentSequence.length !== 0) {\n        sequences.push(Uint8Array.from(currentSequence));\n    }\n    /**\n     * 2. Let output be an initially empty list of name-value tuples where both name and value hold a string.\n     */\n    var output = [];\n    try {\n        /**\n         * 3. For each byte sequence bytes in sequences:\n         */\n        for (var sequences_1 = __values(sequences), sequences_1_1 = sequences_1.next(); !sequences_1_1.done; sequences_1_1 = sequences_1.next()) {\n            var bytes = sequences_1_1.value;\n            /**\n             * 3.1. If bytes is the empty byte sequence, then continue.\n             */\n            if (bytes.length === 0)\n                continue;\n            /**\n             * 3.2. If bytes contains a 0x3D (=), then let name be the bytes from the\n             * start of bytes up to but excluding its first 0x3D (=), and let value be\n             * the bytes, if any, after the first 0x3D (=) up to the end of bytes.\n             * If 0x3D (=) is the first byte, then name will be the empty byte\n             * sequence. If it is the last, then value will be the empty byte sequence.\n             * 3.3. Otherwise, let name have the value of bytes and let value be the\n             * empty byte sequence.\n             */\n            var index = bytes.indexOf(0x3D);\n            var name = (index !== -1 ? bytes.slice(0, index) : bytes);\n            var value = (index !== -1 ? bytes.slice(index + 1) : new Uint8Array());\n            /**\n             * 3.4. Replace any 0x2B (+) in name and value with 0x20 (SP).\n             */\n            for (var i = 0; i < name.length; i++)\n                if (name[i] === 0x2B)\n                    name[i] = 0x20;\n            for (var i = 0; i < value.length; i++)\n                if (value[i] === 0x2B)\n                    value[i] = 0x20;\n            /**\n             * 3.5. Let nameString and valueString be the result of running UTF-8\n             * decode without BOM on the percent decoding of name and value,\n             * respectively.\n             */\n            var nameString = util_1.utf8Decode(name);\n            var valueString = util_1.utf8Decode(value);\n            /**\n             * 3.6. Append (nameString, valueString) to output.\n             */\n            output.push([nameString, valueString]);\n        }\n    }\n    catch (e_11_1) { e_11 = { error: e_11_1 }; }\n    finally {\n        try {\n            if (sequences_1_1 && !sequences_1_1.done && (_b = sequences_1.return)) _b.call(sequences_1);\n        }\n        finally { if (e_11) throw e_11.error; }\n    }\n    /**\n     * 4. Return output.\n     */\n    return output;\n}\nexports.urlEncodedParser = urlEncodedParser;\n/**\n * Serializes `application/x-www-form-urlencoded` bytes.\n *\n * @param input - a byte sequence\n */\nfunction urlEncodedByteSerializer(input) {\n    var e_12, _a;\n    /**\n     * 1. Let output be the empty string.\n     * 2. For each byte in input, depending on byte:\n     * 0x20 (SP)\n     * Append U+002B (+) to output.\n     *\n     * 0x2A (*)\n     * 0x2D (-)\n     * 0x2E (.)\n     * 0x30 (0) to 0x39 (9)\n     * 0x41 (A) to 0x5A (Z)\n     * 0x5F (_)\n     * 0x61 (a) to 0x7A (z)\n     * Append a code point whose value is byte to output.\n     *\n     * Otherwise\n     * Append byte, percent encoded, to output.\n     * 3. Return output.\n     */\n    var output = \"\";\n    try {\n        for (var input_3 = __values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()) {\n            var byte = input_3_1.value;\n            if (byte === 0x20) {\n                output += '+';\n            }\n            else if (byte === 0x2A || byte === 0x2D || byte === 0x2E ||\n                (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x5A) ||\n                byte === 0x5F || (byte >= 0x61 && byte <= 0x7A)) {\n                output += String.fromCodePoint(byte);\n            }\n            else {\n                output += percentEncode(byte);\n            }\n        }\n    }\n    catch (e_12_1) { e_12 = { error: e_12_1 }; }\n    finally {\n        try {\n            if (input_3_1 && !input_3_1.done && (_a = input_3.return)) _a.call(input_3);\n        }\n        finally { if (e_12) throw e_12.error; }\n    }\n    return output;\n}\nexports.urlEncodedByteSerializer = urlEncodedByteSerializer;\n/**\n * Serializes `application/x-www-form-urlencoded` tuples.\n *\n * @param input - input tuple of name/value pairs\n * @param encodingOverride: encoding override\n */\nfunction urlEncodedSerializer(tuples, encodingOverride) {\n    var e_13, _a;\n    /**\n     * 1. Let encoding be UTF-8.\n     * 2. If encoding override is given, set encoding to the result of getting\n     * an output encoding from encoding override.\n     */\n    var encoding = (encodingOverride === undefined ||\n        encodingOverride === \"replacement\" || encodingOverride === \"UTF-16BE\" ||\n        encodingOverride === \"UTF-16LE\" ? \"UTF-8\" : encodingOverride);\n    if (encoding.toUpperCase() !== \"UTF-8\") {\n        throw new Error(\"Only UTF-8 encoding is supported.\");\n    }\n    /**\n     * 3. Let output be the empty string.\n     */\n    var output = \"\";\n    try {\n        /**\n         * 4. For each tuple in tuples:\n         */\n        for (var tuples_1 = __values(tuples), tuples_1_1 = tuples_1.next(); !tuples_1_1.done; tuples_1_1 = tuples_1.next()) {\n            var tuple = tuples_1_1.value;\n            /**\n             * 4.1. Let name be the result of serializing the result of encoding\n             * tuple’s name, using encoding.\n             */\n            var name = urlEncodedByteSerializer(util_1.utf8Encode(tuple[0]));\n            /**\n             * 4.2. Let value be tuple’s value.\n             */\n            var value = tuple[1];\n            /**\n             * TODO:\n             * 4.3. If value is a file, then set value to value’s filename.\n             */\n            /**\n             * 4.4. Set value to the result of serializing the result of encoding\n             * value, using encoding.\n             */\n            value = urlEncodedByteSerializer(util_1.utf8Encode(value));\n            /**\n             * 4.5. If tuple is not the first pair in tuples, then append U+0026 (&)\n             * to output.\n             */\n            if (output !== \"\")\n                output += '&';\n            /**\n             * 4.6. Append name, followed by U+003D (=), followed by value, to output.\n             */\n            output += name + '=' + value;\n        }\n    }\n    catch (e_13_1) { e_13 = { error: e_13_1 }; }\n    finally {\n        try {\n            if (tuples_1_1 && !tuples_1_1.done && (_a = tuples_1.return)) _a.call(tuples_1);\n        }\n        finally { if (e_13) throw e_13.error; }\n    }\n    /**\n     * 5. Return output.\n     */\n    return output;\n}\nexports.urlEncodedSerializer = urlEncodedSerializer;\n/**\n * Returns a URL's origin.\n *\n * @param url - a URL\n */\nfunction origin(url) {\n    /**\n     * A URL’s origin is the origin returned by running these steps, switching\n     * on URL’s scheme:\n     * \"blob\"\n     * 1. If URL’s blob URL entry is non-null, then return URL’s blob URL\n     * entry’s environment’s origin.\n     * 2. Let url be the result of parsing URL’s path[0].\n     * 3. Return a new opaque origin, if url is failure, and url’s origin\n     * otherwise.\n     * \"ftp\"\n     * \"http\"\n     * \"https\"\n     * \"ws\"\n     * \"wss\"\n     * Return a tuple consisting of URL’s scheme, URL’s host, URL’s port, and\n     * null.\n     * \"file\"\n     * Unfortunate as it is, is left as an exercise to the reader. When in\n     * doubt, return a new opaque origin.\n     * Otherwise\n     * Return a new opaque origin.\n     */\n    switch (url.scheme) {\n        case \"blob\":\n            if (url._blobURLEntry !== null) {\n                // TODO: return URL’s blob URL entry’s environment’s origin.\n            }\n            var parsedURL = basicURLParser(url.path[0]);\n            if (parsedURL === null)\n                return interfaces_1.OpaqueOrigin;\n            else\n                return origin(parsedURL);\n        case \"ftp\":\n        case \"http\":\n        case \"https\":\n        case \"ws\":\n        case \"wss\":\n            return [url.scheme, url.host === null ? \"\" : url.host, url.port, null];\n        case \"file\":\n            return interfaces_1.OpaqueOrigin;\n        default:\n            return interfaces_1.OpaqueOrigin;\n    }\n}\nexports.origin = origin;\n/**\n * Converts a domain string to ASCII.\n *\n * @param domain - a domain string\n */\nfunction domainToASCII(domain, beStrict) {\n    if (beStrict === void 0) { beStrict = false; }\n    /**\n     * 1. If beStrict is not given, set it to false.\n     * 2. Let result be the result of running Unicode ToASCII with domain_name\n     * set to domain, UseSTD3ASCIIRules set to beStrict, CheckHyphens set to\n     * false, CheckBidi set to true, CheckJoiners set to true,\n     * Transitional_Processing set to false, and VerifyDnsLength set to beStrict.\n     * 3. If result is a failure value, validation error, return failure.\n     * 4. Return result.\n     */\n    // Use node.js function\n    var result = url_1.domainToASCII(domain);\n    if (result === \"\") {\n        validationError(\"Invalid domain name.\");\n        return null;\n    }\n    return result;\n}\nexports.domainToASCII = domainToASCII;\n/**\n * Converts a domain string to Unicode.\n *\n * @param domain - a domain string\n */\nfunction domainToUnicode(domain, beStrict) {\n    if (beStrict === void 0) { beStrict = false; }\n    /**\n     * 1. Let result be the result of running Unicode ToUnicode with domain_name\n     * set to domain, CheckHyphens set to false, CheckBidi set to true,\n     * CheckJoiners set to true, UseSTD3ASCIIRules set to false, and\n     * Transitional_Processing set to false.\n     * 2. Signify validation errors for any returned errors, and then,\n     * return result.\n     */\n    // Use node.js function\n    var result = url_1.domainToUnicode(domain);\n    if (result === \"\") {\n        validationError(\"Invalid domain name.\");\n    }\n    return result;\n}\nexports.domainToUnicode = domainToUnicode;\n/**\n * Serializes an origin.\n * function is from the HTML spec:\n * https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin\n *\n * @param origin - an origin\n */\nfunction asciiSerializationOfAnOrigin(origin) {\n    /**\n     * 1. If origin is an opaque origin, then return \"null\".\n     * 2. Otherwise, let result be origin's scheme.\n     * 3. Append \"://\" to result.\n     * 4. Append origin's host, serialized, to result.\n     * 5. If origin's port is non-null, append a U+003A COLON character (:),\n     * and origin's port, serialized, to result.\n     * 6. Return result.\n     */\n    if (origin[0] === \"\" && origin[1] === \"\" && origin[2] === null && origin[3] === null) {\n        return \"null\";\n    }\n    var result = origin[0] + \"://\" + hostSerializer(origin[1]);\n    if (origin[2] !== null)\n        result += \":\" + origin[2].toString();\n    return result;\n}\nexports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;\n//# sourceMappingURL=URLAlgorithm.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents the state of the URL parser.\n */\nvar ParserState;\n(function (ParserState) {\n    ParserState[ParserState[\"SchemeStart\"] = 0] = \"SchemeStart\";\n    ParserState[ParserState[\"Scheme\"] = 1] = \"Scheme\";\n    ParserState[ParserState[\"NoScheme\"] = 2] = \"NoScheme\";\n    ParserState[ParserState[\"SpecialRelativeOrAuthority\"] = 3] = \"SpecialRelativeOrAuthority\";\n    ParserState[ParserState[\"PathOrAuthority\"] = 4] = \"PathOrAuthority\";\n    ParserState[ParserState[\"Relative\"] = 5] = \"Relative\";\n    ParserState[ParserState[\"RelativeSlash\"] = 6] = \"RelativeSlash\";\n    ParserState[ParserState[\"SpecialAuthoritySlashes\"] = 7] = \"SpecialAuthoritySlashes\";\n    ParserState[ParserState[\"SpecialAuthorityIgnoreSlashes\"] = 8] = \"SpecialAuthorityIgnoreSlashes\";\n    ParserState[ParserState[\"Authority\"] = 9] = \"Authority\";\n    ParserState[ParserState[\"Host\"] = 10] = \"Host\";\n    ParserState[ParserState[\"Hostname\"] = 11] = \"Hostname\";\n    ParserState[ParserState[\"Port\"] = 12] = \"Port\";\n    ParserState[ParserState[\"File\"] = 13] = \"File\";\n    ParserState[ParserState[\"FileSlash\"] = 14] = \"FileSlash\";\n    ParserState[ParserState[\"FileHost\"] = 15] = \"FileHost\";\n    ParserState[ParserState[\"PathStart\"] = 16] = \"PathStart\";\n    ParserState[ParserState[\"Path\"] = 17] = \"Path\";\n    ParserState[ParserState[\"CannotBeABaseURLPath\"] = 18] = \"CannotBeABaseURLPath\";\n    ParserState[ParserState[\"Query\"] = 19] = \"Query\";\n    ParserState[ParserState[\"Fragment\"] = 20] = \"Fragment\";\n})(ParserState = exports.ParserState || (exports.ParserState = {}));\nexports.OpaqueOrigin = [\"\", \"\", null, null];\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a cache for storing order between equal objects.\n *\n * This cache is used when an algorithm compares two objects and finds them to\n * be equal but still needs to establish an order between those two objects.\n * When two such objects `a` and `b` are passed to the `check` method, a random\n * number is generated with `Math.random()`. If the random number is less than\n * `0.5` it is assumed that `a < b` otherwise `a > b`. The random number along\n * with `a` and `b` is stored in the cache, so that subsequent checks result\n * in the same consistent result.\n *\n * The cache has a size limit which is defined on initialization.\n */\nvar CompareCache = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `CompareCache`.\n     *\n     * @param limit - maximum number of items to keep in the cache. When the limit\n     * is exceeded the first item is removed from the cache.\n     */\n    function CompareCache(limit) {\n        if (limit === void 0) { limit = 1000; }\n        this._items = new Map();\n        this._limit = limit;\n    }\n    /**\n     * Compares and caches the given objects. Returns `true` if `objA < objB` and\n     * `false` otherwise.\n     *\n     * @param objA - an item to compare\n     * @param objB - an item to compare\n     */\n    CompareCache.prototype.check = function (objA, objB) {\n        if (this._items.get(objA) === objB)\n            return true;\n        else if (this._items.get(objB) === objA)\n            return false;\n        var result = (Math.random() < 0.5);\n        if (result) {\n            this._items.set(objA, objB);\n        }\n        else {\n            this._items.set(objB, objA);\n        }\n        if (this._items.size > this._limit) {\n            var it_1 = this._items.keys().next();\n            /* istanbul ignore else */\n            if (!it_1.done) {\n                this._items.delete(it_1.value);\n            }\n        }\n        return result;\n    };\n    return CompareCache;\n}());\nexports.CompareCache = CompareCache;\n//# sourceMappingURL=CompareCache.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a set of objects with a size limit.\n */\nvar FixedSizeSet = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `FixedSizeSet`.\n     *\n     * @param limit - maximum number of items to keep in the set. When the limit\n     * is exceeded the first item is removed from the set.\n     */\n    function FixedSizeSet(limit) {\n        if (limit === void 0) { limit = 1000; }\n        this._items = new Set();\n        this._limit = limit;\n    }\n    /**\n     * Adds a new item to the set.\n     *\n     * @param item - an item\n     */\n    FixedSizeSet.prototype.add = function (item) {\n        this._items.add(item);\n        if (this._items.size > this._limit) {\n            var it_1 = this._items.values().next();\n            /* istanbul ignore else */\n            if (!it_1.done) {\n                this._items.delete(it_1.value);\n            }\n        }\n        return this;\n    };\n    /**\n     * Removes an item from the set.\n     *\n     * @param item - an item\n     */\n    FixedSizeSet.prototype.delete = function (item) {\n        return this._items.delete(item);\n    };\n    /**\n     * Determines if an item is in the set.\n     *\n     * @param item - an item\n     */\n    FixedSizeSet.prototype.has = function (item) {\n        return this._items.has(item);\n    };\n    /**\n     * Removes all items from the set.\n     */\n    FixedSizeSet.prototype.clear = function () {\n        this._items.clear();\n    };\n    Object.defineProperty(FixedSizeSet.prototype, \"size\", {\n        /**\n         * Gets the number of items in the set.\n         */\n        get: function () { return this._items.size; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Applies the given callback function to all elements of the set.\n     */\n    FixedSizeSet.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this._items.forEach(function (e) { return callback.call(thisArg, e, e, _this); });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    FixedSizeSet.prototype.keys = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items.keys())];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    FixedSizeSet.prototype.values = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items.values())];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    FixedSizeSet.prototype.entries = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items.entries())];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    FixedSizeSet.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    Object.defineProperty(FixedSizeSet.prototype, Symbol.toStringTag, {\n        /**\n         * Returns the string tag of the set.\n         */\n        get: function () {\n            return \"FixedSizeSet\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FixedSizeSet;\n}());\nexports.FixedSizeSet = FixedSizeSet;\n//# sourceMappingURL=FixedSizeSet.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents an object with lazy initialization.\n */\nvar Lazy = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `Lazy`.\n     *\n     * @param initFunc - initializer function\n     */\n    function Lazy(initFunc) {\n        this._initialized = false;\n        this._value = undefined;\n        this._initFunc = initFunc;\n    }\n    Object.defineProperty(Lazy.prototype, \"value\", {\n        /**\n         * Gets the value of the object.\n         */\n        get: function () {\n            if (!this._initialized) {\n                this._value = this._initFunc();\n                this._initialized = true;\n            }\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Lazy;\n}());\nexports.Lazy = Lazy;\n//# sourceMappingURL=Lazy.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a cache of objects with a size limit.\n */\nvar ObjectCache = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `ObjectCache`.\n     *\n     * @param limit - maximum number of items to keep in the cache. When the limit\n     * is exceeded the first item is removed from the cache.\n     */\n    function ObjectCache(limit) {\n        if (limit === void 0) { limit = 1000; }\n        this._items = new Map();\n        this._limit = limit;\n    }\n    /**\n     * Gets an item from the cache.\n     *\n     * @param key - object key\n     */\n    ObjectCache.prototype.get = function (key) {\n        return this._items.get(key);\n    };\n    /**\n     * Adds a new item to the cache.\n     *\n     * @param key - object key\n     * @param value - object value\n     */\n    ObjectCache.prototype.set = function (key, value) {\n        this._items.set(key, value);\n        if (this._items.size > this._limit) {\n            var it_1 = this._items.keys().next();\n            /* istanbul ignore else */\n            if (!it_1.done) {\n                this._items.delete(it_1.value);\n            }\n        }\n    };\n    /**\n     * Removes an item from the cache.\n     *\n     * @param item - an item\n     */\n    ObjectCache.prototype.delete = function (key) {\n        return this._items.delete(key);\n    };\n    /**\n     * Determines if an item is in the cache.\n     *\n     * @param item - an item\n     */\n    ObjectCache.prototype.has = function (key) {\n        return this._items.has(key);\n    };\n    /**\n     * Removes all items from the cache.\n     */\n    ObjectCache.prototype.clear = function () {\n        this._items.clear();\n    };\n    Object.defineProperty(ObjectCache.prototype, \"size\", {\n        /**\n         * Gets the number of items in the cache.\n         */\n        get: function () { return this._items.size; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Applies the given callback function to all elements of the cache.\n     */\n    ObjectCache.prototype.forEach = function (callback, thisArg) {\n        this._items.forEach(function (v, k) { return callback.call(thisArg, k, v); });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    ObjectCache.prototype.keys = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items.keys())];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    ObjectCache.prototype.values = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items.values())];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    ObjectCache.prototype.entries = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items.entries())];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterates through the items in the set.\n     */\n    ObjectCache.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [5 /*yield**/, __values(this._items)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    };\n    Object.defineProperty(ObjectCache.prototype, Symbol.toStringTag, {\n        /**\n         * Returns the string tag of the cache.\n         */\n        get: function () {\n            return \"ObjectCache\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ObjectCache;\n}());\nexports.ObjectCache = ObjectCache;\n//# sourceMappingURL=ObjectCache.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Walks through the code points of a string.\n */\nvar StringWalker = /** @class */ (function () {\n    /**\n     * Initializes a new `StringWalker`.\n     *\n     * @param input - input string\n     */\n    function StringWalker(input) {\n        this._pointer = 0;\n        this._chars = Array.from(input);\n        this._length = this._chars.length;\n    }\n    Object.defineProperty(StringWalker.prototype, \"eof\", {\n        /**\n         * Determines if the current position is beyond the end of string.\n         */\n        get: function () { return this._pointer >= this._length; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StringWalker.prototype, \"length\", {\n        /**\n         * Returns the number of code points in the input string.\n         */\n        get: function () { return this._length; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the current code point. Returns `-1` if the position is beyond\n     * the end of string.\n     */\n    StringWalker.prototype.codePoint = function () {\n        if (this._codePoint === undefined) {\n            if (this.eof) {\n                this._codePoint = -1;\n            }\n            else {\n                var cp = this._chars[this._pointer].codePointAt(0);\n                /* istanbul ignore else */\n                if (cp !== undefined) {\n                    this._codePoint = cp;\n                }\n                else {\n                    this._codePoint = -1;\n                }\n            }\n        }\n        return this._codePoint;\n    };\n    /**\n     * Returns the current character. Returns an empty string if the position is\n     * beyond the end of string.\n     */\n    StringWalker.prototype.c = function () {\n        if (this._c === undefined) {\n            this._c = (this.eof ? \"\" : this._chars[this._pointer]);\n        }\n        return this._c;\n    };\n    /**\n     * Returns the remaining string.\n     */\n    StringWalker.prototype.remaining = function () {\n        if (this._remaining === undefined) {\n            this._remaining = (this.eof ?\n                \"\" : this._chars.slice(this._pointer + 1).join(''));\n        }\n        return this._remaining;\n    };\n    /**\n     * Returns the substring from the current character to the end of string.\n     */\n    StringWalker.prototype.substring = function () {\n        if (this._substring === undefined) {\n            this._substring = (this.eof ?\n                \"\" : this._chars.slice(this._pointer).join(''));\n        }\n        return this._substring;\n    };\n    Object.defineProperty(StringWalker.prototype, \"pointer\", {\n        /**\n         * Gets or sets the current position.\n         */\n        get: function () { return this._pointer; },\n        set: function (val) {\n            if (val === this._pointer)\n                return;\n            this._pointer = val;\n            this._codePoint = undefined;\n            this._c = undefined;\n            this._remaining = undefined;\n            this._substring = undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return StringWalker;\n}());\nexports.StringWalker = StringWalker;\n//# sourceMappingURL=StringWalker.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FixedSizeSet_1 = require(\"./FixedSizeSet\");\nexports.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;\nvar ObjectCache_1 = require(\"./ObjectCache\");\nexports.ObjectCache = ObjectCache_1.ObjectCache;\nvar CompareCache_1 = require(\"./CompareCache\");\nexports.CompareCache = CompareCache_1.CompareCache;\nvar Lazy_1 = require(\"./Lazy\");\nexports.Lazy = Lazy_1.Lazy;\nvar StringWalker_1 = require(\"./StringWalker\");\nexports.StringWalker = StringWalker_1.StringWalker;\n/**\n * Applies the mixin to a given class.\n *\n * @param baseClass - class to receive the mixin\n * @param mixinClass - mixin class\n * @param overrides - an array with names of function overrides. Base class\n * functions whose names are in this array will be kept by prepending an\n * underscore to their names.\n */\nfunction applyMixin(baseClass, mixinClass) {\n    var overrides = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        overrides[_i - 2] = arguments[_i];\n    }\n    Object.getOwnPropertyNames(mixinClass.prototype).forEach(function (name) {\n        if (name !== \"constructor\") {\n            if (overrides.indexOf(name) !== -1) {\n                var orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);\n                /* istanbul ignore else */\n                if (orgPropDesc) {\n                    Object.defineProperty(baseClass.prototype, \"_\" + name, orgPropDesc);\n                }\n            }\n            var propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);\n            /* istanbul ignore else */\n            if (propDesc) {\n                Object.defineProperty(baseClass.prototype, name, propDesc);\n            }\n        }\n    });\n}\nexports.applyMixin = applyMixin;\n/**\n * Applies default values to the given object.\n *\n * @param obj - an object\n * @param defaults - an object with default values\n * @param overwrite - if set to `true` defaults object always overwrites object\n * values, whether they are `undefined` or not.\n */\nfunction applyDefaults(obj, defaults, overwrite) {\n    if (overwrite === void 0) { overwrite = false; }\n    var result = clone(obj || {});\n    forEachObject(defaults, function (key, val) {\n        if (isPlainObject(val)) {\n            result[key] = applyDefaults(result[key], val, overwrite);\n        }\n        else if (overwrite || result[key] === undefined) {\n            result[key] = val;\n        }\n    });\n    return result;\n}\nexports.applyDefaults = applyDefaults;\n/**\n * Iterates over items of an array or set.\n *\n * @param arr - array or set to iterate\n * @param callback - a callback function which receives each array item as its\n * single argument\n * @param thisArg - the value of this inside callback\n */\nfunction forEachArray(arr, callback, thisArg) {\n    arr.forEach(callback, thisArg);\n}\nexports.forEachArray = forEachArray;\n/**\n * Iterates over key/value pairs of a map or object.\n *\n * @param obj - map or object to iterate\n * @param callback - a callback function which receives object key as its first\n * argument and object value as its second argument\n * @param thisArg - the value of this inside callback\n */\nfunction forEachObject(obj, callback, thisArg) {\n    if (isMap(obj)) {\n        obj.forEach(function (value, key) { return callback.call(thisArg, key, value); });\n    }\n    else {\n        for (var key in obj) {\n            /* istanbul ignore else */\n            if (obj.hasOwnProperty(key)) {\n                callback.call(thisArg, key, obj[key]);\n            }\n        }\n    }\n}\nexports.forEachObject = forEachObject;\n/**\n * Returns the number of entries in an array or set.\n *\n * @param arr - array or set\n */\nfunction arrayLength(obj) {\n    if (isSet(obj)) {\n        return obj.size;\n    }\n    else {\n        return obj.length;\n    }\n}\nexports.arrayLength = arrayLength;\n/**\n * Returns the number of entries in a map or object.\n *\n * @param obj - map or object\n */\nfunction objectLength(obj) {\n    if (isMap(obj)) {\n        return obj.size;\n    }\n    else {\n        return Object.keys(obj).length;\n    }\n}\nexports.objectLength = objectLength;\n/**\n * Gets the value of a key from a map or object.\n *\n * @param obj - map or object\n * @param key - the key to retrieve\n */\nfunction getObjectValue(obj, key) {\n    if (isMap(obj)) {\n        return obj.get(key);\n    }\n    else {\n        return obj[key];\n    }\n}\nexports.getObjectValue = getObjectValue;\n/**\n * Removes a property from a map or object.\n *\n * @param obj - map or object\n * @param key - the key to remove\n */\nfunction removeObjectValue(obj, key) {\n    if (isMap(obj)) {\n        obj.delete(key);\n    }\n    else {\n        delete obj[key];\n    }\n}\nexports.removeObjectValue = removeObjectValue;\n/**\n * Deep clones the given object.\n *\n * @param obj - an object\n */\nfunction clone(obj) {\n    var e_1, _a;\n    if (isFunction(obj)) {\n        return obj;\n    }\n    else if (isArray(obj)) {\n        var result = [];\n        try {\n            for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {\n                var item = obj_1_1.value;\n                result.push(clone(item));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    }\n    else if (isObject(obj)) {\n        var result = {};\n        for (var key in obj) {\n            /* istanbul ignore next */\n            if (obj.hasOwnProperty(key)) {\n                var val = obj[key];\n                result[key] = clone(val);\n            }\n        }\n        return result;\n    }\n    else {\n        return obj;\n    }\n}\nexports.clone = clone;\n/**\n * Type guard for boolean types\n *\n * @param x - a variable to type check\n */\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nexports.isBoolean = isBoolean;\n/**\n * Type guard for numeric types\n *\n * @param x - a variable to type check\n */\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nexports.isNumber = isNumber;\n/**\n * Type guard for strings\n *\n * @param x - a variable to type check\n */\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nexports.isString = isString;\n/**\n * Type guard for function objects\n *\n * @param x - a variable to type check\n */\nfunction isFunction(x) {\n    return !!x && Object.prototype.toString.call(x) === '[object Function]';\n}\nexports.isFunction = isFunction;\n/**\n * Type guard for JS objects\n *\n * _Note:_ Functions are objects too\n *\n * @param x - a variable to type check\n */\nfunction isObject(x) {\n    var type = typeof x;\n    return !!x && (type === 'function' || type === 'object');\n}\nexports.isObject = isObject;\n/**\n * Type guard for arrays\n *\n * @param x - a variable to type check\n */\nfunction isArray(x) {\n    return Array.isArray(x);\n}\nexports.isArray = isArray;\n/**\n * Type guard for sets.\n *\n * @param x - a variable to check\n */\nfunction isSet(x) {\n    return x instanceof Set;\n}\nexports.isSet = isSet;\n/**\n * Type guard for maps.\n *\n * @param x - a variable to check\n */\nfunction isMap(x) {\n    return x instanceof Map;\n}\nexports.isMap = isMap;\n/**\n * Determines if `x` is an empty Array or an Object with no own properties.\n *\n * @param x - a variable to check\n */\nfunction isEmpty(x) {\n    if (isArray(x)) {\n        return !x.length;\n    }\n    else if (isSet(x)) {\n        return !x.size;\n    }\n    else if (isMap(x)) {\n        return !x.size;\n    }\n    else if (isObject(x)) {\n        for (var key in x) {\n            if (x.hasOwnProperty(key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexports.isEmpty = isEmpty;\n/**\n * Determines if `x` is a plain Object.\n *\n * @param x - a variable to check\n */\nfunction isPlainObject(x) {\n    if (isObject(x)) {\n        var proto = Object.getPrototypeOf(x);\n        var ctor = proto.constructor;\n        return proto && ctor &&\n            (typeof ctor === 'function') && (ctor instanceof ctor) &&\n            (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));\n    }\n    return false;\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Determines if `x` is an iterable Object.\n *\n * @param x - a variable to check\n */\nfunction isIterable(x) {\n    return x && (typeof x[Symbol.iterator] === 'function');\n}\nexports.isIterable = isIterable;\n/**\n * Gets the primitive value of an object.\n */\nfunction getValue(obj) {\n    if (isFunction(obj.valueOf)) {\n        return obj.valueOf();\n    }\n    else {\n        return obj;\n    }\n}\nexports.getValue = getValue;\n/**\n * UTF-8 encodes the given string.\n *\n * @param input - a string\n */\nfunction utf8Encode(input) {\n    var bytes = new Uint8Array(input.length * 4);\n    var byteIndex = 0;\n    for (var i = 0; i < input.length; i++) {\n        var char = input.charCodeAt(i);\n        if (char < 128) {\n            bytes[byteIndex++] = char;\n            continue;\n        }\n        else if (char < 2048) {\n            bytes[byteIndex++] = char >> 6 | 192;\n        }\n        else {\n            if (char > 0xd7ff && char < 0xdc00) {\n                if (++i >= input.length) {\n                    throw new Error(\"Incomplete surrogate pair.\");\n                }\n                var c2 = input.charCodeAt(i);\n                if (c2 < 0xdc00 || c2 > 0xdfff) {\n                    throw new Error(\"Invalid surrogate character.\");\n                }\n                char = 0x10000 + ((char & 0x03ff) << 10) + (c2 & 0x03ff);\n                bytes[byteIndex++] = char >> 18 | 240;\n                bytes[byteIndex++] = char >> 12 & 63 | 128;\n            }\n            else {\n                bytes[byteIndex++] = char >> 12 | 224;\n            }\n            bytes[byteIndex++] = char >> 6 & 63 | 128;\n        }\n        bytes[byteIndex++] = char & 63 | 128;\n    }\n    return bytes.subarray(0, byteIndex);\n}\nexports.utf8Encode = utf8Encode;\n/**\n * UTF-8 decodes the given byte sequence into a string.\n *\n * @param bytes - a byte sequence\n */\nfunction utf8Decode(bytes) {\n    var result = \"\";\n    var i = 0;\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        if (c > 127) {\n            if (c > 191 && c < 224) {\n                if (i >= bytes.length) {\n                    throw new Error(\"Incomplete 2-byte sequence.\");\n                }\n                c = (c & 31) << 6 | bytes[i++] & 63;\n            }\n            else if (c > 223 && c < 240) {\n                if (i + 1 >= bytes.length) {\n                    throw new Error(\"Incomplete 3-byte sequence.\");\n                }\n                c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\n            }\n            else if (c > 239 && c < 248) {\n                if (i + 2 >= bytes.length) {\n                    throw new Error(\"Incomplete 4-byte sequence.\");\n                }\n                c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\n            }\n            else {\n                throw new Error(\"Unknown multi-byte start.\");\n            }\n        }\n        if (c <= 0xffff) {\n            result += String.fromCharCode(c);\n        }\n        else if (c <= 0x10ffff) {\n            c -= 0x10000;\n            result += String.fromCharCode(c >> 10 | 0xd800);\n            result += String.fromCharCode(c & 0x3FF | 0xdc00);\n        }\n        else {\n            throw new Error(\"Code point exceeds UTF-16 limit.\");\n        }\n    }\n    return result;\n}\nexports.utf8Decode = utf8Decode;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dedent = void 0;\nfunction dedent(templ) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    var strings = Array.from(typeof templ === 'string' ? [templ] : templ);\n    strings[strings.length - 1] = strings[strings.length - 1].replace(/\\r?\\n([\\t ]*)$/, '');\n    var indentLengths = strings.reduce(function (arr, str) {\n        var matches = str.match(/\\n([\\t ]+|(?!\\s).)/g);\n        if (matches) {\n            return arr.concat(matches.map(function (match) { var _a, _b; return (_b = (_a = match.match(/[\\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0; }));\n        }\n        return arr;\n    }, []);\n    if (indentLengths.length) {\n        var pattern_1 = new RegExp(\"\\n[\\t ]{\" + Math.min.apply(Math, indentLengths) + \"}\", 'g');\n        strings = strings.map(function (str) { return str.replace(pattern_1, '\\n'); });\n    }\n    strings[0] = strings[0].replace(/^\\r?\\n/, '');\n    var string = strings[0];\n    values.forEach(function (value, i) {\n        var endentations = string.match(/(?:^|\\n)( *)$/);\n        var endentation = endentations ? endentations[1] : '';\n        var indentedValue = value;\n        if (typeof value === 'string' && value.includes('\\n')) {\n            indentedValue = String(value)\n                .split('\\n')\n                .map(function (str, i) {\n                return i === 0 ? str : \"\" + endentation + str;\n            })\n                .join('\\n');\n        }\n        string += indentedValue + strings[i + 1];\n    });\n    return string;\n}\nexports.dedent = dedent;\nexports.default = dedent;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../interfaces\");\nvar util_1 = require(\"@oozcitak/util\");\nvar util_2 = require(\"@oozcitak/dom/lib/util\");\nvar _1 = require(\".\");\nvar dom_1 = require(\"../builder/dom\");\n/** @inheritdoc */\nfunction builder(p1, p2) {\n    var options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);\n    var nodes = util_2.Guard.isNode(p1) || util_1.isArray(p1) ? p1 : p2;\n    if (nodes === undefined) {\n        throw new Error(\"Invalid arguments.\");\n    }\n    if (util_1.isArray(nodes)) {\n        var builders = [];\n        for (var i = 0; i < nodes.length; i++) {\n            var builder_1 = new _1.XMLBuilderImpl(nodes[i]);\n            builder_1.set(options);\n            builders.push(builder_1);\n        }\n        return builders;\n    }\n    else {\n        var builder_2 = new _1.XMLBuilderImpl(nodes);\n        builder_2.set(options);\n        return builder_2;\n    }\n}\nexports.builder = builder;\n/** @inheritdoc */\nfunction create(p1, p2) {\n    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?\n        p1 : interfaces_1.DefaultBuilderOptions);\n    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;\n    var doc = dom_1.createDocument();\n    setOptions(doc, options);\n    var builder = new _1.XMLBuilderImpl(doc);\n    if (contents !== undefined) {\n        // parse contents\n        builder.ele(contents);\n    }\n    return builder;\n}\nexports.create = create;\n/** @inheritdoc */\nfunction fragment(p1, p2) {\n    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?\n        p1 : interfaces_1.DefaultBuilderOptions);\n    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;\n    var doc = dom_1.createDocument();\n    setOptions(doc, options, true);\n    var builder = new _1.XMLBuilderImpl(doc.createDocumentFragment());\n    if (contents !== undefined) {\n        // parse contents\n        builder.ele(contents);\n    }\n    return builder;\n}\nexports.fragment = fragment;\n/** @inheritdoc */\nfunction convert(p1, p2, p3) {\n    var builderOptions;\n    var contents;\n    var convertOptions;\n    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {\n        builderOptions = p1;\n        contents = p2;\n        convertOptions = p3;\n    }\n    else {\n        builderOptions = interfaces_1.DefaultBuilderOptions;\n        contents = p1;\n        convertOptions = p2 || undefined;\n    }\n    return create(builderOptions, contents).end(convertOptions);\n}\nexports.convert = convert;\nfunction isXMLBuilderCreateOptions(obj) {\n    if (!util_1.isPlainObject(obj))\n        return false;\n    for (var key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(key)) {\n            if (!interfaces_1.XMLBuilderOptionKeys.has(key))\n                return false;\n        }\n    }\n    return true;\n}\nfunction formatBuilderOptions(createOptions) {\n    if (createOptions === void 0) { createOptions = {}; }\n    var options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);\n    if (options.convert.att.length === 0 ||\n        options.convert.ins.length === 0 ||\n        options.convert.text.length === 0 ||\n        options.convert.cdata.length === 0 ||\n        options.convert.comment.length === 0) {\n        throw new Error(\"JS object converter strings cannot be zero length.\");\n    }\n    return options;\n}\nfunction setOptions(doc, options, isFragment) {\n    var docWithSettings = doc;\n    docWithSettings._xmlBuilderOptions = options;\n    docWithSettings._isFragment = isFragment;\n}\n//# sourceMappingURL=BuilderFunctions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = require(\".\");\n/**\n * Creates an XML builder which serializes the document in chunks.\n *\n * @param options - callback builder options\n *\n * @returns callback builder\n */\nfunction createCB(options) {\n    return new _1.XMLBuilderCBImpl(options);\n}\nexports.createCB = createCB;\n/**\n * Creates an XML builder which serializes the fragment in chunks.\n *\n * @param options - callback builder options\n *\n * @returns callback builder\n */\nfunction fragmentCB(options) {\n    return new _1.XMLBuilderCBImpl(options, true);\n}\nexports.fragmentCB = fragmentCB;\n//# sourceMappingURL=BuilderFunctionsCB.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../interfaces\");\nvar util_1 = require(\"@oozcitak/util\");\nvar BuilderFunctions_1 = require(\"./BuilderFunctions\");\nvar algorithm_1 = require(\"@oozcitak/dom/lib/algorithm\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar NamespacePrefixMap_1 = require(\"@oozcitak/dom/lib/serializer/NamespacePrefixMap\");\nvar LocalNameSet_1 = require(\"@oozcitak/dom/lib/serializer/LocalNameSet\");\nvar util_2 = require(\"@oozcitak/dom/lib/util\");\nvar XMLCBWriter_1 = require(\"../writers/XMLCBWriter\");\nvar JSONCBWriter_1 = require(\"../writers/JSONCBWriter\");\nvar YAMLCBWriter_1 = require(\"../writers/YAMLCBWriter\");\nvar events_1 = require(\"events\");\n/**\n * Represents a readable XML document stream.\n */\nvar XMLBuilderCBImpl = /** @class */ (function (_super) {\n    __extends(XMLBuilderCBImpl, _super);\n    /**\n     * Initializes a new instance of `XMLStream`.\n     *\n     * @param options - stream writer options\n     * @param fragment - whether to create fragment stream or a document stream\n     *\n     * @returns XML stream\n     */\n    function XMLBuilderCBImpl(options, fragment) {\n        if (fragment === void 0) { fragment = false; }\n        var _this = _super.call(this) || this;\n        _this._hasDeclaration = false;\n        _this._docTypeName = \"\";\n        _this._hasDocumentElement = false;\n        _this._currentElementSerialized = false;\n        _this._openTags = [];\n        _this._ended = false;\n        _this._fragment = fragment;\n        // provide default options\n        _this._options = util_1.applyDefaults(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);\n        _this._builderOptions = {\n            defaultNamespace: _this._options.defaultNamespace,\n            namespaceAlias: _this._options.namespaceAlias\n        };\n        if (_this._options.format === \"json\") {\n            _this._writer = new JSONCBWriter_1.JSONCBWriter(_this._options);\n        }\n        else if (_this._options.format === \"yaml\") {\n            _this._writer = new YAMLCBWriter_1.YAMLCBWriter(_this._options);\n        }\n        else {\n            _this._writer = new XMLCBWriter_1.XMLCBWriter(_this._options);\n        }\n        // automatically create listeners for callbacks passed via options\n        if (_this._options.data !== undefined) {\n            _this.on(\"data\", _this._options.data);\n        }\n        if (_this._options.end !== undefined) {\n            _this.on(\"end\", _this._options.end);\n        }\n        if (_this._options.error !== undefined) {\n            _this.on(\"error\", _this._options.error);\n        }\n        _this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();\n        _this._prefixMap.set(\"xml\", infra_1.namespace.XML);\n        _this._prefixIndex = { value: 1 };\n        _this._push(_this._writer.frontMatter());\n        return _this;\n    }\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.ele = function (p1, p2, p3) {\n        var e_1, _a;\n        // parse if JS object or XML or JSON string\n        if (util_1.isObject(p1) || (util_1.isString(p1) && (/^\\s*</.test(p1) || /^\\s*[\\{\\[]/.test(p1) || /^(\\s*|(#.*)|(%.*))*---/.test(p1)))) {\n            var frag = BuilderFunctions_1.fragment().set(this._options);\n            try {\n                frag.ele(p1);\n            }\n            catch (err) {\n                this.emit(\"error\", err);\n                return this;\n            }\n            try {\n                for (var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var node = _c.value;\n                    this._fromNode(node);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return this;\n        }\n        this._serializeOpenTag(true);\n        if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {\n            this.emit(\"error\", new Error(\"Document cannot have multiple document element nodes.\"));\n            return this;\n        }\n        try {\n            this._currentElement = BuilderFunctions_1.fragment(this._builderOptions).ele(p1, p2, p3);\n        }\n        catch (err) {\n            this.emit(\"error\", err);\n            return this;\n        }\n        if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== \"\"\n            && this._currentElement.node._qualifiedName !== this._docTypeName) {\n            this.emit(\"error\", new Error(\"Document element name does not match DocType declaration name.\"));\n            return this;\n        }\n        this._currentElementSerialized = false;\n        if (!this._fragment) {\n            this._hasDocumentElement = true;\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.att = function (p1, p2, p3) {\n        if (this._currentElement === undefined) {\n            this.emit(\"error\", new Error(\"Cannot insert an attribute node as child of a document node.\"));\n            return this;\n        }\n        try {\n            this._currentElement.att(p1, p2, p3);\n        }\n        catch (err) {\n            this.emit(\"error\", err);\n            return this;\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.com = function (content) {\n        this._serializeOpenTag(true);\n        var node;\n        try {\n            node = BuilderFunctions_1.fragment(this._builderOptions).com(content).first().node;\n        }\n        catch (err) {\n            /* istanbul ignore next */\n            this.emit(\"error\", err);\n            /* istanbul ignore next */\n            return this;\n        }\n        if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||\n            node.data.indexOf(\"--\") !== -1 || node.data.endsWith(\"-\"))) {\n            this.emit(\"error\", new Error(\"Comment data contains invalid characters (well-formed required).\"));\n            return this;\n        }\n        this._push(this._writer.comment(node.data));\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.txt = function (content) {\n        if (!this._fragment && this._currentElement === undefined) {\n            this.emit(\"error\", new Error(\"Cannot insert a text node as child of a document node.\"));\n            return this;\n        }\n        this._serializeOpenTag(true);\n        var node;\n        try {\n            node = BuilderFunctions_1.fragment(this._builderOptions).txt(content).first().node;\n        }\n        catch (err) {\n            /* istanbul ignore next */\n            this.emit(\"error\", err);\n            /* istanbul ignore next */\n            return this;\n        }\n        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {\n            this.emit(\"error\", new Error(\"Text data contains invalid characters (well-formed required).\"));\n            return this;\n        }\n        var markup = \"\";\n        if (this._options.noDoubleEncoding) {\n            markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        }\n        else {\n            for (var i = 0; i < node.data.length; i++) {\n                var c = node.data[i];\n                if (c === \"&\")\n                    markup += \"&amp;\";\n                else if (c === \"<\")\n                    markup += \"&lt;\";\n                else if (c === \">\")\n                    markup += \"&gt;\";\n                else\n                    markup += c;\n            }\n        }\n        this._push(this._writer.text(markup));\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.ins = function (target, content) {\n        if (content === void 0) { content = ''; }\n        this._serializeOpenTag(true);\n        var node;\n        try {\n            node = BuilderFunctions_1.fragment(this._builderOptions).ins(target, content).first().node;\n        }\n        catch (err) {\n            /* istanbul ignore next */\n            this.emit(\"error\", err);\n            /* istanbul ignore next */\n            return this;\n        }\n        if (this._options.wellFormed && (node.target.indexOf(\":\") !== -1 || (/^xml$/i).test(node.target))) {\n            this.emit(\"error\", new Error(\"Processing instruction target contains invalid characters (well-formed required).\"));\n            return this;\n        }\n        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {\n            this.emit(\"error\", Error(\"Processing instruction data contains invalid characters (well-formed required).\"));\n            return this;\n        }\n        this._push(this._writer.instruction(node.target, node.data));\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.dat = function (content) {\n        this._serializeOpenTag(true);\n        var node;\n        try {\n            node = BuilderFunctions_1.fragment(this._builderOptions).dat(content).first().node;\n        }\n        catch (err) {\n            this.emit(\"error\", err);\n            return this;\n        }\n        this._push(this._writer.cdata(node.data));\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.dec = function (options) {\n        if (options === void 0) { options = { version: \"1.0\" }; }\n        if (this._fragment) {\n            this.emit(\"error\", Error(\"Cannot insert an XML declaration into a document fragment.\"));\n            return this;\n        }\n        if (this._hasDeclaration) {\n            this.emit(\"error\", Error(\"XML declaration is already inserted.\"));\n            return this;\n        }\n        this._push(this._writer.declaration(options.version || \"1.0\", options.encoding, options.standalone));\n        this._hasDeclaration = true;\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.dtd = function (options) {\n        if (this._fragment) {\n            this.emit(\"error\", Error(\"Cannot insert a DocType declaration into a document fragment.\"));\n            return this;\n        }\n        if (this._docTypeName !== \"\") {\n            this.emit(\"error\", new Error(\"DocType declaration is already inserted.\"));\n            return this;\n        }\n        if (this._hasDocumentElement) {\n            this.emit(\"error\", new Error(\"Cannot insert DocType declaration after document element.\"));\n            return this;\n        }\n        var node;\n        try {\n            node = BuilderFunctions_1.create().dtd(options).first().node;\n        }\n        catch (err) {\n            this.emit(\"error\", err);\n            return this;\n        }\n        if (this._options.wellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {\n            this.emit(\"error\", new Error(\"DocType public identifier does not match PubidChar construct (well-formed required).\"));\n            return this;\n        }\n        if (this._options.wellFormed &&\n            (!algorithm_1.xml_isLegalChar(node.systemId) ||\n                (node.systemId.indexOf('\"') !== -1 && node.systemId.indexOf(\"'\") !== -1))) {\n            this.emit(\"error\", new Error(\"DocType system identifier contains invalid characters (well-formed required).\"));\n            return this;\n        }\n        this._docTypeName = options.name;\n        this._push(this._writer.docType(options.name, node.publicId, node.systemId));\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.up = function () {\n        this._serializeOpenTag(false);\n        this._serializeCloseTag();\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderCBImpl.prototype.end = function () {\n        this._serializeOpenTag(false);\n        while (this._openTags.length > 0) {\n            this._serializeCloseTag();\n        }\n        this._push(null);\n        return this;\n    };\n    /**\n     * Serializes the opening tag of an element node.\n     *\n     * @param hasChildren - whether the element node has child nodes\n     */\n    XMLBuilderCBImpl.prototype._serializeOpenTag = function (hasChildren) {\n        if (this._currentElementSerialized)\n            return;\n        if (this._currentElement === undefined)\n            return;\n        var node = this._currentElement.node;\n        if (this._options.wellFormed && (node.localName.indexOf(\":\") !== -1 ||\n            !algorithm_1.xml_isName(node.localName))) {\n            this.emit(\"error\", new Error(\"Node local name contains invalid characters (well-formed required).\"));\n            return;\n        }\n        var qualifiedName = \"\";\n        var ignoreNamespaceDefinitionAttribute = false;\n        var map = this._prefixMap.copy();\n        var localPrefixesMap = {};\n        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);\n        var inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];\n        var ns = node.namespaceURI;\n        if (ns === null)\n            ns = inheritedNS;\n        if (inheritedNS === ns) {\n            if (localDefaultNamespace !== null) {\n                ignoreNamespaceDefinitionAttribute = true;\n            }\n            if (ns === infra_1.namespace.XML) {\n                qualifiedName = \"xml:\" + node.localName;\n            }\n            else {\n                qualifiedName = node.localName;\n            }\n            this._writer.beginElement(qualifiedName);\n            this._push(this._writer.openTagBegin(qualifiedName));\n        }\n        else {\n            var prefix = node.prefix;\n            var candidatePrefix = null;\n            if (prefix !== null || ns !== localDefaultNamespace) {\n                candidatePrefix = map.get(prefix, ns);\n            }\n            if (prefix === \"xmlns\") {\n                if (this._options.wellFormed) {\n                    this.emit(\"error\", new Error(\"An element cannot have the 'xmlns' prefix (well-formed required).\"));\n                    return;\n                }\n                candidatePrefix = prefix;\n            }\n            if (candidatePrefix !== null) {\n                qualifiedName = candidatePrefix + ':' + node.localName;\n                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {\n                    inheritedNS = localDefaultNamespace || null;\n                }\n                this._writer.beginElement(qualifiedName);\n                this._push(this._writer.openTagBegin(qualifiedName));\n            }\n            else if (prefix !== null) {\n                if (prefix in localPrefixesMap) {\n                    prefix = this._generatePrefix(ns, map, this._prefixIndex);\n                }\n                map.set(prefix, ns);\n                qualifiedName += prefix + ':' + node.localName;\n                this._writer.beginElement(qualifiedName);\n                this._push(this._writer.openTagBegin(qualifiedName));\n                this._push(this._writer.attribute(\"xmlns:\" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));\n                if (localDefaultNamespace !== null) {\n                    inheritedNS = localDefaultNamespace || null;\n                }\n            }\n            else if (localDefaultNamespace === null ||\n                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {\n                ignoreNamespaceDefinitionAttribute = true;\n                qualifiedName += node.localName;\n                inheritedNS = ns;\n                this._writer.beginElement(qualifiedName);\n                this._push(this._writer.openTagBegin(qualifiedName));\n                this._push(this._writer.attribute(\"xmlns\", this._serializeAttributeValue(ns, this._options.wellFormed)));\n            }\n            else {\n                qualifiedName += node.localName;\n                inheritedNS = ns;\n                this._writer.beginElement(qualifiedName);\n                this._push(this._writer.openTagBegin(qualifiedName));\n            }\n        }\n        this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);\n        var isHTML = (ns === infra_1.namespace.HTML);\n        if (isHTML && !hasChildren &&\n            XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {\n            this._push(this._writer.openTagEnd(qualifiedName, true, true));\n            this._writer.endElement(qualifiedName);\n        }\n        else if (!isHTML && !hasChildren) {\n            this._push(this._writer.openTagEnd(qualifiedName, true, false));\n            this._writer.endElement(qualifiedName);\n        }\n        else {\n            this._push(this._writer.openTagEnd(qualifiedName, false, false));\n        }\n        this._currentElementSerialized = true;\n        /**\n         * Save qualified name, original inherited ns, original prefix map, and\n         * hasChildren flag.\n         */\n        this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren]);\n        /**\n         * New values of inherited namespace and prefix map will be used while\n         * serializing child nodes. They will be returned to their original values\n         * when this node is closed using the _openTags array item we saved above.\n         */\n        if (this._isPrefixMapModified(this._prefixMap, map)) {\n            this._prefixMap = map;\n        }\n        /**\n         * Calls following this will either serialize child nodes or close this tag.\n         */\n        this._writer.level++;\n    };\n    /**\n     * Serializes the closing tag of an element node.\n     */\n    XMLBuilderCBImpl.prototype._serializeCloseTag = function () {\n        this._writer.level--;\n        var lastEle = this._openTags.pop();\n        /* istanbul ignore next */\n        if (lastEle === undefined) {\n            this.emit(\"error\", new Error(\"Last element is undefined.\"));\n            return;\n        }\n        var _a = __read(lastEle, 4), qualifiedName = _a[0], ns = _a[1], map = _a[2], hasChildren = _a[3];\n        /**\n         * Restore original values of inherited namespace and prefix map.\n         */\n        this._prefixMap = map;\n        if (!hasChildren)\n            return;\n        this._push(this._writer.closeTag(qualifiedName));\n        this._writer.endElement(qualifiedName);\n    };\n    /**\n     * Pushes data to internal buffer.\n     *\n     * @param data - data\n     */\n    XMLBuilderCBImpl.prototype._push = function (data) {\n        if (data === null) {\n            this._ended = true;\n            this.emit(\"end\");\n        }\n        else if (this._ended) {\n            this.emit(\"error\", new Error(\"Cannot push to ended stream.\"));\n        }\n        else if (data.length !== 0) {\n            this._writer.hasData = true;\n            this.emit(\"data\", data, this._writer.level);\n        }\n    };\n    /**\n     * Reads and serializes an XML tree.\n     *\n     * @param node - root node\n     */\n    XMLBuilderCBImpl.prototype._fromNode = function (node) {\n        var e_2, _a, e_3, _b;\n        if (util_2.Guard.isElementNode(node)) {\n            var name = node.prefix ? node.prefix + \":\" + node.localName : node.localName;\n            if (node.namespaceURI !== null) {\n                this.ele(node.namespaceURI, name);\n            }\n            else {\n                this.ele(name);\n            }\n            try {\n                for (var _c = __values(node.attributes), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var attr = _d.value;\n                    var name_1 = attr.prefix ? attr.prefix + \":\" + attr.localName : attr.localName;\n                    if (attr.namespaceURI !== null) {\n                        this.att(attr.namespaceURI, name_1, attr.value);\n                    }\n                    else {\n                        this.att(name_1, attr.value);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            try {\n                for (var _e = __values(node.childNodes), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var child = _f.value;\n                    this._fromNode(child);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            this.up();\n        }\n        else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {\n            this.txt(node.data);\n        }\n        else if (util_2.Guard.isCommentNode(node)) {\n            this.com(node.data);\n        }\n        else if (util_2.Guard.isCDATASectionNode(node)) {\n            this.dat(node.data);\n        }\n        else if (util_2.Guard.isProcessingInstructionNode(node)) {\n            this.ins(node.target, node.data);\n        }\n    };\n    /**\n     * Produces an XML serialization of the attributes of an element node.\n     *\n     * @param node - node to serialize\n     * @param map - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param localPrefixesMap - local prefixes map\n     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace\n     * attributes\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLBuilderCBImpl.prototype._serializeAttributes = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {\n        var e_4, _a;\n        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;\n        try {\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                // Optimize common case\n                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {\n                    this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));\n                    continue;\n                }\n                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {\n                    this.emit(\"error\", new Error(\"Element contains duplicate attributes (well-formed required).\"));\n                    return;\n                }\n                if (requireWellFormed && localNameSet)\n                    localNameSet.set(attr.namespaceURI, attr.localName);\n                var attributeNamespace = attr.namespaceURI;\n                var candidatePrefix = null;\n                if (attributeNamespace !== null) {\n                    candidatePrefix = map.get(attr.prefix, attributeNamespace);\n                    if (attributeNamespace === infra_1.namespace.XMLNS) {\n                        if (attr.value === infra_1.namespace.XML ||\n                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||\n                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||\n                                localPrefixesMap[attr.localName] !== attr.value) &&\n                                map.has(attr.localName, attr.value)))\n                            continue;\n                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {\n                            this.emit(\"error\", new Error(\"XMLNS namespace is reserved (well-formed required).\"));\n                            return;\n                        }\n                        if (requireWellFormed && attr.value === '') {\n                            this.emit(\"error\", new Error(\"Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).\"));\n                            return;\n                        }\n                        if (attr.prefix === 'xmlns')\n                            candidatePrefix = 'xmlns';\n                        /**\n                         * _Note:_ The (candidatePrefix === null) check is not in the spec.\n                         * We deviate from the spec here. Otherwise a prefix is generated for\n                         * all attributes with namespaces.\n                         */\n                    }\n                    else if (candidatePrefix === null) {\n                        if (attr.prefix !== null &&\n                            (!map.hasPrefix(attr.prefix) ||\n                                map.has(attr.prefix, attributeNamespace))) {\n                            /**\n                             * Check if we can use the attribute's own prefix.\n                             * We deviate from the spec here.\n                             * TODO: This is not an efficient way of searching for prefixes.\n                             * Follow developments to the spec.\n                             */\n                            candidatePrefix = attr.prefix;\n                        }\n                        else {\n                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);\n                        }\n                        this._push(this._writer.attribute(\"xmlns:\" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));\n                    }\n                }\n                if (requireWellFormed && (attr.localName.indexOf(\":\") !== -1 ||\n                    !algorithm_1.xml_isName(attr.localName) ||\n                    (attr.localName === \"xmlns\" && attributeNamespace === null))) {\n                    this.emit(\"error\", new Error(\"Attribute local name contains invalid characters (well-formed required).\"));\n                    return;\n                }\n                this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + \":\" : \"\") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    };\n    /**\n     * Produces an XML serialization of an attribute value.\n     *\n     * @param value - attribute value\n     * @param requireWellFormed - whether to check conformance\n     */\n    XMLBuilderCBImpl.prototype._serializeAttributeValue = function (value, requireWellFormed) {\n        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {\n            this.emit(\"error\", new Error(\"Invalid characters in attribute value.\"));\n            return \"\";\n        }\n        if (value === null)\n            return \"\";\n        if (this._options.noDoubleEncoding) {\n            return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;')\n                .replace(/\"/g, '&quot;');\n        }\n        else {\n            var result = \"\";\n            for (var i = 0; i < value.length; i++) {\n                var c = value[i];\n                if (c === \"\\\"\")\n                    result += \"&quot;\";\n                else if (c === \"&\")\n                    result += \"&amp;\";\n                else if (c === \"<\")\n                    result += \"&lt;\";\n                else if (c === \">\")\n                    result += \"&gt;\";\n                else\n                    result += c;\n            }\n            return result;\n        }\n    };\n    /**\n     * Records namespace information for the given element and returns the\n     * default namespace attribute value.\n     *\n     * @param node - element node to process\n     * @param map - namespace prefix map\n     * @param localPrefixesMap - local prefixes map\n     */\n    XMLBuilderCBImpl.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {\n        var e_5, _a;\n        var defaultNamespaceAttrValue = null;\n        try {\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                var attributeNamespace = attr.namespaceURI;\n                var attributePrefix = attr.prefix;\n                if (attributeNamespace === infra_1.namespace.XMLNS) {\n                    if (attributePrefix === null) {\n                        defaultNamespaceAttrValue = attr.value;\n                        continue;\n                    }\n                    else {\n                        var prefixDefinition = attr.localName;\n                        var namespaceDefinition = attr.value;\n                        if (namespaceDefinition === infra_1.namespace.XML) {\n                            continue;\n                        }\n                        if (namespaceDefinition === '') {\n                            namespaceDefinition = null;\n                        }\n                        if (map.has(prefixDefinition, namespaceDefinition)) {\n                            continue;\n                        }\n                        map.set(prefixDefinition, namespaceDefinition);\n                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';\n                    }\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        return defaultNamespaceAttrValue;\n    };\n    /**\n     * Generates a new prefix for the given namespace.\n     *\n     * @param newNamespace - a namespace to generate prefix for\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     */\n    XMLBuilderCBImpl.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {\n        var generatedPrefix = \"ns\" + prefixIndex.value;\n        prefixIndex.value++;\n        prefixMap.set(generatedPrefix, newNamespace);\n        return generatedPrefix;\n    };\n    /**\n     * Determines if the namespace prefix map was modified from its original.\n     *\n     * @param originalMap - original namespace prefix map\n     * @param newMap - new namespace prefix map\n     */\n    XMLBuilderCBImpl.prototype._isPrefixMapModified = function (originalMap, newMap) {\n        var items1 = originalMap._items;\n        var items2 = newMap._items;\n        var nullItems1 = originalMap._nullItems;\n        var nullItems2 = newMap._nullItems;\n        for (var key in items2) {\n            var arr1 = items1[key];\n            if (arr1 === undefined)\n                return true;\n            var arr2 = items2[key];\n            if (arr1.length !== arr2.length)\n                return true;\n            for (var i = 0; i < arr1.length; i++) {\n                if (arr1[i] !== arr2[i])\n                    return true;\n            }\n        }\n        if (nullItems1.length !== nullItems2.length)\n            return true;\n        for (var i = 0; i < nullItems1.length; i++) {\n            if (nullItems1[i] !== nullItems2[i])\n                return true;\n        }\n        return false;\n    };\n    XMLBuilderCBImpl._VoidElementNames = new Set(['area', 'base', 'basefont',\n        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',\n        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);\n    return XMLBuilderCBImpl;\n}(events_1.EventEmitter));\nexports.XMLBuilderCBImpl = XMLBuilderCBImpl;\n//# sourceMappingURL=XMLBuilderCBImpl.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"../interfaces\");\nvar util_1 = require(\"@oozcitak/util\");\nvar writers_1 = require(\"../writers\");\nvar interfaces_2 = require(\"@oozcitak/dom/lib/dom/interfaces\");\nvar util_2 = require(\"@oozcitak/dom/lib/util\");\nvar algorithm_1 = require(\"@oozcitak/dom/lib/algorithm\");\nvar dom_1 = require(\"./dom\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar readers_1 = require(\"../readers\");\n/**\n * Represents a wrapper that extends XML nodes to implement easy to use and\n * chainable document builder methods.\n */\nvar XMLBuilderImpl = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `XMLBuilderNodeImpl`.\n     *\n     * @param domNode - the DOM node to wrap\n     */\n    function XMLBuilderImpl(domNode) {\n        this._domNode = domNode;\n    }\n    Object.defineProperty(XMLBuilderImpl.prototype, \"node\", {\n        /** @inheritdoc */\n        get: function () { return this._domNode; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(XMLBuilderImpl.prototype, \"options\", {\n        /** @inheritdoc */\n        get: function () { return this._options; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.set = function (options) {\n        this._options = util_1.applyDefaults(util_1.applyDefaults(this._options, options, true), // apply user settings\n        interfaces_1.DefaultBuilderOptions); // provide defaults\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.ele = function (p1, p2, p3) {\n        var _a, _b, _c;\n        var namespace;\n        var name;\n        var attributes;\n        if (util_1.isObject(p1)) {\n            // ele(obj: ExpandObject)\n            return new readers_1.ObjectReader(this._options).parse(this, p1);\n        }\n        else if (p1 !== null && /^\\s*</.test(p1)) {\n            // parse XML document string\n            return new readers_1.XMLReader(this._options).parse(this, p1);\n        }\n        else if (p1 !== null && /^\\s*[\\{\\[]/.test(p1)) {\n            // parse JSON string\n            return new readers_1.JSONReader(this._options).parse(this, p1);\n        }\n        else if (p1 !== null && /^(\\s*|(#.*)|(%.*))*---/.test(p1)) {\n            // parse YAML string\n            return new readers_1.YAMLReader(this._options).parse(this, p1);\n        }\n        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {\n            // ele(namespace: string, name: string, attributes?: AttributesObject)\n            _a = __read([p1, p2, p3], 3), namespace = _a[0], name = _a[1], attributes = _a[2];\n        }\n        else if (p1 !== null) {\n            // ele(name: string, attributes?: AttributesObject)\n            _b = __read([undefined, p1, util_1.isObject(p2) ? p2 : undefined], 3), namespace = _b[0], name = _b[1], attributes = _b[2];\n        }\n        else {\n            throw new Error(\"Element name cannot be null. \" + this._debugInfo());\n        }\n        if (attributes) {\n            attributes = util_1.getValue(attributes);\n        }\n        _c = __read(this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true), 2), namespace = _c[0], name = _c[1];\n        // inherit namespace from parent\n        if (namespace === undefined) {\n            var _d = __read(algorithm_1.namespace_extractQName(name), 1), prefix = _d[0];\n            namespace = this.node.lookupNamespaceURI(prefix);\n        }\n        // create a child element node\n        var childNode = (namespace !== undefined && namespace !== null ?\n            this._doc.createElementNS(namespace, name) :\n            this._doc.createElement(name));\n        this.node.appendChild(childNode);\n        var builder = new XMLBuilderImpl(childNode);\n        // update doctype node if the new node is the document element node\n        var oldDocType = this._doc.doctype;\n        if (childNode === this._doc.documentElement && oldDocType !== null) {\n            var docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);\n            this._doc.replaceChild(docType, oldDocType);\n        }\n        // create attributes\n        if (attributes && !util_1.isEmpty(attributes)) {\n            builder.att(attributes);\n        }\n        return builder;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.remove = function () {\n        var parent = this.up();\n        parent.node.removeChild(this.node);\n        return parent;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.att = function (p1, p2, p3) {\n        var _a, _b, _c;\n        var _this = this;\n        if (util_1.isMap(p1) || util_1.isObject(p1)) {\n            // att(obj: AttributesObject)\n            // expand if object\n            util_1.forEachObject(p1, function (attName, attValue) { return _this.att(attName, attValue); }, this);\n            return this;\n        }\n        // get primitive values\n        if (p1 !== undefined && p1 !== null)\n            p1 = util_1.getValue(p1 + \"\");\n        if (p2 !== undefined && p2 !== null)\n            p2 = util_1.getValue(p2 + \"\");\n        if (p3 !== undefined && p3 !== null)\n            p3 = util_1.getValue(p3 + \"\");\n        var namespace;\n        var name;\n        var value;\n        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {\n            // att(namespace: string, name: string, value: string)\n            _a = __read([p1, p2, p3], 3), namespace = _a[0], name = _a[1], value = _a[2];\n        }\n        else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {\n            // ele(name: string, value: string)\n            _b = __read([undefined, p1, p2], 3), namespace = _b[0], name = _b[1], value = _b[2];\n        }\n        else {\n            throw new Error(\"Attribute name and value not specified. \" + this._debugInfo());\n        }\n        if (this._options.keepNullAttributes && (value == null)) {\n            // keep null attributes\n            value = \"\";\n        }\n        else if (value == null) {\n            // skip null|undefined attributes\n            return this;\n        }\n        if (!util_2.Guard.isElementNode(this.node)) {\n            throw new Error(\"An attribute can only be assigned to an element node.\");\n        }\n        var ele = this.node;\n        _c = __read(this._extractNamespace(namespace, name, false), 2), namespace = _c[0], name = _c[1];\n        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);\n        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);\n        value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);\n        var _d = __read(algorithm_1.namespace_extractQName(name), 2), prefix = _d[0], localName = _d[1];\n        var _e = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName), 1), elePrefix = _e[0];\n        // check if this is a namespace declaration attribute\n        // assign a new element namespace if it wasn't previously assigned\n        var eleNamespace = null;\n        if (prefix === \"xmlns\") {\n            namespace = infra_1.namespace.XMLNS;\n            if (ele.namespaceURI === null && elePrefix === localName) {\n                eleNamespace = value;\n            }\n        }\n        else if (prefix === null && localName === \"xmlns\" && elePrefix === null) {\n            namespace = infra_1.namespace.XMLNS;\n            eleNamespace = value;\n        }\n        // re-create the element node if its namespace changed\n        // we can't simply change the namespaceURI since its read-only\n        if (eleNamespace !== null) {\n            this._updateNamespace(eleNamespace);\n            ele = this.node;\n        }\n        if (namespace !== undefined) {\n            ele.setAttributeNS(namespace, name, value);\n        }\n        else {\n            ele.setAttribute(name, value);\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.removeAtt = function (p1, p2) {\n        var _this = this;\n        if (!util_2.Guard.isElementNode(this.node)) {\n            throw new Error(\"An attribute can only be removed from an element node.\");\n        }\n        // get primitive values\n        p1 = util_1.getValue(p1);\n        if (p2 !== undefined) {\n            p2 = util_1.getValue(p2);\n        }\n        var namespace;\n        var name;\n        if (p1 !== null && p2 === undefined) {\n            name = p1;\n        }\n        else if ((p1 === null || util_1.isString(p1)) && p2 !== undefined) {\n            namespace = p1;\n            name = p2;\n        }\n        else {\n            throw new Error(\"Attribute namespace must be a string. \" + this._debugInfo());\n        }\n        if (util_1.isArray(name) || util_1.isSet(name)) {\n            // removeAtt(names: string[])\n            // removeAtt(namespace: string, names: string[])\n            util_1.forEachArray(name, function (attName) {\n                return namespace === undefined ? _this.removeAtt(attName) : _this.removeAtt(namespace, attName);\n            }, this);\n        }\n        else if (namespace !== undefined) {\n            // removeAtt(namespace: string, name: string)\n            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);\n            namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);\n            this.node.removeAttributeNS(namespace, name);\n        }\n        else {\n            // removeAtt(name: string)\n            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);\n            this.node.removeAttribute(name);\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.txt = function (content) {\n        if (content === null || content === undefined) {\n            if (this._options.keepNullNodes) {\n                // keep null nodes\n                content = \"\";\n            }\n            else {\n                // skip null|undefined nodes\n                return this;\n            }\n        }\n        var child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));\n        this.node.appendChild(child);\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.com = function (content) {\n        if (content === null || content === undefined) {\n            if (this._options.keepNullNodes) {\n                // keep null nodes\n                content = \"\";\n            }\n            else {\n                // skip null|undefined nodes\n                return this;\n            }\n        }\n        var child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));\n        this.node.appendChild(child);\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.dat = function (content) {\n        if (content === null || content === undefined) {\n            if (this._options.keepNullNodes) {\n                // keep null nodes\n                content = \"\";\n            }\n            else {\n                // skip null|undefined nodes\n                return this;\n            }\n        }\n        var child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));\n        this.node.appendChild(child);\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.ins = function (target, content) {\n        var _this = this;\n        if (content === void 0) { content = ''; }\n        if (content === null || content === undefined) {\n            if (this._options.keepNullNodes) {\n                // keep null nodes\n                content = \"\";\n            }\n            else {\n                // skip null|undefined nodes\n                return this;\n            }\n        }\n        if (util_1.isArray(target) || util_1.isSet(target)) {\n            util_1.forEachArray(target, function (item) {\n                item += \"\";\n                var insIndex = item.indexOf(' ');\n                var insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));\n                var insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));\n                _this.ins(insTarget, insValue);\n            }, this);\n        }\n        else if (util_1.isMap(target) || util_1.isObject(target)) {\n            util_1.forEachObject(target, function (insTarget, insValue) { return _this.ins(insTarget, insValue); }, this);\n        }\n        else {\n            var child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));\n            this.node.appendChild(child);\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.dec = function (options) {\n        this._options.version = options.version || \"1.0\";\n        this._options.encoding = options.encoding;\n        this._options.standalone = options.standalone;\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.dtd = function (options) {\n        var name = dom_1.sanitizeInput((options && options.name) || (this._doc.documentElement ? this._doc.documentElement.tagName : \"ROOT\"), this._options.invalidCharReplacement);\n        var pubID = dom_1.sanitizeInput((options && options.pubID) || \"\", this._options.invalidCharReplacement);\n        var sysID = dom_1.sanitizeInput((options && options.sysID) || \"\", this._options.invalidCharReplacement);\n        // name must match document element\n        if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {\n            throw new Error(\"DocType name does not match document element name.\");\n        }\n        // create doctype node\n        var docType = this._doc.implementation.createDocumentType(name, pubID, sysID);\n        if (this._doc.doctype !== null) {\n            // replace existing doctype\n            this._doc.replaceChild(docType, this._doc.doctype);\n        }\n        else {\n            // insert before document element node or append to end\n            this._doc.insertBefore(docType, this._doc.documentElement);\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.import = function (node) {\n        var e_1, _a;\n        var hostNode = this._domNode;\n        var hostDoc = this._doc;\n        var importedNode = node.node;\n        if (util_2.Guard.isDocumentNode(importedNode)) {\n            // import document node\n            var elementNode = importedNode.documentElement;\n            if (elementNode === null) {\n                throw new Error(\"Imported document has no document element node. \" + this._debugInfo());\n            }\n            var clone = hostDoc.importNode(elementNode, true);\n            hostNode.appendChild(clone);\n            var _b = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _b[0];\n            var namespace = hostNode.lookupNamespaceURI(prefix);\n            new XMLBuilderImpl(clone)._updateNamespace(namespace);\n        }\n        else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {\n            try {\n                // import child nodes\n                for (var _c = __values(importedNode.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var childNode = _d.value;\n                    var clone = hostDoc.importNode(childNode, true);\n                    hostNode.appendChild(clone);\n                    if (util_2.Guard.isElementNode(clone)) {\n                        var _e = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _e[0];\n                        var namespace = hostNode.lookupNamespaceURI(prefix);\n                        new XMLBuilderImpl(clone)._updateNamespace(namespace);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        else {\n            // import node\n            var clone = hostDoc.importNode(importedNode, true);\n            hostNode.appendChild(clone);\n            if (util_2.Guard.isElementNode(clone)) {\n                var _f = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _f[0];\n                var namespace = hostNode.lookupNamespaceURI(prefix);\n                new XMLBuilderImpl(clone)._updateNamespace(namespace);\n            }\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.doc = function () {\n        if (this._doc._isFragment) {\n            var node = this.node;\n            while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {\n                node = node.parentNode;\n            }\n            /* istanbul ignore next */\n            if (node === null) {\n                throw new Error(\"Node has no parent node while searching for document fragment ancestor. \" + this._debugInfo());\n            }\n            return new XMLBuilderImpl(node);\n        }\n        else {\n            return new XMLBuilderImpl(this._doc);\n        }\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.root = function () {\n        var ele = this._doc.documentElement;\n        if (!ele) {\n            throw new Error(\"Document root element is null. \" + this._debugInfo());\n        }\n        return new XMLBuilderImpl(ele);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.up = function () {\n        var parent = this._domNode.parentNode;\n        if (!parent) {\n            throw new Error(\"Parent node is null. \" + this._debugInfo());\n        }\n        return new XMLBuilderImpl(parent);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.prev = function () {\n        var node = this._domNode.previousSibling;\n        if (!node) {\n            throw new Error(\"Previous sibling node is null. \" + this._debugInfo());\n        }\n        return new XMLBuilderImpl(node);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.next = function () {\n        var node = this._domNode.nextSibling;\n        if (!node) {\n            throw new Error(\"Next sibling node is null. \" + this._debugInfo());\n        }\n        return new XMLBuilderImpl(node);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.first = function () {\n        var node = this._domNode.firstChild;\n        if (!node) {\n            throw new Error(\"First child node is null. \" + this._debugInfo());\n        }\n        return new XMLBuilderImpl(node);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.last = function () {\n        var node = this._domNode.lastChild;\n        if (!node) {\n            throw new Error(\"Last child node is null. \" + this._debugInfo());\n        }\n        return new XMLBuilderImpl(node);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.each = function (callback, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = this._getFirstDescendantNode(this._domNode, self, recursive);\n        while (result[0]) {\n            var nextResult = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);\n            callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);\n            result = nextResult;\n        }\n        return this;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.map = function (callback, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = [];\n        this.each(function (node, index, level) {\n            return result.push(callback.call(thisArg, node, index, level));\n        }, self, recursive);\n        return result;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.reduce = function (callback, initialValue, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var value = initialValue;\n        this.each(function (node, index, level) {\n            return value = callback.call(thisArg, value, node, index, level);\n        }, self, recursive);\n        return value;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.find = function (predicate, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = this._getFirstDescendantNode(this._domNode, self, recursive);\n        while (result[0]) {\n            var builder = new XMLBuilderImpl(result[0]);\n            if (predicate.call(thisArg, builder, result[1], result[2])) {\n                return builder;\n            }\n            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);\n        }\n        return undefined;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.filter = function (predicate, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = [];\n        this.each(function (node, index, level) {\n            if (predicate.call(thisArg, node, index, level)) {\n                result.push(node);\n            }\n        }, self, recursive);\n        return result;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.every = function (predicate, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = this._getFirstDescendantNode(this._domNode, self, recursive);\n        while (result[0]) {\n            var builder = new XMLBuilderImpl(result[0]);\n            if (!predicate.call(thisArg, builder, result[1], result[2])) {\n                return false;\n            }\n            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);\n        }\n        return true;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.some = function (predicate, self, recursive, thisArg) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = this._getFirstDescendantNode(this._domNode, self, recursive);\n        while (result[0]) {\n            var builder = new XMLBuilderImpl(result[0]);\n            if (predicate.call(thisArg, builder, result[1], result[2])) {\n                return true;\n            }\n            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);\n        }\n        return false;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.toArray = function (self, recursive) {\n        if (self === void 0) { self = false; }\n        if (recursive === void 0) { recursive = false; }\n        var result = [];\n        this.each(function (node) { return result.push(node); }, self, recursive);\n        return result;\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.toString = function (writerOptions) {\n        writerOptions = writerOptions || {};\n        if (writerOptions.format === undefined) {\n            writerOptions.format = \"xml\";\n        }\n        return this._serialize(writerOptions);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.toObject = function (writerOptions) {\n        writerOptions = writerOptions || {};\n        if (writerOptions.format === undefined) {\n            writerOptions.format = \"object\";\n        }\n        return this._serialize(writerOptions);\n    };\n    /** @inheritdoc */\n    XMLBuilderImpl.prototype.end = function (writerOptions) {\n        writerOptions = writerOptions || {};\n        if (writerOptions.format === undefined) {\n            writerOptions.format = \"xml\";\n        }\n        return this.doc()._serialize(writerOptions);\n    };\n    /**\n     * Gets the next descendant of the given node of the tree rooted at `root`\n     * in depth-first pre-order. Returns a three-tuple with\n     * [descendant, descendant_index, descendant_level].\n     *\n     * @param root - root node of the tree\n     * @param self - whether to visit the current node along with child nodes\n     * @param recursive - whether to visit all descendant nodes in tree-order or\n     * only the immediate child nodes\n     */\n    XMLBuilderImpl.prototype._getFirstDescendantNode = function (root, self, recursive) {\n        if (self)\n            return [this._domNode, 0, 0];\n        else if (recursive)\n            return this._getNextDescendantNode(root, root, recursive, 0, 0);\n        else\n            return [this._domNode.firstChild, 0, 1];\n    };\n    /**\n     * Gets the next descendant of the given node of the tree rooted at `root`\n     * in depth-first pre-order. Returns a three-tuple with\n     * [descendant, descendant_index, descendant_level].\n     *\n     * @param root - root node of the tree\n     * @param node - current node\n     * @param recursive - whether to visit all descendant nodes in tree-order or\n     * only the immediate child nodes\n     * @param index - child node index\n     * @param level - current depth of the XML tree\n     */\n    XMLBuilderImpl.prototype._getNextDescendantNode = function (root, node, recursive, index, level) {\n        if (recursive) {\n            // traverse child nodes\n            if (node.firstChild)\n                return [node.firstChild, 0, level + 1];\n            if (node === root)\n                return [null, -1, -1];\n            // traverse siblings\n            if (node.nextSibling)\n                return [node.nextSibling, index + 1, level];\n            // traverse parent's next sibling\n            var parent = node.parentNode;\n            while (parent && parent !== root) {\n                if (parent.nextSibling)\n                    return [parent.nextSibling, algorithm_1.tree_index(parent.nextSibling), level - 1];\n                parent = parent.parentNode;\n                level--;\n            }\n        }\n        else {\n            if (root === node)\n                return [node.firstChild, 0, level + 1];\n            else\n                return [node.nextSibling, index + 1, level];\n        }\n        return [null, -1, -1];\n    };\n    /**\n     * Converts the node into its string or object representation.\n     *\n     * @param options - serialization options\n     */\n    XMLBuilderImpl.prototype._serialize = function (writerOptions) {\n        if (writerOptions.format === \"xml\") {\n            var writer = new writers_1.XMLWriter(this._options, writerOptions);\n            return writer.serialize(this.node);\n        }\n        else if (writerOptions.format === \"map\") {\n            var writer = new writers_1.MapWriter(this._options, writerOptions);\n            return writer.serialize(this.node);\n        }\n        else if (writerOptions.format === \"object\") {\n            var writer = new writers_1.ObjectWriter(this._options, writerOptions);\n            return writer.serialize(this.node);\n        }\n        else if (writerOptions.format === \"json\") {\n            var writer = new writers_1.JSONWriter(this._options, writerOptions);\n            return writer.serialize(this.node);\n        }\n        else if (writerOptions.format === \"yaml\") {\n            var writer = new writers_1.YAMLWriter(this._options, writerOptions);\n            return writer.serialize(this.node);\n        }\n        else {\n            throw new Error(\"Invalid writer format: \" + writerOptions.format + \". \" + this._debugInfo());\n        }\n    };\n    /**\n     * Extracts a namespace and name from the given string.\n     *\n     * @param namespace - namespace\n     * @param name - a string containing both a name and namespace separated by an\n     * `'@'` character\n     * @param ele - `true` if this is an element namespace; otherwise `false`\n     */\n    XMLBuilderImpl.prototype._extractNamespace = function (namespace, name, ele) {\n        // extract from name\n        var atIndex = name.indexOf(\"@\");\n        if (atIndex > 0) {\n            if (namespace === undefined)\n                namespace = name.slice(atIndex + 1);\n            name = name.slice(0, atIndex);\n        }\n        if (namespace === undefined) {\n            // look-up default namespace\n            namespace = (ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att);\n        }\n        else if (namespace !== null && namespace[0] === \"@\") {\n            // look-up namespace aliases\n            var alias = namespace.slice(1);\n            namespace = this._options.namespaceAlias[alias];\n            if (namespace === undefined) {\n                throw new Error(\"Namespace alias `\" + alias + \"` is not defined. \" + this._debugInfo());\n            }\n        }\n        return [namespace, name];\n    };\n    /**\n     * Updates the element's namespace.\n     *\n     * @param ns - new namespace\n     */\n    XMLBuilderImpl.prototype._updateNamespace = function (ns) {\n        var e_2, _a, e_3, _b;\n        var ele = this._domNode;\n        if (util_2.Guard.isElementNode(ele) && ns !== null && ele.namespaceURI !== ns) {\n            var _c = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName), 2), elePrefix = _c[0], eleLocalName = _c[1];\n            // re-create the element node if its namespace changed\n            // we can't simply change the namespaceURI since its read-only\n            var newEle = algorithm_1.create_element(this._doc, eleLocalName, ns, elePrefix);\n            try {\n                for (var _d = __values(ele.attributes), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var attr = _e.value;\n                    var attrQName = attr.prefix ? attr.prefix + ':' + attr.localName : attr.localName;\n                    var _f = __read(algorithm_1.namespace_extractQName(attrQName), 1), attrPrefix = _f[0];\n                    var newAttrNS = attr.namespaceURI;\n                    if (newAttrNS === null && attrPrefix !== null) {\n                        newAttrNS = ele.lookupNamespaceURI(attrPrefix);\n                    }\n                    if (newAttrNS === null) {\n                        newEle.setAttribute(attrQName, attr.value);\n                    }\n                    else {\n                        newEle.setAttributeNS(newAttrNS, attrQName, attr.value);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            // replace the new node in parent node\n            var parent = ele.parentNode;\n            /* istanbul ignore next */\n            if (parent === null) {\n                throw new Error(\"Parent node is null.\" + this._debugInfo());\n            }\n            parent.replaceChild(newEle, ele);\n            this._domNode = newEle;\n            try {\n                // check child nodes\n                for (var _g = __values(ele.childNodes), _h = _g.next(); !_h.done; _h = _g.next()) {\n                    var childNode = _h.value;\n                    var newChildNode = childNode.cloneNode(true);\n                    newEle.appendChild(newChildNode);\n                    if (util_2.Guard.isElementNode(newChildNode)) {\n                        var _j = __read(algorithm_1.namespace_extractQName(newChildNode.prefix ? newChildNode.prefix + ':' + newChildNode.localName : newChildNode.localName), 1), newChildNodePrefix = _j[0];\n                        var newChildNodeNS = newEle.lookupNamespaceURI(newChildNodePrefix);\n                        new XMLBuilderImpl(newChildNode)._updateNamespace(newChildNodeNS);\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n    };\n    Object.defineProperty(XMLBuilderImpl.prototype, \"_doc\", {\n        /**\n         * Returns the document owning this node.\n         */\n        get: function () {\n            var node = this.node;\n            if (util_2.Guard.isDocumentNode(node)) {\n                return node;\n            }\n            else {\n                var docNode = node.ownerDocument;\n                /* istanbul ignore next */\n                if (!docNode)\n                    throw new Error(\"Owner document is null. \" + this._debugInfo());\n                return docNode;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns debug information for this node.\n     *\n     * @param name - node name\n     */\n    XMLBuilderImpl.prototype._debugInfo = function (name) {\n        var node = this.node;\n        var parentNode = node.parentNode;\n        name = name || node.nodeName;\n        var parentName = parentNode ? parentNode.nodeName : '';\n        if (!parentName) {\n            return \"node: <\" + name + \">\";\n        }\n        else {\n            return \"node: <\" + name + \">, parent: <\" + parentName + \">\";\n        }\n    };\n    Object.defineProperty(XMLBuilderImpl.prototype, \"_options\", {\n        /**\n         * Gets or sets builder options.\n         */\n        get: function () {\n            var doc = this._doc;\n            /* istanbul ignore next */\n            if (doc._xmlBuilderOptions === undefined) {\n                throw new Error(\"Builder options is not set.\");\n            }\n            return doc._xmlBuilderOptions;\n        },\n        set: function (value) {\n            var doc = this._doc;\n            doc._xmlBuilderOptions = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return XMLBuilderImpl;\n}());\nexports.XMLBuilderImpl = XMLBuilderImpl;\n//# sourceMappingURL=XMLBuilderImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dom_1 = require(\"@oozcitak/dom\");\nvar dom_2 = require(\"@oozcitak/dom/lib/dom\");\nvar util_1 = require(\"@oozcitak/util\");\ndom_2.dom.setFeatures(false);\n/**\n * Creates an XML document without any child nodes.\n */\nfunction createDocument() {\n    var impl = new dom_1.DOMImplementation();\n    var doc = impl.createDocument(null, 'root', null);\n    /* istanbul ignore else */\n    if (doc.documentElement) {\n        doc.removeChild(doc.documentElement);\n    }\n    return doc;\n}\nexports.createDocument = createDocument;\n/**\n * Sanitizes input strings with user supplied replacement characters.\n *\n * @param str - input string\n * @param replacement - replacement character or function\n */\nfunction sanitizeInput(str, replacement) {\n    if (str == null) {\n        return str;\n    }\n    else if (replacement === undefined) {\n        return str + \"\";\n    }\n    else {\n        var result = \"\";\n        str = str + \"\";\n        for (var i = 0; i < str.length; i++) {\n            var n = str.charCodeAt(i);\n            // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n            if (n === 0x9 || n === 0xA || n === 0xD ||\n                (n >= 0x20 && n <= 0xD7FF) ||\n                (n >= 0xE000 && n <= 0xFFFD)) {\n                // valid character - not surrogate pair\n                result += str.charAt(i);\n            }\n            else if (n >= 0xD800 && n <= 0xDBFF && i < str.length - 1) {\n                var n2 = str.charCodeAt(i + 1);\n                if (n2 >= 0xDC00 && n2 <= 0xDFFF) {\n                    // valid surrogate pair\n                    n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;\n                    result += String.fromCodePoint(n);\n                    i++;\n                }\n                else {\n                    // invalid lone surrogate\n                    result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);\n                }\n            }\n            else {\n                // invalid character\n                result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);\n            }\n        }\n        return result;\n    }\n}\nexports.sanitizeInput = sanitizeInput;\n//# sourceMappingURL=dom.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar XMLBuilderImpl_1 = require(\"./XMLBuilderImpl\");\nexports.XMLBuilderImpl = XMLBuilderImpl_1.XMLBuilderImpl;\nvar XMLBuilderCBImpl_1 = require(\"./XMLBuilderCBImpl\");\nexports.XMLBuilderCBImpl = XMLBuilderCBImpl_1.XMLBuilderCBImpl;\nvar BuilderFunctions_1 = require(\"./BuilderFunctions\");\nexports.builder = BuilderFunctions_1.builder;\nexports.create = BuilderFunctions_1.create;\nexports.fragment = BuilderFunctions_1.fragment;\nexports.convert = BuilderFunctions_1.convert;\nvar BuilderFunctionsCB_1 = require(\"./BuilderFunctionsCB\");\nexports.createCB = BuilderFunctionsCB_1.createCB;\nexports.fragmentCB = BuilderFunctionsCB_1.fragmentCB;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar builder_1 = require(\"./builder\");\nexports.builder = builder_1.builder;\nexports.create = builder_1.create;\nexports.fragment = builder_1.fragment;\nexports.convert = builder_1.convert;\nexports.createCB = builder_1.createCB;\nexports.fragmentCB = builder_1.fragmentCB;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines default values for builder options.\n */\nexports.DefaultBuilderOptions = {\n    version: \"1.0\",\n    encoding: undefined,\n    standalone: undefined,\n    keepNullNodes: false,\n    keepNullAttributes: false,\n    ignoreConverters: false,\n    convert: {\n        att: \"@\",\n        ins: \"?\",\n        text: \"#\",\n        cdata: \"$\",\n        comment: \"!\"\n    },\n    defaultNamespace: {\n        ele: undefined,\n        att: undefined\n    },\n    namespaceAlias: {\n        html: \"http://www.w3.org/1999/xhtml\",\n        xml: \"http://www.w3.org/XML/1998/namespace\",\n        xmlns: \"http://www.w3.org/2000/xmlns/\",\n        mathml: \"http://www.w3.org/1998/Math/MathML\",\n        svg: \"http://www.w3.org/2000/svg\",\n        xlink: \"http://www.w3.org/1999/xlink\"\n    },\n    invalidCharReplacement: undefined,\n    parser: undefined\n};\n/**\n * Contains keys of `XMLBuilderOptions`.\n */\nexports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));\n/**\n * Defines default values for builder options.\n */\nexports.DefaultXMLBuilderCBOptions = {\n    format: \"xml\",\n    wellFormed: false,\n    prettyPrint: false,\n    indent: \"  \",\n    newline: \"\\n\",\n    offset: 0,\n    width: 0,\n    allowEmptyTags: false,\n    spaceBeforeSlash: false,\n    keepNullNodes: false,\n    keepNullAttributes: false,\n    ignoreConverters: false,\n    convert: {\n        att: \"@\",\n        ins: \"?\",\n        text: \"#\",\n        cdata: \"$\",\n        comment: \"!\"\n    },\n    defaultNamespace: {\n        ele: undefined,\n        att: undefined\n    },\n    namespaceAlias: {\n        html: \"http://www.w3.org/1999/xhtml\",\n        xml: \"http://www.w3.org/XML/1998/namespace\",\n        xmlns: \"http://www.w3.org/2000/xmlns/\",\n        mathml: \"http://www.w3.org/1998/Math/MathML\",\n        svg: \"http://www.w3.org/2000/svg\",\n        xlink: \"http://www.w3.org/1999/xlink\"\n    }\n};\n//# sourceMappingURL=interfaces.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dom_1 = require(\"../builder/dom\");\n/**\n * Pre-serializes XML nodes.\n */\nvar BaseReader = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `BaseReader`.\n     *\n     * @param builderOptions - XML builder options\n     */\n    function BaseReader(builderOptions) {\n        this._builderOptions = builderOptions;\n        if (builderOptions.parser) {\n            Object.assign(this, builderOptions.parser);\n        }\n    }\n    BaseReader.prototype._docType = function (parent, name, publicId, systemId) {\n        return parent.dtd({ name: name, pubID: publicId, sysID: systemId });\n    };\n    BaseReader.prototype._comment = function (parent, data) {\n        return parent.com(data);\n    };\n    BaseReader.prototype._text = function (parent, data) {\n        return parent.txt(data);\n    };\n    BaseReader.prototype._instruction = function (parent, target, data) {\n        return parent.ins(target, data);\n    };\n    BaseReader.prototype._cdata = function (parent, data) {\n        return parent.dat(data);\n    };\n    BaseReader.prototype._element = function (parent, namespace, name) {\n        return (namespace === undefined ? parent.ele(name) : parent.ele(namespace, name));\n    };\n    BaseReader.prototype._attribute = function (parent, namespace, name, value) {\n        return (namespace === undefined ? parent.att(name, value) : parent.att(namespace, name, value));\n    };\n    BaseReader.prototype._sanitize = function (str) {\n        return dom_1.sanitizeInput(str, this._builderOptions.invalidCharReplacement);\n    };\n    /**\n     * Main parser function which parses the given object and returns an XMLBuilder.\n     *\n     * @param node - node to recieve parsed content\n     * @param obj - object to parse\n     */\n    BaseReader.prototype.parse = function (node, obj) {\n        return this._parse(node, obj);\n    };\n    /**\n     * Creates a DocType node.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param name - node name\n     * @param publicId - public identifier\n     * @param systemId - system identifier\n     */\n    BaseReader.prototype.docType = function (parent, name, publicId, systemId) {\n        return this._docType(parent, name, publicId, systemId);\n    };\n    /**\n     * Creates a comment node.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param parent - parent node\n     * @param data - node data\n     */\n    BaseReader.prototype.comment = function (parent, data) {\n        return this._comment(parent, data);\n    };\n    /**\n     * Creates a text node.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param parent - parent node\n     * @param data - node data\n     */\n    BaseReader.prototype.text = function (parent, data) {\n        return this._text(parent, data);\n    };\n    /**\n     * Creates a processing instruction node.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param parent - parent node\n     * @param target - instruction target\n     * @param data - node data\n     */\n    BaseReader.prototype.instruction = function (parent, target, data) {\n        return this._instruction(parent, target, data);\n    };\n    /**\n     * Creates a CData section node.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param parent - parent node\n     * @param data - node data\n     */\n    BaseReader.prototype.cdata = function (parent, data) {\n        return this._cdata(parent, data);\n    };\n    /**\n     * Creates an element node.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param parent - parent node\n     * @param namespace - node namespace\n     * @param name - node name\n     */\n    BaseReader.prototype.element = function (parent, namespace, name) {\n        return this._element(parent, namespace, name);\n    };\n    /**\n     * Creates an attribute or namespace declaration.\n     * The node will be skipped if the function returns `undefined`.\n     *\n     * @param parent - parent node\n     * @param namespace - node namespace\n     * @param name - node name\n     * @param value - node value\n     */\n    BaseReader.prototype.attribute = function (parent, namespace, name, value) {\n        return this._attribute(parent, namespace, name, value);\n    };\n    /**\n     * Sanitizes input strings.\n     *\n     * @param str - input string\n     */\n    BaseReader.prototype.sanitize = function (str) {\n        return this._sanitize(str);\n    };\n    return BaseReader;\n}());\nexports.BaseReader = BaseReader;\n//# sourceMappingURL=BaseReader.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ObjectReader_1 = require(\"./ObjectReader\");\nvar BaseReader_1 = require(\"./BaseReader\");\n/**\n * Parses XML nodes from a JSON string.\n */\nvar JSONReader = /** @class */ (function (_super) {\n    __extends(JSONReader, _super);\n    function JSONReader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Parses the given document representation.\n     *\n     * @param node - node receive parsed XML nodes\n     * @param str - JSON string to parse\n     */\n    JSONReader.prototype._parse = function (node, str) {\n        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, JSON.parse(str));\n    };\n    return JSONReader;\n}(BaseReader_1.BaseReader));\nexports.JSONReader = JSONReader;\n//# sourceMappingURL=JSONReader.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar BaseReader_1 = require(\"./BaseReader\");\n/**\n * Parses XML nodes from objects and arrays.\n * ES6 maps and sets are also supoorted.\n */\nvar ObjectReader = /** @class */ (function (_super) {\n    __extends(ObjectReader, _super);\n    function ObjectReader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Parses the given document representation.\n     *\n     * @param node - node receive parsed XML nodes\n     * @param obj - object to parse\n     */\n    ObjectReader.prototype._parse = function (node, obj) {\n        var _this = this;\n        var options = this._builderOptions;\n        var lastChild = null;\n        if (util_1.isFunction(obj)) {\n            // evaluate if function\n            lastChild = this.parse(node, obj.apply(this));\n        }\n        else if (util_1.isArray(obj) || util_1.isSet(obj)) {\n            util_1.forEachArray(obj, function (item) { return lastChild = _this.parse(node, item); }, this);\n        }\n        else /* if (isMap(obj) || isObject(obj)) */ {\n            // expand if object\n            util_1.forEachObject(obj, function (key, val) {\n                if (util_1.isFunction(val)) {\n                    // evaluate if function\n                    val = val.apply(_this);\n                }\n                if (!options.ignoreConverters && key.indexOf(options.convert.att) === 0) {\n                    // assign attributes\n                    if (key === options.convert.att) {\n                        if (util_1.isArray(val) || util_1.isSet(val)) {\n                            throw new Error(\"Invalid attribute: \" + val.toString() + \". \" + node._debugInfo());\n                        }\n                        else /* if (isMap(val) || isObject(val)) */ {\n                            util_1.forEachObject(val, function (attrKey, attrVal) {\n                                lastChild = _this.attribute(node, undefined, _this.sanitize(attrKey), _this.sanitize(attrVal)) || lastChild;\n                            });\n                        }\n                    }\n                    else {\n                        lastChild = _this.attribute(node, undefined, _this.sanitize(key.substr(options.convert.att.length)), _this.sanitize(val)) || lastChild;\n                    }\n                }\n                else if (!options.ignoreConverters && key.indexOf(options.convert.text) === 0) {\n                    // text node\n                    if (util_1.isMap(val) || util_1.isObject(val)) {\n                        // if the key is #text expand child nodes under this node to support mixed content\n                        lastChild = _this.parse(node, val);\n                    }\n                    else {\n                        lastChild = _this.text(node, _this.sanitize(val)) || lastChild;\n                    }\n                }\n                else if (!options.ignoreConverters && key.indexOf(options.convert.cdata) === 0) {\n                    // cdata node\n                    if (util_1.isArray(val) || util_1.isSet(val)) {\n                        util_1.forEachArray(val, function (item) { return lastChild = _this.cdata(node, _this.sanitize(item)) || lastChild; }, _this);\n                    }\n                    else {\n                        lastChild = _this.cdata(node, _this.sanitize(val)) || lastChild;\n                    }\n                }\n                else if (!options.ignoreConverters && key.indexOf(options.convert.comment) === 0) {\n                    // comment node\n                    if (util_1.isArray(val) || util_1.isSet(val)) {\n                        util_1.forEachArray(val, function (item) { return lastChild = _this.comment(node, _this.sanitize(item)) || lastChild; }, _this);\n                    }\n                    else {\n                        lastChild = _this.comment(node, _this.sanitize(val)) || lastChild;\n                    }\n                }\n                else if (!options.ignoreConverters && key.indexOf(options.convert.ins) === 0) {\n                    // processing instruction\n                    if (util_1.isString(val)) {\n                        var insIndex = val.indexOf(' ');\n                        var insTarget = (insIndex === -1 ? val : val.substr(0, insIndex));\n                        var insValue = (insIndex === -1 ? '' : val.substr(insIndex + 1));\n                        lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;\n                    }\n                    else if (util_1.isArray(val) || util_1.isSet(val)) {\n                        util_1.forEachArray(val, function (item) {\n                            var insIndex = item.indexOf(' ');\n                            var insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));\n                            var insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));\n                            lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;\n                        }, _this);\n                    }\n                    else /* if (isMap(target) || isObject(target)) */ {\n                        util_1.forEachObject(val, function (insTarget, insValue) { return lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild; }, _this);\n                    }\n                }\n                else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {\n                    // skip empty arrays\n                }\n                else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {\n                    // empty objects produce one node\n                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;\n                }\n                else if (!options.keepNullNodes && (val == null)) {\n                    // skip null and undefined nodes\n                }\n                else if (util_1.isArray(val) || util_1.isSet(val)) {\n                    // expand list by creating child nodes\n                    util_1.forEachArray(val, function (item) {\n                        var childNode = {};\n                        childNode[key] = item;\n                        lastChild = _this.parse(node, childNode);\n                    }, _this);\n                }\n                else if (util_1.isMap(val) || util_1.isObject(val)) {\n                    // create a parent node\n                    var parent = _this.element(node, undefined, _this.sanitize(key));\n                    if (parent) {\n                        lastChild = parent;\n                        // expand child nodes under parent\n                        _this.parse(parent, val);\n                    }\n                }\n                else if (val != null && val !== '') {\n                    // leaf element node with a single text node\n                    var parent = _this.element(node, undefined, _this.sanitize(key));\n                    if (parent) {\n                        lastChild = parent;\n                        _this.text(parent, _this.sanitize(val));\n                    }\n                }\n                else {\n                    // leaf element node\n                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;\n                }\n            }, this);\n        }\n        return lastChild || node;\n    };\n    return ObjectReader;\n}(BaseReader_1.BaseReader));\nexports.ObjectReader = ObjectReader;\n//# sourceMappingURL=ObjectReader.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar XMLStringLexer_1 = require(\"@oozcitak/dom/lib/parser/XMLStringLexer\");\nvar interfaces_1 = require(\"@oozcitak/dom/lib/parser/interfaces\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"@oozcitak/dom/lib/algorithm\");\nvar BaseReader_1 = require(\"./BaseReader\");\n/**\n * Parses XML nodes from an XML document string.\n */\nvar XMLReader = /** @class */ (function (_super) {\n    __extends(XMLReader, _super);\n    function XMLReader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Parses the given document representation.\n     *\n     * @param node - node receive parsed XML nodes\n     * @param str - XML document string to parse\n     */\n    XMLReader.prototype._parse = function (node, str) {\n        var e_1, _a, e_2, _b;\n        var lexer = new XMLStringLexer_1.XMLStringLexer(str, { skipWhitespaceOnlyText: true });\n        var context = node;\n        var token = lexer.nextToken();\n        while (token.type !== interfaces_1.TokenType.EOF) {\n            switch (token.type) {\n                case interfaces_1.TokenType.Declaration:\n                    var declaration = token;\n                    var version = this.sanitize(declaration.version);\n                    if (version !== \"1.0\") {\n                        throw new Error(\"Invalid xml version: \" + version);\n                    }\n                    var builderOptions = {\n                        version: version\n                    };\n                    if (declaration.encoding) {\n                        builderOptions.encoding = this.sanitize(declaration.encoding);\n                    }\n                    if (declaration.standalone) {\n                        builderOptions.standalone = (this.sanitize(declaration.standalone) === \"yes\");\n                    }\n                    context.set(builderOptions);\n                    break;\n                case interfaces_1.TokenType.DocType:\n                    var doctype = token;\n                    context = this.docType(context, this.sanitize(doctype.name), this.sanitize(doctype.pubId), this.sanitize(doctype.sysId)) || context;\n                    break;\n                case interfaces_1.TokenType.CDATA:\n                    var cdata = token;\n                    context = this.cdata(context, this.sanitize(cdata.data)) || context;\n                    break;\n                case interfaces_1.TokenType.Comment:\n                    var comment = token;\n                    context = this.comment(context, this.sanitize(comment.data)) || context;\n                    break;\n                case interfaces_1.TokenType.PI:\n                    var pi = token;\n                    context = this.instruction(context, this.sanitize(pi.target), this.sanitize(pi.data)) || context;\n                    break;\n                case interfaces_1.TokenType.Text:\n                    var text = token;\n                    context = this.text(context, this.sanitize(text.data)) || context;\n                    break;\n                case interfaces_1.TokenType.Element:\n                    var element = token;\n                    var elementName = this.sanitize(element.name);\n                    // inherit namespace from parent\n                    var _c = __read(algorithm_1.namespace_extractQName(elementName), 1), prefix = _c[0];\n                    var namespace = context.node.lookupNamespaceURI(prefix);\n                    // override namespace if there is a namespace declaration\n                    // attribute\n                    // also lookup namespace declaration attributes\n                    var nsDeclarations = {};\n                    try {\n                        for (var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];\n                            attName = this.sanitize(attName);\n                            attValue = this.sanitize(attValue);\n                            if (attName === \"xmlns\") {\n                                namespace = attValue;\n                            }\n                            else {\n                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];\n                                if (attPrefix === \"xmlns\") {\n                                    if (attLocalName === prefix) {\n                                        namespace = attValue;\n                                    }\n                                    nsDeclarations[attLocalName] = attValue;\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    // create the DOM element node\n                    var elementNode = (namespace !== null ?\n                        this.element(context, namespace, elementName) :\n                        this.element(context, undefined, elementName));\n                    if (elementNode === undefined)\n                        break;\n                    try {\n                        // assign attributes\n                        for (var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];\n                            attName = this.sanitize(attName);\n                            attValue = this.sanitize(attValue);\n                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];\n                            var attNamespace = null;\n                            if (attPrefix === \"xmlns\" || (attPrefix === null && attLocalName === \"xmlns\")) {\n                                // namespace declaration attribute\n                                attNamespace = infra_1.namespace.XMLNS;\n                            }\n                            else {\n                                attNamespace = elementNode.node.lookupNamespaceURI(attPrefix);\n                                if (attNamespace !== null && elementNode.node.isDefaultNamespace(attNamespace)) {\n                                    attNamespace = null;\n                                }\n                                else if (attNamespace === null && attPrefix !== null) {\n                                    attNamespace = nsDeclarations[attPrefix] || null;\n                                }\n                            }\n                            if (attNamespace !== null)\n                                this.attribute(elementNode, attNamespace, attName, attValue);\n                            else\n                                this.attribute(elementNode, undefined, attName, attValue);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    if (!element.selfClosing) {\n                        context = elementNode;\n                    }\n                    break;\n                case interfaces_1.TokenType.ClosingTag:\n                    /* istanbul ignore else */\n                    if (context.node.parentNode) {\n                        context = context.up();\n                    }\n                    break;\n            }\n            token = lexer.nextToken();\n        }\n        return context;\n    };\n    return XMLReader;\n}(BaseReader_1.BaseReader));\nexports.XMLReader = XMLReader;\n//# sourceMappingURL=XMLReader.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ObjectReader_1 = require(\"./ObjectReader\");\nvar BaseReader_1 = require(\"./BaseReader\");\nvar js_yaml_1 = require(\"js-yaml\");\n/**\n * Parses XML nodes from a YAML string.\n */\nvar YAMLReader = /** @class */ (function (_super) {\n    __extends(YAMLReader, _super);\n    function YAMLReader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Parses the given document representation.\n     *\n     * @param node - node receive parsed XML nodes\n     * @param str - YAML string to parse\n     */\n    YAMLReader.prototype._parse = function (node, str) {\n        var result = js_yaml_1.safeLoad(str);\n        /* istanbul ignore next */\n        if (result === undefined) {\n            throw new Error(\"Unable to parse YAML document.\");\n        }\n        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, result);\n    };\n    return YAMLReader;\n}(BaseReader_1.BaseReader));\nexports.YAMLReader = YAMLReader;\n//# sourceMappingURL=YAMLReader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar XMLReader_1 = require(\"./XMLReader\");\nexports.XMLReader = XMLReader_1.XMLReader;\nvar ObjectReader_1 = require(\"./ObjectReader\");\nexports.ObjectReader = ObjectReader_1.ObjectReader;\nvar JSONReader_1 = require(\"./JSONReader\");\nexports.JSONReader = JSONReader_1.JSONReader;\nvar YAMLReader_1 = require(\"./YAMLReader\");\nexports.YAMLReader = YAMLReader_1.YAMLReader;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Pre-serializes XML nodes.\n */\nvar BaseCBWriter = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `BaseCBWriter`.\n     *\n     * @param builderOptions - XML builder options\n     */\n    function BaseCBWriter(builderOptions) {\n        /**\n         * Gets the current depth of the XML tree.\n         */\n        this.level = 0;\n        this._builderOptions = builderOptions;\n        this._writerOptions = builderOptions;\n    }\n    return BaseCBWriter;\n}());\nexports.BaseCBWriter = BaseCBWriter;\n//# sourceMappingURL=BaseCBWriter.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interfaces_1 = require(\"@oozcitak/dom/lib/dom/interfaces\");\nvar LocalNameSet_1 = require(\"@oozcitak/dom/lib/serializer/LocalNameSet\");\nvar NamespacePrefixMap_1 = require(\"@oozcitak/dom/lib/serializer/NamespacePrefixMap\");\nvar infra_1 = require(\"@oozcitak/infra\");\nvar algorithm_1 = require(\"@oozcitak/dom/lib/algorithm\");\n/**\n * Pre-serializes XML nodes.\n */\nvar BaseWriter = /** @class */ (function () {\n    /**\n     * Initializes a new instance of `BaseWriter`.\n     *\n     * @param builderOptions - XML builder options\n     */\n    function BaseWriter(builderOptions) {\n        /**\n         * Gets the current depth of the XML tree.\n         */\n        this.level = 0;\n        this._builderOptions = builderOptions;\n    }\n    /**\n     * Used by derived classes to serialize the XML declaration.\n     *\n     * @param version - a version number string\n     * @param encoding - encoding declaration\n     * @param standalone - standalone document declaration\n     */\n    BaseWriter.prototype.declaration = function (version, encoding, standalone) { };\n    /**\n     * Used by derived classes to serialize a DocType node.\n     *\n     * @param name - node name\n     * @param publicId - public identifier\n     * @param systemId - system identifier\n     */\n    BaseWriter.prototype.docType = function (name, publicId, systemId) { };\n    /**\n     * Used by derived classes to serialize a comment node.\n     *\n     * @param data - node data\n     */\n    BaseWriter.prototype.comment = function (data) { };\n    /**\n     * Used by derived classes to serialize a text node.\n     *\n     * @param data - node data\n     */\n    BaseWriter.prototype.text = function (data) { };\n    /**\n     * Used by derived classes to serialize a processing instruction node.\n     *\n     * @param target - instruction target\n     * @param data - node data\n     */\n    BaseWriter.prototype.instruction = function (target, data) { };\n    /**\n     * Used by derived classes to serialize a CData section node.\n     *\n     * @param data - node data\n     */\n    BaseWriter.prototype.cdata = function (data) { };\n    /**\n     * Used by derived classes to serialize the beginning of the opening tag of an\n     * element node.\n     *\n     * @param name - node name\n     */\n    BaseWriter.prototype.openTagBegin = function (name) { };\n    /**\n     * Used by derived classes to serialize the ending of the opening tag of an\n     * element node.\n     *\n     * @param name - node name\n     * @param selfClosing - whether the element node is self closing\n     * @param voidElement - whether the element node is a HTML void element\n     */\n    BaseWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) { };\n    /**\n     * Used by derived classes to serialize the closing tag of an element node.\n     *\n     * @param name - node name\n     */\n    BaseWriter.prototype.closeTag = function (name) { };\n    /**\n     * Used by derived classes to serialize attributes or namespace declarations.\n     *\n     * @param attributes - attribute array\n     */\n    BaseWriter.prototype.attributes = function (attributes) {\n        var e_1, _a;\n        try {\n            for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\n                var attr = attributes_1_1.value;\n                this.attribute(attr[1] === null ? attr[2] : attr[1] + ':' + attr[2], attr[3]);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Used by derived classes to serialize an attribute or namespace declaration.\n     *\n     * @param name - node name\n     * @param value - node value\n     */\n    BaseWriter.prototype.attribute = function (name, value) { };\n    /**\n     * Used by derived classes to perform any pre-processing steps before starting\n     * serializing an element node.\n     *\n     * @param name - node name\n     */\n    BaseWriter.prototype.beginElement = function (name) { };\n    /**\n     * Used by derived classes to perform any post-processing steps after\n     * completing serializing an element node.\n     *\n     * @param name - node name\n     */\n    BaseWriter.prototype.endElement = function (name) { };\n    /**\n     * Produces an XML serialization of the given node. The pre-serializer inserts\n     * namespace declarations where necessary and produces qualified names for\n     * nodes and attributes.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype.serializeNode = function (node, requireWellFormed, noDoubleEncoding) {\n        var hasNamespaces = (node._nodeDocument !== undefined && node._nodeDocument._hasNamespaces);\n        this.level = 0;\n        this.currentNode = node;\n        if (hasNamespaces) {\n            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization\n             *\n             * 1. Let namespace be a context namespace with value null.\n             * The context namespace tracks the XML serialization algorithm's current\n             * default namespace. The context namespace is changed when either an Element\n             * Node has a default namespace declaration, or the algorithm generates a\n             * default namespace declaration for the Element Node to match its own\n             * namespace. The algorithm assumes no namespace (null) to start.\n             * 2. Let prefix map be a new namespace prefix map.\n             * 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n             * 4. Let prefix index be a generated namespace prefix index with value 1.\n             * The generated namespace prefix index is used to generate a new unique\n             * prefix value when no suitable existing namespace prefix is available to\n             * serialize a node's namespaceURI (or the namespaceURI of one of node's\n             * attributes). See the generate a prefix algorithm.\n             */\n            var namespace = null;\n            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();\n            prefixMap.set(\"xml\", infra_1.namespace.XML);\n            var prefixIndex = { value: 1 };\n            /**\n             * 5. Return the result of running the XML serialization algorithm on node\n             * passing the context namespace namespace, namespace prefix map prefix map,\n             * generated namespace prefix index reference to prefix index, and the\n             * flag require well-formed. If an exception occurs during the execution\n             * of the algorithm, then catch that exception and throw an\n             * \"InvalidStateError\" DOMException.\n             */\n            this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);\n        }\n        else {\n            this._serializeNode(node, requireWellFormed, noDoubleEncoding);\n        }\n    };\n    /**\n     * Produces an XML serialization of a node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeNodeNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {\n        this.currentNode = node;\n        switch (node.nodeType) {\n            case interfaces_1.NodeType.Element:\n                this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.Document:\n                this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.Comment:\n                this._serializeComment(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.Text:\n                this._serializeText(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.DocumentFragment:\n                this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.DocumentType:\n                this._serializeDocumentType(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.ProcessingInstruction:\n                this._serializeProcessingInstruction(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.CData:\n                this._serializeCData(node, requireWellFormed, noDoubleEncoding);\n                break;\n            default:\n                throw new Error(\"Unknown node type: \" + node.nodeType);\n        }\n    };\n    /**\n     * Produces an XML serialization of a node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeNode = function (node, requireWellFormed, noDoubleEncoding) {\n        this.currentNode = node;\n        switch (node.nodeType) {\n            case interfaces_1.NodeType.Element:\n                this._serializeElement(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.Document:\n                this._serializeDocument(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.Comment:\n                this._serializeComment(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.Text:\n                this._serializeText(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.DocumentFragment:\n                this._serializeDocumentFragment(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.DocumentType:\n                this._serializeDocumentType(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.ProcessingInstruction:\n                this._serializeProcessingInstruction(node, requireWellFormed, noDoubleEncoding);\n                break;\n            case interfaces_1.NodeType.CData:\n                this._serializeCData(node, requireWellFormed, noDoubleEncoding);\n                break;\n            default:\n                throw new Error(\"Unknown node type: \" + node.nodeType);\n        }\n    };\n    /**\n     * Produces an XML serialization of an element node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeElementNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {\n        var e_2, _a;\n        var attributes = [];\n        /**\n         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node\n         *\n         * 1. If the require well-formed flag is set (its value is true), and this\n         * node's localName attribute contains the character \":\" (U+003A COLON) or\n         * does not match the XML Name production, then throw an exception; the\n         * serialization of this node would not be a well-formed element.\n         */\n        if (requireWellFormed && (node.localName.indexOf(\":\") !== -1 ||\n            !algorithm_1.xml_isName(node.localName))) {\n            throw new Error(\"Node local name contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n         * 3. Let qualified name be an empty string.\n         * 4. Let skip end tag be a boolean flag with value false.\n         * 5. Let ignore namespace definition attribute be a boolean flag with value\n         * false.\n         * 6. Given prefix map, copy a namespace prefix map and let map be the\n         * result.\n         * 7. Let local prefixes map be an empty map. The map has unique Node prefix\n         * strings as its keys, with corresponding namespaceURI Node values as the\n         * map's key values (in this map, the null namespace is represented by the\n         * empty string).\n         *\n         * _Note:_ This map is local to each element. It is used to ensure there\n         * are no conflicting prefixes should a new namespace prefix attribute need\n         * to be generated. It is also used to enable skipping of duplicate prefix\n         * definitions when writing an element's attributes: the map allows the\n         * algorithm to distinguish between a prefix in the namespace prefix map\n         * that might be locally-defined (to the current Element) and one that is\n         * not.\n         * 8. Let local default namespace be the result of recording the namespace\n         * information for node given map and local prefixes map.\n         *\n         * _Note:_ The above step will update map with any found namespace prefix\n         * definitions, add the found prefix definitions to the local prefixes map\n         * and return a local default namespace value defined by a default namespace\n         * attribute if one exists. Otherwise it returns null.\n         * 9. Let inherited ns be a copy of namespace.\n         * 10. Let ns be the value of node's namespaceURI attribute.\n         */\n        var qualifiedName = '';\n        var skipEndTag = false;\n        var ignoreNamespaceDefinitionAttribute = false;\n        var map = prefixMap.copy();\n        var localPrefixesMap = {};\n        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);\n        var inheritedNS = namespace;\n        var ns = node.namespaceURI;\n        /** 11. If inherited ns is equal to ns, then: */\n        if (inheritedNS === ns) {\n            /**\n             * 11.1. If local default namespace is not null, then set ignore\n             * namespace definition attribute to true.\n             */\n            if (localDefaultNamespace !== null) {\n                ignoreNamespaceDefinitionAttribute = true;\n            }\n            /**\n             * 11.2. If ns is the XML namespace, then append to qualified name the\n             * concatenation of the string \"xml:\" and the value of node's localName.\n             * 11.3. Otherwise, append to qualified name the value of node's\n             * localName. The node's prefix if it exists, is dropped.\n             */\n            if (ns === infra_1.namespace.XML) {\n                qualifiedName = 'xml:' + node.localName;\n            }\n            else {\n                qualifiedName = node.localName;\n            }\n            /** 11.4. Append the value of qualified name to markup. */\n            this.beginElement(qualifiedName);\n            this.openTagBegin(qualifiedName);\n        }\n        else {\n            /**\n             * 12. Otherwise, inherited ns is not equal to ns (the node's own\n             * namespace is different from the context namespace of its parent).\n             * Run these sub-steps:\n             *\n             * 12.1. Let prefix be the value of node's prefix attribute.\n             * 12.2. Let candidate prefix be the result of retrieving a preferred\n             * prefix string prefix from map given namespace ns. The above may return\n             * null if no namespace key ns exists in map.\n             */\n            var prefix = node.prefix;\n            /**\n             * We don't need to run \"retrieving a preferred prefix string\" algorithm if\n             * the element has no prefix and its namespace matches to the default\n             * namespace.\n             * See: https://github.com/web-platform-tests/wpt/pull/16703\n             */\n            var candidatePrefix = null;\n            if (prefix !== null || ns !== localDefaultNamespace) {\n                candidatePrefix = map.get(prefix, ns);\n            }\n            /**\n             * 12.3. If the value of prefix matches \"xmlns\", then run the following\n             * steps:\n             */\n            if (prefix === \"xmlns\") {\n                /**\n                 * 12.3.1. If the require well-formed flag is set, then throw an error.\n                 * An Element with prefix \"xmlns\" will not legally round-trip in a\n                 * conforming XML parser.\n                 */\n                if (requireWellFormed) {\n                    throw new Error(\"An element cannot have the 'xmlns' prefix (well-formed required).\");\n                }\n                /**\n                 * 12.3.2. Let candidate prefix be the value of prefix.\n                 */\n                candidatePrefix = prefix;\n            }\n            /**\n             * 12.4.Found a suitable namespace prefix: if candidate prefix is not\n             * null (a namespace prefix is defined which maps to ns), then:\n             */\n            if (candidatePrefix !== null) {\n                /**\n                 * The following may serialize a different prefix than the Element's\n                 * existing prefix if it already had one. However, the retrieving a\n                 * preferred prefix string algorithm already tried to match the\n                 * existing prefix if possible.\n                 *\n                 * 12.4.1. Append to qualified name the concatenation of candidate\n                 * prefix, \":\" (U+003A COLON), and node's localName. There exists on\n                 * this node or the node's ancestry a namespace prefix definition that\n                 * defines the node's namespace.\n                 * 12.4.2. If the local default namespace is not null (there exists a\n                 * locally-defined default namespace declaration attribute) and its\n                 * value is not the XML namespace, then let inherited ns get the value\n                 * of local default namespace unless the local default namespace is the\n                 * empty string in which case let it get null (the context namespace\n                 * is changed to the declared default, rather than this node's own\n                 * namespace).\n                 *\n                 * _Note:_ Any default namespace definitions or namespace prefixes that\n                 * define the XML namespace are omitted when serializing this node's\n                 * attributes.\n                 */\n                qualifiedName = candidatePrefix + ':' + node.localName;\n                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {\n                    inheritedNS = localDefaultNamespace || null;\n                }\n                /**\n                 * 12.4.3. Append the value of qualified name to markup.\n                 */\n                this.beginElement(qualifiedName);\n                this.openTagBegin(qualifiedName);\n                /** 12.5. Otherwise, if prefix is not null, then: */\n            }\n            else if (prefix !== null) {\n                /**\n                 * _Note:_ By this step, there is no namespace or prefix mapping\n                 * declaration in this node (or any parent node visited by this\n                 * algorithm) that defines prefix otherwise the step labelled Found\n                 * a suitable namespace prefix would have been followed. The sub-steps\n                 * that follow will create a new namespace prefix declaration for prefix\n                 * and ensure that prefix does not conflict with an existing namespace\n                 * prefix declaration of the same localName in node's attribute list.\n                 *\n                 * 12.5.1. If the local prefixes map contains a key matching prefix,\n                 * then let prefix be the result of generating a prefix providing as\n                 * input map, ns, and prefix index.\n                 */\n                if (prefix in localPrefixesMap) {\n                    prefix = this._generatePrefix(ns, map, prefixIndex);\n                }\n                /**\n                 * 12.5.2. Add prefix to map given namespace ns.\n                 * 12.5.3. Append to qualified name the concatenation of prefix, \":\"\n                 * (U+003A COLON), and node's localName.\n                 * 12.5.4. Append the value of qualified name to markup.\n                 */\n                map.set(prefix, ns);\n                qualifiedName += prefix + ':' + node.localName;\n                this.beginElement(qualifiedName);\n                this.openTagBegin(qualifiedName);\n                /**\n                 * 12.5.5. Append the following to markup, in the order listed:\n                 *\n                 * _Note:_ The following serializes a namespace prefix declaration for\n                 * prefix which was just added to the map.\n                 *\n                 * 12.5.5.1. \" \" (U+0020 SPACE);\n                 * 12.5.5.2. The string \"xmlns:\";\n                 * 12.5.5.3. The value of prefix;\n                 * 12.5.5.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 12.5.5.5. The result of serializing an attribute value given ns and\n                 * the require well-formed flag as input;\n                 * 12.5.5.6. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                attributes.push([null, 'xmlns', prefix,\n                    this._serializeAttributeValue(ns, requireWellFormed, noDoubleEncoding)]);\n                /**\n                 * 12.5.5.7. If local default namespace is not null (there exists a\n                 * locally-defined default namespace declaration attribute), then\n                 * let inherited ns get the value of local default namespace unless the\n                 * local default namespace is the empty string in which case let it get\n                 * null.\n                 */\n                if (localDefaultNamespace !== null) {\n                    inheritedNS = localDefaultNamespace || null;\n                }\n                /**\n                 * 12.6. Otherwise, if local default namespace is null, or local\n                 * default namespace is not null and its value is not equal to ns, then:\n                 */\n            }\n            else if (localDefaultNamespace === null ||\n                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {\n                /**\n                 * _Note:_ At this point, the namespace for this node still needs to be\n                 * serialized, but there's no prefix (or candidate prefix) available; the\n                 * following uses the default namespace declaration to define the\n                 * namespace--optionally replacing an existing default declaration\n                 * if present.\n                 *\n                 * 12.6.1. Set the ignore namespace definition attribute flag to true.\n                 * 12.6.2. Append to qualified name the value of node's localName.\n                 * 12.6.3. Let the value of inherited ns be ns.\n                 *\n                 * _Note:_ The new default namespace will be used in the serialization\n                 * to define this node's namespace and act as the context namespace for\n                 * its children.\n                 */\n                ignoreNamespaceDefinitionAttribute = true;\n                qualifiedName += node.localName;\n                inheritedNS = ns;\n                /**\n                 * 12.6.4. Append the value of qualified name to markup.\n                 */\n                this.beginElement(qualifiedName);\n                this.openTagBegin(qualifiedName);\n                /**\n                 * 12.6.5. Append the following to markup, in the order listed:\n                 *\n                 * _Note:_ The following serializes the new (or replacement) default\n                 * namespace definition.\n                 *\n                 * 12.6.5.1. \" \" (U+0020 SPACE);\n                 * 12.6.5.2. The string \"xmlns\";\n                 * 12.6.5.3. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 12.6.5.4. The result of serializing an attribute value given ns\n                 * and the require well-formed flag as input;\n                 * 12.6.5.5. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                attributes.push([null, null, 'xmlns',\n                    this._serializeAttributeValue(ns, requireWellFormed, noDoubleEncoding)]);\n                /**\n                 * 12.7. Otherwise, the node has a local default namespace that matches\n                 * ns. Append to qualified name the value of node's localName, let the\n                 * value of inherited ns be ns, and append the value of qualified name\n                 * to markup.\n                 */\n            }\n            else {\n                qualifiedName += node.localName;\n                inheritedNS = ns;\n                this.beginElement(qualifiedName);\n                this.openTagBegin(qualifiedName);\n            }\n        }\n        /**\n         * 13. Append to markup the result of the XML serialization of node's\n         * attributes given map, prefix index, local prefixes map, ignore namespace\n         * definition attribute flag, and require well-formed flag.\n         */\n        attributes.push.apply(attributes, __spread(this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, noDoubleEncoding)));\n        this.attributes(attributes);\n        /**\n         * 14. If ns is the HTML namespace, and the node's list of children is\n         * empty, and the node's localName matches any one of the following void\n         * elements: \"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"embed\",\n         * \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\",\n         * \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup,\n         * in the order listed:\n         * 14.1. \" \" (U+0020 SPACE);\n         * 14.2. \"/\" (U+002F SOLIDUS).\n         * and set the skip end tag flag to true.\n         * 15. If ns is not the HTML namespace, and the node's list of children is\n         * empty, then append \"/\" (U+002F SOLIDUS) to markup and set the skip end\n         * tag flag to true.\n         * 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n         */\n        var isHTML = (ns === infra_1.namespace.HTML);\n        if (isHTML && node.childNodes.length === 0 &&\n            BaseWriter._VoidElementNames.has(node.localName)) {\n            this.openTagEnd(qualifiedName, true, true);\n            this.endElement(qualifiedName);\n            skipEndTag = true;\n        }\n        else if (!isHTML && node.childNodes.length === 0) {\n            this.openTagEnd(qualifiedName, true, false);\n            this.endElement(qualifiedName);\n            skipEndTag = true;\n        }\n        else {\n            this.openTagEnd(qualifiedName, false, false);\n        }\n        /**\n         * 17. If the value of skip end tag is true, then return the value of markup\n         * and skip the remaining steps. The node is a leaf-node.\n         */\n        if (skipEndTag)\n            return;\n        /**\n         * 18. If ns is the HTML namespace, and the node's localName matches the\n         * string \"template\", then this is a template element. Append to markup the\n         * result of XML serializing a DocumentFragment node given the template\n         * element's template contents (a DocumentFragment), providing inherited\n         * ns, map, prefix index, and the require well-formed flag.\n         *\n         * _Note:_ This allows template content to round-trip, given the rules for\n         * parsing XHTML documents.\n         *\n         * 19. Otherwise, append to markup the result of running the XML\n         * serialization algorithm on each of node's children, in tree order,\n         * providing inherited ns, map, prefix index, and the require well-formed\n         * flag.\n         */\n        if (isHTML && node.localName === \"template\") {\n            // TODO: serialize template contents\n        }\n        else {\n            try {\n                for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var childNode = _c.value;\n                    this.level++;\n                    this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed, noDoubleEncoding);\n                    this.level--;\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        /**\n         * 20. Append the following to markup, in the order listed:\n         * 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n         * 20.2. The value of qualified name;\n         * 20.3. \">\" (U+003E GREATER-THAN SIGN).\n         * 21. Return the value of markup.\n         */\n        this.closeTag(qualifiedName);\n        this.endElement(qualifiedName);\n    };\n    /**\n     * Produces an XML serialization of an element node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeElement = function (node, requireWellFormed, noDoubleEncoding) {\n        var e_3, _a;\n        /**\n         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node\n         *\n         * 1. If the require well-formed flag is set (its value is true), and this\n         * node's localName attribute contains the character \":\" (U+003A COLON) or\n         * does not match the XML Name production, then throw an exception; the\n         * serialization of this node would not be a well-formed element.\n         */\n        if (requireWellFormed && (node.localName.indexOf(\":\") !== -1 ||\n            !algorithm_1.xml_isName(node.localName))) {\n            throw new Error(\"Node local name contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n         * 3. Let qualified name be an empty string.\n         * 4. Let skip end tag be a boolean flag with value false.\n         * 5. Let ignore namespace definition attribute be a boolean flag with value\n         * false.\n         * 6. Given prefix map, copy a namespace prefix map and let map be the\n         * result.\n         * 7. Let local prefixes map be an empty map. The map has unique Node prefix\n         * strings as its keys, with corresponding namespaceURI Node values as the\n         * map's key values (in this map, the null namespace is represented by the\n         * empty string).\n         *\n         * _Note:_ This map is local to each element. It is used to ensure there\n         * are no conflicting prefixes should a new namespace prefix attribute need\n         * to be generated. It is also used to enable skipping of duplicate prefix\n         * definitions when writing an element's attributes: the map allows the\n         * algorithm to distinguish between a prefix in the namespace prefix map\n         * that might be locally-defined (to the current Element) and one that is\n         * not.\n         * 8. Let local default namespace be the result of recording the namespace\n         * information for node given map and local prefixes map.\n         *\n         * _Note:_ The above step will update map with any found namespace prefix\n         * definitions, add the found prefix definitions to the local prefixes map\n         * and return a local default namespace value defined by a default namespace\n         * attribute if one exists. Otherwise it returns null.\n         * 9. Let inherited ns be a copy of namespace.\n         * 10. Let ns be the value of node's namespaceURI attribute.\n         */\n        var skipEndTag = false;\n        /** 11. If inherited ns is equal to ns, then: */\n        /**\n         * 11.1. If local default namespace is not null, then set ignore\n         * namespace definition attribute to true.\n         */\n        /**\n         * 11.2. If ns is the XML namespace, then append to qualified name the\n         * concatenation of the string \"xml:\" and the value of node's localName.\n         * 11.3. Otherwise, append to qualified name the value of node's\n         * localName. The node's prefix if it exists, is dropped.\n         */\n        var qualifiedName = node.localName;\n        /** 11.4. Append the value of qualified name to markup. */\n        this.beginElement(qualifiedName);\n        this.openTagBegin(qualifiedName);\n        /**\n         * 13. Append to markup the result of the XML serialization of node's\n         * attributes given map, prefix index, local prefixes map, ignore namespace\n         * definition attribute flag, and require well-formed flag.\n         */\n        var attributes = this._serializeAttributes(node, requireWellFormed, noDoubleEncoding);\n        this.attributes(attributes);\n        /**\n         * 14. If ns is the HTML namespace, and the node's list of children is\n         * empty, and the node's localName matches any one of the following void\n         * elements: \"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"embed\",\n         * \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\",\n         * \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup,\n         * in the order listed:\n         * 14.1. \" \" (U+0020 SPACE);\n         * 14.2. \"/\" (U+002F SOLIDUS).\n         * and set the skip end tag flag to true.\n         * 15. If ns is not the HTML namespace, and the node's list of children is\n         * empty, then append \"/\" (U+002F SOLIDUS) to markup and set the skip end\n         * tag flag to true.\n         * 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n         */\n        if (!node.hasChildNodes()) {\n            this.openTagEnd(qualifiedName, true, false);\n            this.endElement(qualifiedName);\n            skipEndTag = true;\n        }\n        else {\n            this.openTagEnd(qualifiedName, false, false);\n        }\n        /**\n         * 17. If the value of skip end tag is true, then return the value of markup\n         * and skip the remaining steps. The node is a leaf-node.\n         */\n        if (skipEndTag)\n            return;\n        try {\n            /**\n             * 18. If ns is the HTML namespace, and the node's localName matches the\n             * string \"template\", then this is a template element. Append to markup the\n             * result of XML serializing a DocumentFragment node given the template\n             * element's template contents (a DocumentFragment), providing inherited\n             * ns, map, prefix index, and the require well-formed flag.\n             *\n             * _Note:_ This allows template content to round-trip, given the rules for\n             * parsing XHTML documents.\n             *\n             * 19. Otherwise, append to markup the result of running the XML\n             * serialization algorithm on each of node's children, in tree order,\n             * providing inherited ns, map, prefix index, and the require well-formed\n             * flag.\n             */\n            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                this.level++;\n                this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);\n                this.level--;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        /**\n         * 20. Append the following to markup, in the order listed:\n         * 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n         * 20.2. The value of qualified name;\n         * 20.3. \">\" (U+003E GREATER-THAN SIGN).\n         * 21. Return the value of markup.\n         */\n        this.closeTag(qualifiedName);\n        this.endElement(qualifiedName);\n    };\n    /**\n     * Produces an XML serialization of a document node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeDocumentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {\n        var e_4, _a;\n        /**\n         * If the require well-formed flag is set (its value is true), and this node\n         * has no documentElement (the documentElement attribute's value is null),\n         * then throw an exception; the serialization of this node would not be a\n         * well-formed document.\n         */\n        if (requireWellFormed && node.documentElement === null) {\n            throw new Error(\"Missing document element (well-formed required).\");\n        }\n        try {\n            /**\n             * Otherwise, run the following steps:\n             * 1. Let serialized document be an empty string.\n             * 2. For each child child of node, in tree order, run the XML\n             * serialization algorithm on the child passing along the provided\n             * arguments, and append the result to serialized document.\n             *\n             * _Note:_ This will serialize any number of ProcessingInstruction and\n             * Comment nodes both before and after the Document's documentElement node,\n             * including at most one DocumentType node. (Text nodes are not allowed as\n             * children of the Document.)\n             *\n             * 3. Return the value of serialized document.\n            */\n            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n    };\n    /**\n     * Produces an XML serialization of a document node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeDocument = function (node, requireWellFormed, noDoubleEncoding) {\n        var e_5, _a;\n        /**\n         * If the require well-formed flag is set (its value is true), and this node\n         * has no documentElement (the documentElement attribute's value is null),\n         * then throw an exception; the serialization of this node would not be a\n         * well-formed document.\n         */\n        if (requireWellFormed && node.documentElement === null) {\n            throw new Error(\"Missing document element (well-formed required).\");\n        }\n        try {\n            /**\n             * Otherwise, run the following steps:\n             * 1. Let serialized document be an empty string.\n             * 2. For each child child of node, in tree order, run the XML\n             * serialization algorithm on the child passing along the provided\n             * arguments, and append the result to serialized document.\n             *\n             * _Note:_ This will serialize any number of ProcessingInstruction and\n             * Comment nodes both before and after the Document's documentElement node,\n             * including at most one DocumentType node. (Text nodes are not allowed as\n             * children of the Document.)\n             *\n             * 3. Return the value of serialized document.\n            */\n            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n    };\n    /**\n     * Produces an XML serialization of a comment node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeComment = function (node, requireWellFormed, noDoubleEncoding) {\n        /**\n         * If the require well-formed flag is set (its value is true), and node's\n         * data contains characters that are not matched by the XML Char production\n         * or contains \"--\" (two adjacent U+002D HYPHEN-MINUS characters) or that\n         * ends with a \"-\" (U+002D HYPHEN-MINUS) character, then throw an exception;\n         * the serialization of this node's data would not be well-formed.\n         */\n        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||\n            node.data.indexOf(\"--\") !== -1 || node.data.endsWith(\"-\"))) {\n            throw new Error(\"Comment data contains invalid characters (well-formed required).\");\n        }\n        /**\n         * Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n         */\n        this.comment(node.data);\n    };\n    /**\n     * Produces an XML serialization of a text node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     * @param level - current depth of the XML tree\n     */\n    BaseWriter.prototype._serializeText = function (node, requireWellFormed, noDoubleEncoding) {\n        /**\n         * 1. If the require well-formed flag is set (its value is true), and\n         * node's data contains characters that are not matched by the XML Char\n         * production, then throw an exception; the serialization of this node's\n         * data would not be well-formed.\n         */\n        if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {\n            throw new Error(\"Text data contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. Let markup be the value of node's data.\n         * 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n         * 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n         * 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n         * 6. Return the value of markup.\n         */\n        var markup = \"\";\n        if (noDoubleEncoding) {\n            markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        }\n        else {\n            for (var i = 0; i < node.data.length; i++) {\n                var c = node.data[i];\n                if (c === \"&\")\n                    markup += \"&amp;\";\n                else if (c === \"<\")\n                    markup += \"&lt;\";\n                else if (c === \">\")\n                    markup += \"&gt;\";\n                else\n                    markup += c;\n            }\n        }\n        this.text(markup);\n    };\n    /**\n     * Produces an XML serialization of a document fragment node.\n     *\n     * @param node - node to serialize\n     * @param namespace - context namespace\n     * @param prefixMap - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeDocumentFragmentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {\n        var e_6, _a;\n        try {\n            /**\n             * 1. Let markup the empty string.\n             * 2. For each child child of node, in tree order, run the XML serialization\n             * algorithm on the child given namespace, prefix map, a reference to prefix\n             * index, and flag require well-formed. Concatenate the result to markup.\n             * 3. Return the value of markup.\n             */\n            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n    };\n    /**\n     * Produces an XML serialization of a document fragment node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeDocumentFragment = function (node, requireWellFormed, noDoubleEncoding) {\n        var e_7, _a;\n        try {\n            /**\n             * 1. Let markup the empty string.\n             * 2. For each child child of node, in tree order, run the XML serialization\n             * algorithm on the child given namespace, prefix map, a reference to prefix\n             * index, and flag require well-formed. Concatenate the result to markup.\n             * 3. Return the value of markup.\n             */\n            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var childNode = _c.value;\n                this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n    };\n    /**\n     * Produces an XML serialization of a document type node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeDocumentType = function (node, requireWellFormed, noDoubleEncoding) {\n        /**\n         * 1. If the require well-formed flag is true and the node's publicId\n         * attribute contains characters that are not matched by the XML PubidChar\n         *  production, then throw an exception; the serialization of this node\n         * would not be a well-formed document type declaration.\n         */\n        if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {\n            throw new Error(\"DocType public identifier does not match PubidChar construct (well-formed required).\");\n        }\n        /**\n         * 2. If the require well-formed flag is true and the node's systemId\n         * attribute contains characters that are not matched by the XML Char\n         * production or that contains both a \"\"\" (U+0022 QUOTATION MARK) and a\n         * \"'\" (U+0027 APOSTROPHE), then throw an exception; the serialization\n         * of this node would not be a well-formed document type declaration.\n         */\n        if (requireWellFormed &&\n            (!algorithm_1.xml_isLegalChar(node.systemId) ||\n                (node.systemId.indexOf('\"') !== -1 && node.systemId.indexOf(\"'\") !== -1))) {\n            throw new Error(\"DocType system identifier contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 3. Let markup be an empty string.\n         * 4. Append the string \"<!DOCTYPE\" to markup.\n         * 5. Append \" \" (U+0020 SPACE) to markup.\n         * 6. Append the value of the node's name attribute to markup. For a node\n         * belonging to an HTML document, the value will be all lowercase.\n         * 7. If the node's publicId is not the empty string then append the\n         * following, in the order listed, to markup:\n         * 7.1. \" \" (U+0020 SPACE);\n         * 7.2. The string \"PUBLIC\";\n         * 7.3. \" \" (U+0020 SPACE);\n         * 7.4. \"\"\" (U+0022 QUOTATION MARK);\n         * 7.5. The value of the node's publicId attribute;\n         * 7.6. \"\"\" (U+0022 QUOTATION MARK).\n         * 8. If the node's systemId is not the empty string and the node's publicId\n         * is set to the empty string, then append the following, in the order\n         * listed, to markup:\n         * 8.1. \" \" (U+0020 SPACE);\n         * 8.2. The string \"SYSTEM\".\n         * 9. If the node's systemId is not the empty string then append the\n         * following, in the order listed, to markup:\n         * 9.2. \" \" (U+0020 SPACE);\n         * 9.3. \"\"\" (U+0022 QUOTATION MARK);\n         * 9.3. The value of the node's systemId attribute;\n         * 9.4. \"\"\" (U+0022 QUOTATION MARK).\n         * 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n         * 11. Return the value of markup.\n         */\n        this.docType(node.name, node.publicId, node.systemId);\n    };\n    /**\n     * Produces an XML serialization of a processing instruction node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeProcessingInstruction = function (node, requireWellFormed, noDoubleEncoding) {\n        /**\n         * 1. If the require well-formed flag is set (its value is true), and node's\n         * target contains a \":\" (U+003A COLON) character or is an ASCII\n         * case-insensitive match for the string \"xml\", then throw an exception;\n         * the serialization of this node's target would not be well-formed.\n         */\n        if (requireWellFormed && (node.target.indexOf(\":\") !== -1 || (/^xml$/i).test(node.target))) {\n            throw new Error(\"Processing instruction target contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 2. If the require well-formed flag is set (its value is true), and node's\n         * data contains characters that are not matched by the XML Char production\n         * or contains the string \"?>\" (U+003F QUESTION MARK,\n         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of\n         * this node's data would not be well-formed.\n         */\n        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||\n            node.data.indexOf(\"?>\") !== -1)) {\n            throw new Error(\"Processing instruction data contains invalid characters (well-formed required).\");\n        }\n        /**\n         * 3. Let markup be the concatenation of the following, in the order listed:\n         * 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n         * 3.2. The value of node's target;\n         * 3.3. \" \" (U+0020 SPACE);\n         * 3.4. The value of node's data;\n         * 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n         * 4. Return the value of markup.\n         */\n        this.instruction(node.target, node.data);\n    };\n    /**\n     * Produces an XML serialization of a CDATA node.\n     *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeCData = function (node, requireWellFormed, noDoubleEncoding) {\n        if (requireWellFormed && (node.data.indexOf(\"]]>\") !== -1)) {\n            throw new Error(\"CDATA contains invalid characters (well-formed required).\");\n        }\n        this.cdata(node.data);\n    };\n    /**\n    * Produces an XML serialization of the attributes of an element node.\n    *\n     * @param node - node to serialize\n     * @param map - namespace prefix map\n     * @param prefixIndex - generated namespace prefix index\n     * @param localPrefixesMap - local prefixes map\n     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace\n     * attributes\n     * @param requireWellFormed - whether to check conformance\n    */\n    BaseWriter.prototype._serializeAttributesNS = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, noDoubleEncoding) {\n        var e_8, _a;\n        /**\n         * 1. Let result be the empty string.\n         * 2. Let localname set be a new empty namespace localname set. This\n         * localname set will contain tuples of unique attribute namespaceURI and\n         * localName pairs, and is populated as each attr is processed. This set is\n         * used to [optionally] enforce the well-formed constraint that an element\n         * cannot have two attributes with the same namespaceURI and localName.\n         * This can occur when two otherwise identical attributes on the same\n         * element differ only by their prefix values.\n         */\n        var result = [];\n        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;\n        try {\n            /**\n             * 3. Loop: For each attribute attr in element's attributes, in the order\n             * they are specified in the element's attribute list:\n             */\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                // Optimize common case\n                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {\n                    result.push([null, null, attr.localName,\n                        this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)]);\n                    continue;\n                }\n                /**\n                 * 3.1. If the require well-formed flag is set (its value is true), and the\n                 * localname set contains a tuple whose values match those of a new tuple\n                 * consisting of attr's namespaceURI attribute and localName attribute,\n                 * then throw an exception; the serialization of this attr would fail to\n                 * produce a well-formed element serialization.\n                 */\n                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {\n                    throw new Error(\"Element contains duplicate attributes (well-formed required).\");\n                }\n                /**\n                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and\n                 * localName attribute, and add it to the localname set.\n                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n                 * 3.4. Let candidate prefix be null.\n                 */\n                if (requireWellFormed && localNameSet)\n                    localNameSet.set(attr.namespaceURI, attr.localName);\n                var attributeNamespace = attr.namespaceURI;\n                var candidatePrefix = null;\n                /** 3.5. If attribute namespace is not null, then run these sub-steps: */\n                if (attributeNamespace !== null) {\n                    /**\n                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred\n                     * prefix string from map given namespace attribute namespace with\n                     * preferred prefix being attr's prefix value.\n                     */\n                    candidatePrefix = map.get(attr.prefix, attributeNamespace);\n                    /**\n                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,\n                     * then run these steps:\n                     */\n                    if (attributeNamespace === infra_1.namespace.XMLNS) {\n                        /**\n                         * 3.5.2.1. If any of the following are true, then stop running these\n                         * steps and goto Loop to visit the next attribute:\n                         * - the attr's value is the XML namespace;\n                         * _Note:_ The XML namespace cannot be redeclared and survive\n                         * round-tripping (unless it defines the prefix \"xml\"). To avoid this\n                         * problem, this algorithm always prefixes elements in the XML\n                         * namespace with \"xml\" and drops any related definitions as seen\n                         * in the above condition.\n                         * - the attr's prefix is null and the ignore namespace definition\n                         * attribute flag is true (the Element's default namespace attribute\n                         * should be skipped);\n                         * - the attr's prefix is not null and either\n                         *   * the attr's localName is not a key contained in the local\n                         *     prefixes map, or\n                         *   * the attr's localName is present in the local prefixes map but\n                         *     the value of the key does not match attr's value\n                         * and furthermore that the attr's localName (as the prefix to find)\n                         * is found in the namespace prefix map given the namespace consisting\n                         * of the attr's value (the current namespace prefix definition was\n                         * exactly defined previously--on an ancestor element not the current\n                         * element whose attributes are being processed).\n                         */\n                        if (attr.value === infra_1.namespace.XML ||\n                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||\n                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||\n                                localPrefixesMap[attr.localName] !== attr.value) &&\n                                map.has(attr.localName, attr.value)))\n                            continue;\n                        /**\n                         * 3.5.2.2. If the require well-formed flag is set (its value is true),\n                         * and the value of attr's value attribute matches the XMLNS\n                         * namespace, then throw an exception; the serialization of this\n                         * attribute would produce invalid XML because the XMLNS namespace\n                         * is reserved and cannot be applied as an element's namespace via\n                         * XML parsing.\n                         *\n                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS\n                         * namespace but with strict qualifications.\n                         */\n                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {\n                            throw new Error(\"XMLNS namespace is reserved (well-formed required).\");\n                        }\n                        /**\n                         * 3.5.2.3. If the require well-formed flag is set (its value is true),\n                         * and the value of attr's value attribute is the empty string, then\n                         * throw an exception; namespace prefix declarations cannot be used\n                         * to undeclare a namespace (use a default namespace declaration\n                         * instead).\n                         */\n                        if (requireWellFormed && attr.value === '') {\n                            throw new Error(\"Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).\");\n                        }\n                        /**\n                         * 3.5.2.4. the attr's prefix matches the string \"xmlns\", then let\n                         * candidate prefix be the string \"xmlns\".\n                         */\n                        if (attr.prefix === 'xmlns')\n                            candidatePrefix = 'xmlns';\n                        /**\n                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.\n                         * Run these steps:\n                         *\n                         * _Note:_ The (candidatePrefix === null) check is not in the spec.\n                         * We deviate from the spec here. Otherwise a prefix is generated for\n                         * all attributes with namespaces.\n                         */\n                    }\n                    else if (candidatePrefix === null) {\n                        if (attr.prefix !== null &&\n                            (!map.hasPrefix(attr.prefix) ||\n                                map.has(attr.prefix, attributeNamespace))) {\n                            /**\n                             * Check if we can use the attribute's own prefix.\n                             * We deviate from the spec here.\n                             * TODO: This is not an efficient way of searching for prefixes.\n                             * Follow developments to the spec.\n                             */\n                            candidatePrefix = attr.prefix;\n                        }\n                        else {\n                            /**\n                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix\n                             * providing map, attribute namespace, and prefix index as input.\n                             */\n                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);\n                        }\n                        /**\n                         * 3.5.3.2. Append the following to result, in the order listed:\n                         * 3.5.3.2.1. \" \" (U+0020 SPACE);\n                         * 3.5.3.2.2. The string \"xmlns:\";\n                         * 3.5.3.2.3. The value of candidate prefix;\n                         * 3.5.3.2.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                         * 3.5.3.2.5. The result of serializing an attribute value given\n                         * attribute namespace and the require well-formed flag as input;\n                         * 3.5.3.2.6. \"\"\" (U+0022 QUOTATION MARK).\n                        */\n                        result.push([null, \"xmlns\", candidatePrefix,\n                            this._serializeAttributeValue(attributeNamespace, requireWellFormed, noDoubleEncoding)]);\n                    }\n                }\n                /**\n                 * 3.6. Append a \" \" (U+0020 SPACE) to result.\n                 * 3.7. If candidate prefix is not null, then append to result the\n                 * concatenation of candidate prefix with \":\" (U+003A COLON).\n                 */\n                var attrName = '';\n                if (candidatePrefix !== null) {\n                    attrName = candidatePrefix;\n                }\n                /**\n                 * 3.8. If the require well-formed flag is set (its value is true), and\n                 * this attr's localName attribute contains the character\n                 * \":\" (U+003A COLON) or does not match the XML Name production or\n                 * equals \"xmlns\" and attribute namespace is null, then throw an\n                 * exception; the serialization of this attr would not be a\n                 * well-formed attribute.\n                 */\n                if (requireWellFormed && (attr.localName.indexOf(\":\") !== -1 ||\n                    !algorithm_1.xml_isName(attr.localName) ||\n                    (attr.localName === \"xmlns\" && attributeNamespace === null))) {\n                    throw new Error(\"Attribute local name contains invalid characters (well-formed required).\");\n                }\n                /**\n                 * 3.9. Append the following strings to result, in the order listed:\n                 * 3.9.1. The value of attr's localName;\n                 * 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 3.9.3. The result of serializing an attribute value given attr's value\n                 * attribute and the require well-formed flag as input;\n                 * 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                result.push([attributeNamespace, candidatePrefix, attr.localName,\n                    this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)]);\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n        /**\n         * 4. Return the value of result.\n         */\n        return result;\n    };\n    /**\n    * Produces an XML serialization of the attributes of an element node.\n    *\n     * @param node - node to serialize\n     * @param requireWellFormed - whether to check conformance\n    */\n    BaseWriter.prototype._serializeAttributes = function (node, requireWellFormed, noDoubleEncoding) {\n        var e_9, _a;\n        /**\n         * 1. Let result be the empty string.\n         * 2. Let localname set be a new empty namespace localname set. This\n         * localname set will contain tuples of unique attribute namespaceURI and\n         * localName pairs, and is populated as each attr is processed. This set is\n         * used to [optionally] enforce the well-formed constraint that an element\n         * cannot have two attributes with the same namespaceURI and localName.\n         * This can occur when two otherwise identical attributes on the same\n         * element differ only by their prefix values.\n         */\n        var result = [];\n        var localNameSet = requireWellFormed ? {} : undefined;\n        try {\n            /**\n             * 3. Loop: For each attribute attr in element's attributes, in the order\n             * they are specified in the element's attribute list:\n             */\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                // Optimize common case\n                if (!requireWellFormed) {\n                    result.push([null, null, attr.localName,\n                        this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)]);\n                    continue;\n                }\n                /**\n                 * 3.1. If the require well-formed flag is set (its value is true), and the\n                 * localname set contains a tuple whose values match those of a new tuple\n                 * consisting of attr's namespaceURI attribute and localName attribute,\n                 * then throw an exception; the serialization of this attr would fail to\n                 * produce a well-formed element serialization.\n                 */\n                if (requireWellFormed && localNameSet && (attr.localName in localNameSet)) {\n                    throw new Error(\"Element contains duplicate attributes (well-formed required).\");\n                }\n                /**\n                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and\n                 * localName attribute, and add it to the localname set.\n                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n                 * 3.4. Let candidate prefix be null.\n                 */\n                /* istanbul ignore else */\n                if (requireWellFormed && localNameSet)\n                    localNameSet[attr.localName] = true;\n                /** 3.5. If attribute namespace is not null, then run these sub-steps: */\n                /**\n                 * 3.6. Append a \" \" (U+0020 SPACE) to result.\n                 * 3.7. If candidate prefix is not null, then append to result the\n                 * concatenation of candidate prefix with \":\" (U+003A COLON).\n                 */\n                /**\n                 * 3.8. If the require well-formed flag is set (its value is true), and\n                 * this attr's localName attribute contains the character\n                 * \":\" (U+003A COLON) or does not match the XML Name production or\n                 * equals \"xmlns\" and attribute namespace is null, then throw an\n                 * exception; the serialization of this attr would not be a\n                 * well-formed attribute.\n                 */\n                if (requireWellFormed && (attr.localName.indexOf(\":\") !== -1 ||\n                    !algorithm_1.xml_isName(attr.localName))) {\n                    throw new Error(\"Attribute local name contains invalid characters (well-formed required).\");\n                }\n                /**\n                 * 3.9. Append the following strings to result, in the order listed:\n                 * 3.9.1. The value of attr's localName;\n                 * 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                 * 3.9.3. The result of serializing an attribute value given attr's value\n                 * attribute and the require well-formed flag as input;\n                 * 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n                 */\n                result.push([null, null, attr.localName,\n                    this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)]);\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        /**\n         * 4. Return the value of result.\n         */\n        return result;\n    };\n    /**\n    * Records namespace information for the given element and returns the\n    * default namespace attribute value.\n    *\n    * @param node - element node to process\n    * @param map - namespace prefix map\n    * @param localPrefixesMap - local prefixes map\n    */\n    BaseWriter.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {\n        var e_10, _a;\n        /**\n         * 1. Let default namespace attr value be null.\n         */\n        var defaultNamespaceAttrValue = null;\n        try {\n            /**\n             * 2. Main: For each attribute attr in element's attributes, in the order\n             * they are specified in the element's attribute list:\n             */\n            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attr = _c.value;\n                /**\n                 * _Note:_ The following conditional steps find namespace prefixes. Only\n                 * attributes in the XMLNS namespace are considered (e.g., attributes made\n                 * to look like namespace declarations via\n                 * setAttribute(\"xmlns:pretend-prefix\", \"pretend-namespace\") are not\n                 * included).\n                 */\n                /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */\n                var attributeNamespace = attr.namespaceURI;\n                /** 2.2. Let attribute prefix be the value of attr's prefix. */\n                var attributePrefix = attr.prefix;\n                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */\n                if (attributeNamespace === infra_1.namespace.XMLNS) {\n                    /**\n                     * 2.3.1. If attribute prefix is null, then attr is a default namespace\n                     * declaration. Set the default namespace attr value to attr's value and\n                     * stop running these steps, returning to Main to visit the next\n                     * attribute.\n                     */\n                    if (attributePrefix === null) {\n                        defaultNamespaceAttrValue = attr.value;\n                        continue;\n                        /**\n                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a\n                         * namespace prefix definition. Run the following steps:\n                         */\n                    }\n                    else {\n                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */\n                        var prefixDefinition = attr.localName;\n                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */\n                        var namespaceDefinition = attr.value;\n                        /**\n                         * 2.3.2.3. If namespace definition is the XML namespace, then stop\n                         * running these steps, and return to Main to visit the next\n                         * attribute.\n                         *\n                         * _Note:_ XML namespace definitions in prefixes are completely\n                         * ignored (in order to avoid unnecessary work when there might be\n                         * prefix conflicts). XML namespaced elements are always handled\n                         * uniformly by prefixing (and overriding if necessary) the element's\n                         * localname with the reserved \"xml\" prefix.\n                         */\n                        if (namespaceDefinition === infra_1.namespace.XML) {\n                            continue;\n                        }\n                        /**\n                         * 2.3.2.4. If namespace definition is the empty string (the\n                         * declarative form of having no namespace), then let namespace\n                         * definition be null instead.\n                         */\n                        if (namespaceDefinition === '') {\n                            namespaceDefinition = null;\n                        }\n                        /**\n                         * 2.3.2.5. If prefix definition is found in map given the namespace\n                         * namespace definition, then stop running these steps, and return to\n                         * Main to visit the next attribute.\n                         *\n                         * _Note:_ This step avoids adding duplicate prefix definitions for\n                         * the same namespace in the map. This has the side-effect of avoiding\n                         * later serialization of duplicate namespace prefix declarations in\n                         * any descendant nodes.\n                         */\n                        if (map.has(prefixDefinition, namespaceDefinition)) {\n                            continue;\n                        }\n                        /**\n                         * 2.3.2.6. Add the prefix prefix definition to map given namespace\n                         * namespace definition.\n                         */\n                        map.set(prefixDefinition, namespaceDefinition);\n                        /**\n                         * 2.3.2.7. Add the value of prefix definition as a new key to the\n                         * local prefixes map, with the namespace definition as the key's\n                         * value replacing the value of null with the empty string if\n                         * applicable.\n                         */\n                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';\n                    }\n                }\n            }\n        }\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_10) throw e_10.error; }\n        }\n        /**\n         * 3. Return the value of default namespace attr value.\n         *\n         * _Note:_ The empty string is a legitimate return value and is not\n         * converted to null.\n         */\n        return defaultNamespaceAttrValue;\n    };\n    /**\n    * Generates a new prefix for the given namespace.\n    *\n    * @param newNamespace - a namespace to generate prefix for\n    * @param prefixMap - namespace prefix map\n    * @param prefixIndex - generated namespace prefix index\n    */\n    BaseWriter.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {\n        /**\n         * 1. Let generated prefix be the concatenation of the string \"ns\" and the\n         * current numerical value of prefix index.\n         * 2. Let the value of prefix index be incremented by one.\n         * 3. Add to map the generated prefix given the new namespace namespace.\n         * 4. Return the value of generated prefix.\n         */\n        var generatedPrefix = \"ns\" + prefixIndex.value.toString();\n        prefixIndex.value++;\n        prefixMap.set(generatedPrefix, newNamespace);\n        return generatedPrefix;\n    };\n    /**\n     * Produces an XML serialization of an attribute value.\n     *\n     * @param value - attribute value\n     * @param requireWellFormed - whether to check conformance\n     */\n    BaseWriter.prototype._serializeAttributeValue = function (value, requireWellFormed, noDoubleEncoding) {\n        /**\n         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value\n         *\n         * 1. If the require well-formed flag is set (its value is true), and\n         * attribute value contains characters that are not matched by the XML Char\n         * production, then throw an exception; the serialization of this attribute\n         * value would fail to produce a well-formed element serialization.\n         */\n        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {\n            throw new Error(\"Invalid characters in attribute value.\");\n        }\n        /**\n         * 2. If attribute value is null, then return the empty string.\n         */\n        if (value === null)\n            return \"\";\n        /**\n         * 3. Otherwise, attribute value is a string. Return the value of attribute\n         * value, first replacing any occurrences of the following:\n         * - \"&\" with \"&amp;\"\n         * - \"\"\" with \"&quot;\"\n         * - \"<\" with \"&lt;\"\n         * - \">\" with \"&gt;\"\n         * NOTE\n         * This matches behavior present in browsers, and goes above and beyond the\n         * grammar requirement in the XML specification's AttValue production by\n         * also replacing \">\" characters.\n         */\n        if (noDoubleEncoding) {\n            return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;')\n                .replace(/\"/g, '&quot;');\n        }\n        else {\n            var result = \"\";\n            for (var i = 0; i < value.length; i++) {\n                var c = value[i];\n                if (c === \"\\\"\")\n                    result += \"&quot;\";\n                else if (c === \"&\")\n                    result += \"&amp;\";\n                else if (c === \"<\")\n                    result += \"&lt;\";\n                else if (c === \">\")\n                    result += \"&gt;\";\n                else\n                    result += c;\n            }\n            return result;\n        }\n    };\n    BaseWriter._VoidElementNames = new Set(['area', 'base', 'basefont',\n        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',\n        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);\n    return BaseWriter;\n}());\nexports.BaseWriter = BaseWriter;\n//# sourceMappingURL=BaseWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseCBWriter_1 = require(\"./BaseCBWriter\");\n/**\n * Serializes XML nodes.\n */\nvar JSONCBWriter = /** @class */ (function (_super) {\n    __extends(JSONCBWriter, _super);\n    /**\n     * Initializes a new instance of `JSONCBWriter`.\n     *\n     * @param builderOptions - XML builder options\n     */\n    function JSONCBWriter(builderOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        _this._hasChildren = [];\n        _this._additionalLevel = 0;\n        return _this;\n    }\n    /** @inheritdoc */\n    JSONCBWriter.prototype.frontMatter = function () {\n        return \"\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.declaration = function (version, encoding, standalone) {\n        return \"\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.docType = function (name, publicId, systemId) {\n        return \"\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.comment = function (data) {\n        // { \"!\": \"hello\" }\n        return this._comma() + this._beginLine() + \"{\" + this._sep() +\n            this._key(this._builderOptions.convert.comment) + this._sep() +\n            this._val(data) + this._sep() + \"}\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.text = function (data) {\n        // { \"#\": \"hello\" }\n        return this._comma() + this._beginLine() + \"{\" + this._sep() +\n            this._key(this._builderOptions.convert.text) + this._sep() +\n            this._val(data) + this._sep() + \"}\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.instruction = function (target, data) {\n        // { \"?\": \"target hello\" }\n        return this._comma() + this._beginLine() + \"{\" + this._sep() +\n            this._key(this._builderOptions.convert.ins) + this._sep() +\n            this._val(data ? target + \" \" + data : target) + this._sep() + \"}\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.cdata = function (data) {\n        // { \"$\": \"hello\" }\n        return this._comma() + this._beginLine() + \"{\" + this._sep() +\n            this._key(this._builderOptions.convert.cdata) + this._sep() +\n            this._val(data) + this._sep() + \"}\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.attribute = function (name, value) {\n        // { \"@name\": \"val\" }\n        return this._comma() + this._beginLine(1) + \"{\" + this._sep() +\n            this._key(this._builderOptions.convert.att + name) + this._sep() +\n            this._val(value) + this._sep() + \"}\";\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.openTagBegin = function (name) {\n        // { \"node\": { \"#\": [\n        var str = this._comma() + this._beginLine() + \"{\" + this._sep() + this._key(name) + this._sep() + \"{\";\n        this._additionalLevel++;\n        this.hasData = true;\n        str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + \"[\";\n        this._hasChildren.push(false);\n        return str;\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {\n        if (selfClosing) {\n            var str = this._sep() + \"]\";\n            this._additionalLevel--;\n            str += this._beginLine() + \"}\" + this._sep() + \"}\";\n            return str;\n        }\n        else {\n            return \"\";\n        }\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.closeTag = function (name) {\n        // ] } }\n        var str = this._beginLine() + \"]\";\n        this._additionalLevel--;\n        str += this._beginLine() + \"}\" + this._sep() + \"}\";\n        return str;\n    };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.beginElement = function (name) { };\n    /** @inheritdoc */\n    JSONCBWriter.prototype.endElement = function (name) { this._hasChildren.pop(); };\n    /**\n     * Produces characters to be prepended to a line of string in pretty-print\n     * mode.\n     */\n    JSONCBWriter.prototype._beginLine = function (additionalOffset) {\n        if (additionalOffset === void 0) { additionalOffset = 0; }\n        if (this._writerOptions.prettyPrint) {\n            return (this.hasData ? this._writerOptions.newline : \"\") +\n                this._indent(this._writerOptions.offset + this.level + additionalOffset);\n        }\n        else {\n            return \"\";\n        }\n    };\n    /**\n     * Produces an indentation string.\n     *\n     * @param level - depth of the tree\n     */\n    JSONCBWriter.prototype._indent = function (level) {\n        if (level + this._additionalLevel <= 0) {\n            return \"\";\n        }\n        else {\n            return this._writerOptions.indent.repeat(level + this._additionalLevel);\n        }\n    };\n    /**\n     * Produces a comma before a child node if it has previous siblings.\n     */\n    JSONCBWriter.prototype._comma = function () {\n        var str = (this._hasChildren[this._hasChildren.length - 1] ? \",\" : \"\");\n        if (this._hasChildren.length > 0) {\n            this._hasChildren[this._hasChildren.length - 1] = true;\n        }\n        return str;\n    };\n    /**\n     * Produces a separator string.\n     */\n    JSONCBWriter.prototype._sep = function () {\n        return (this._writerOptions.prettyPrint ? \" \" : \"\");\n    };\n    /**\n     * Produces a JSON key string delimited with double quotes.\n     */\n    JSONCBWriter.prototype._key = function (key) {\n        return \"\\\"\" + key + \"\\\":\";\n    };\n    /**\n     * Produces a JSON value string delimited with double quotes.\n     */\n    JSONCBWriter.prototype._val = function (val) {\n        return JSON.stringify(val);\n    };\n    return JSONCBWriter;\n}(BaseCBWriter_1.BaseCBWriter));\nexports.JSONCBWriter = JSONCBWriter;\n//# sourceMappingURL=JSONCBWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ObjectWriter_1 = require(\"./ObjectWriter\");\nvar util_1 = require(\"@oozcitak/util\");\nvar BaseWriter_1 = require(\"./BaseWriter\");\n/**\n * Serializes XML nodes into a JSON string.\n */\nvar JSONWriter = /** @class */ (function (_super) {\n    __extends(JSONWriter, _super);\n    /**\n     * Initializes a new instance of `JSONWriter`.\n     *\n     * @param builderOptions - XML builder options\n     * @param writerOptions - serialization options\n     */\n    function JSONWriter(builderOptions, writerOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        // provide default options\n        _this._writerOptions = util_1.applyDefaults(writerOptions, {\n            wellFormed: false,\n            noDoubleEncoding: false,\n            prettyPrint: false,\n            indent: '  ',\n            newline: '\\n',\n            offset: 0,\n            group: false,\n            verbose: false\n        });\n        return _this;\n    }\n    /**\n     * Produces an XML serialization of the given node.\n     *\n     * @param node - node to serialize\n     * @param writerOptions - serialization options\n     */\n    JSONWriter.prototype.serialize = function (node) {\n        // convert to object\n        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {\n            format: \"object\",\n            wellFormed: false,\n            noDoubleEncoding: false,\n        });\n        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);\n        var val = objectWriter.serialize(node);\n        // recursively convert object into JSON string\n        return this._beginLine(this._writerOptions, 0) + this._convertObject(val, this._writerOptions);\n    };\n    /**\n     * Produces an XML serialization of the given object.\n     *\n     * @param obj - object to serialize\n     * @param options - serialization options\n     * @param level - depth of the XML tree\n     */\n    JSONWriter.prototype._convertObject = function (obj, options, level) {\n        var e_1, _a;\n        var _this = this;\n        if (level === void 0) { level = 0; }\n        var markup = '';\n        var isLeaf = this._isLeafNode(obj);\n        if (util_1.isArray(obj)) {\n            markup += '[';\n            var len = obj.length;\n            var i = 0;\n            try {\n                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {\n                    var val = obj_1_1.value;\n                    markup += this._endLine(options, level + 1) +\n                        this._beginLine(options, level + 1) +\n                        this._convertObject(val, options, level + 1);\n                    if (i < len - 1) {\n                        markup += ',';\n                    }\n                    i++;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            markup += this._endLine(options, level) + this._beginLine(options, level);\n            markup += ']';\n        }\n        else if (util_1.isObject(obj)) {\n            markup += '{';\n            var len_1 = util_1.objectLength(obj);\n            var i_1 = 0;\n            util_1.forEachObject(obj, function (key, val) {\n                if (isLeaf && options.prettyPrint) {\n                    markup += ' ';\n                }\n                else {\n                    markup += _this._endLine(options, level + 1) + _this._beginLine(options, level + 1);\n                }\n                markup += _this._key(key);\n                if (options.prettyPrint) {\n                    markup += ' ';\n                }\n                markup += _this._convertObject(val, options, level + 1);\n                if (i_1 < len_1 - 1) {\n                    markup += ',';\n                }\n                i_1++;\n            }, this);\n            if (isLeaf && options.prettyPrint) {\n                markup += ' ';\n            }\n            else {\n                markup += this._endLine(options, level) + this._beginLine(options, level);\n            }\n            markup += '}';\n        }\n        else {\n            markup += this._val(obj);\n        }\n        return markup;\n    };\n    /**\n     * Produces characters to be prepended to a line of string in pretty-print\n     * mode.\n     *\n     * @param options - serialization options\n     * @param level - current depth of the XML tree\n     */\n    JSONWriter.prototype._beginLine = function (options, level) {\n        if (!options.prettyPrint) {\n            return '';\n        }\n        else {\n            var indentLevel = options.offset + level + 1;\n            if (indentLevel > 0) {\n                return new Array(indentLevel).join(options.indent);\n            }\n        }\n        return '';\n    };\n    /**\n     * Produces characters to be appended to a line of string in pretty-print\n     * mode.\n     *\n     * @param options - serialization options\n     * @param level - current depth of the XML tree\n     */\n    JSONWriter.prototype._endLine = function (options, level) {\n        if (!options.prettyPrint) {\n            return '';\n        }\n        else {\n            return options.newline;\n        }\n    };\n    /**\n     * Produces a JSON key string delimited with double quotes.\n     */\n    JSONWriter.prototype._key = function (key) {\n        return \"\\\"\" + key + \"\\\":\";\n    };\n    /**\n     * Produces a JSON value string delimited with double quotes.\n     */\n    JSONWriter.prototype._val = function (val) {\n        return JSON.stringify(val);\n    };\n    /**\n     * Determines if an object is a leaf node.\n     *\n     * @param obj\n     */\n    JSONWriter.prototype._isLeafNode = function (obj) {\n        return this._descendantCount(obj) <= 1;\n    };\n    /**\n     * Counts the number of descendants of the given object.\n     *\n     * @param obj\n     * @param count\n     */\n    JSONWriter.prototype._descendantCount = function (obj, count) {\n        var _this = this;\n        if (count === void 0) { count = 0; }\n        if (util_1.isArray(obj)) {\n            util_1.forEachArray(obj, function (val) { return count += _this._descendantCount(val, count); }, this);\n        }\n        else if (util_1.isObject(obj)) {\n            util_1.forEachObject(obj, function (key, val) { return count += _this._descendantCount(val, count); }, this);\n        }\n        else {\n            count++;\n        }\n        return count;\n    };\n    return JSONWriter;\n}(BaseWriter_1.BaseWriter));\nexports.JSONWriter = JSONWriter;\n//# sourceMappingURL=JSONWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar ObjectWriter_1 = require(\"./ObjectWriter\");\nvar BaseWriter_1 = require(\"./BaseWriter\");\n/**\n * Serializes XML nodes into ES6 maps and arrays.\n */\nvar MapWriter = /** @class */ (function (_super) {\n    __extends(MapWriter, _super);\n    /**\n     * Initializes a new instance of `MapWriter`.\n     *\n     * @param builderOptions - XML builder options\n     * @param writerOptions - serialization options\n     */\n    function MapWriter(builderOptions, writerOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        // provide default options\n        _this._writerOptions = util_1.applyDefaults(writerOptions, {\n            format: \"map\",\n            wellFormed: false,\n            noDoubleEncoding: false,\n            group: false,\n            verbose: false\n        });\n        return _this;\n    }\n    /**\n     * Produces an XML serialization of the given node.\n     *\n     * @param node - node to serialize\n     */\n    MapWriter.prototype.serialize = function (node) {\n        // convert to object\n        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {\n            format: \"object\",\n            wellFormed: false,\n            noDoubleEncoding: false,\n            verbose: false\n        });\n        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);\n        var val = objectWriter.serialize(node);\n        // recursively convert object into Map\n        return this._convertObject(val);\n    };\n    /**\n     * Recursively converts a JS object into an ES5 map.\n     *\n     * @param obj - a JS object\n     */\n    MapWriter.prototype._convertObject = function (obj) {\n        if (util_1.isArray(obj)) {\n            for (var i = 0; i < obj.length; i++) {\n                obj[i] = this._convertObject(obj[i]);\n            }\n            return obj;\n        }\n        else if (util_1.isObject(obj)) {\n            var map = new Map();\n            for (var key in obj) {\n                map.set(key, this._convertObject(obj[key]));\n            }\n            return map;\n        }\n        else {\n            return obj;\n        }\n    };\n    return MapWriter;\n}(BaseWriter_1.BaseWriter));\nexports.MapWriter = MapWriter;\n//# sourceMappingURL=MapWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar interfaces_1 = require(\"@oozcitak/dom/lib/dom/interfaces\");\nvar BaseWriter_1 = require(\"./BaseWriter\");\n/**\n * Serializes XML nodes into objects and arrays.\n */\nvar ObjectWriter = /** @class */ (function (_super) {\n    __extends(ObjectWriter, _super);\n    /**\n     * Initializes a new instance of `ObjectWriter`.\n     *\n     * @param builderOptions - XML builder options\n     * @param writerOptions - serialization options\n     */\n    function ObjectWriter(builderOptions, writerOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        _this._writerOptions = util_1.applyDefaults(writerOptions, {\n            format: \"object\",\n            wellFormed: false,\n            noDoubleEncoding: false,\n            group: false,\n            verbose: false\n        });\n        return _this;\n    }\n    /**\n     * Produces an XML serialization of the given node.\n     *\n     * @param node - node to serialize\n     */\n    ObjectWriter.prototype.serialize = function (node) {\n        this._currentList = [];\n        this._currentIndex = 0;\n        this._listRegister = [this._currentList];\n        /**\n         * First pass, serialize nodes\n         * This creates a list of nodes grouped under node types while preserving\n         * insertion order. For example:\n         * [\n         *   root: [\n         *     node: [\n         *       { \"@\" : { \"att1\": \"val1\", \"att2\": \"val2\" }\n         *       { \"#\": \"node text\" }\n         *       { childNode: [] }\n         *       { \"#\": \"more text\" }\n         *     ],\n         *     node: [\n         *       { \"@\" : { \"att\": \"val\" }\n         *       { \"#\": [ \"text line1\", \"text line2\" ] }\n         *     ]\n         *   ]\n         * ]\n         */\n        this.serializeNode(node, this._writerOptions.wellFormed, this._writerOptions.noDoubleEncoding);\n        /**\n         * Second pass, process node lists. Above example becomes:\n         * {\n         *   root: {\n         *     node: [\n         *       {\n         *         \"@att1\": \"val1\",\n         *         \"@att2\": \"val2\",\n         *         \"#1\": \"node text\",\n         *         childNode: {},\n         *         \"#2\": \"more text\"\n         *       },\n         *       {\n         *         \"@att\": \"val\",\n         *         \"#\": [ \"text line1\", \"text line2\" ]\n         *       }\n         *     ]\n         *   }\n         * }\n         */\n        return this._process(this._currentList, this._writerOptions);\n    };\n    ObjectWriter.prototype._process = function (items, options) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (items.length === 0)\n            return {};\n        // determine if there are non-unique element names\n        var namesSeen = {};\n        var hasNonUniqueNames = false;\n        var textCount = 0;\n        var commentCount = 0;\n        var instructionCount = 0;\n        var cdataCount = 0;\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            var key = Object.keys(item)[0];\n            switch (key) {\n                case \"@\":\n                    continue;\n                case \"#\":\n                    textCount++;\n                    break;\n                case \"!\":\n                    commentCount++;\n                    break;\n                case \"?\":\n                    instructionCount++;\n                    break;\n                case \"$\":\n                    cdataCount++;\n                    break;\n                default:\n                    if (namesSeen[key]) {\n                        hasNonUniqueNames = true;\n                    }\n                    else {\n                        namesSeen[key] = true;\n                    }\n                    break;\n            }\n        }\n        var defAttrKey = this._getAttrKey();\n        var defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);\n        var defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);\n        var defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);\n        var defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);\n        if (textCount === 1 && items.length === 1 && util_1.isString(items[0][\"#\"])) {\n            // special case of an element node with a single text node\n            return items[0][\"#\"];\n        }\n        else if (hasNonUniqueNames) {\n            var obj = {};\n            // process attributes first\n            for (var i = 0; i < items.length; i++) {\n                var item = items[i];\n                var key = Object.keys(item)[0];\n                if (key === \"@\") {\n                    var attrs = item[\"@\"];\n                    var attrKeys = Object.keys(attrs);\n                    if (attrKeys.length === 1) {\n                        obj[defAttrKey + attrKeys[0]] = attrs[attrKeys[0]];\n                    }\n                    else {\n                        obj[defAttrKey] = item[\"@\"];\n                    }\n                }\n            }\n            // list contains element nodes with non-unique names\n            // return an array with mixed content notation\n            var result = [];\n            for (var i = 0; i < items.length; i++) {\n                var item = items[i];\n                var key = Object.keys(item)[0];\n                switch (key) {\n                    case \"@\":\n                        // attributes were processed above\n                        break;\n                    case \"#\":\n                        result.push((_a = {}, _a[defTextKey] = item[\"#\"], _a));\n                        break;\n                    case \"!\":\n                        result.push((_b = {}, _b[defCommentKey] = item[\"!\"], _b));\n                        break;\n                    case \"?\":\n                        result.push((_c = {}, _c[defInstructionKey] = item[\"?\"], _c));\n                        break;\n                    case \"$\":\n                        result.push((_d = {}, _d[defCdataKey] = item[\"$\"], _d));\n                        break;\n                    default:\n                        // element node\n                        var ele = item;\n                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {\n                            // group of element nodes\n                            var eleGroup = [];\n                            var listOfLists = ele[key];\n                            for (var i_1 = 0; i_1 < listOfLists.length; i_1++) {\n                                eleGroup.push(this._process(listOfLists[i_1], options));\n                            }\n                            result.push((_e = {}, _e[key] = eleGroup, _e));\n                        }\n                        else {\n                            // single element node\n                            if (options.verbose) {\n                                result.push((_f = {}, _f[key] = [this._process(ele[key], options)], _f));\n                            }\n                            else {\n                                result.push((_g = {}, _g[key] = this._process(ele[key], options), _g));\n                            }\n                        }\n                        break;\n                }\n            }\n            obj[defTextKey] = result;\n            return obj;\n        }\n        else {\n            // all element nodes have unique names\n            // return an object while prefixing data node keys\n            var textId = 1;\n            var commentId = 1;\n            var instructionId = 1;\n            var cdataId = 1;\n            var obj = {};\n            for (var i = 0; i < items.length; i++) {\n                var item = items[i];\n                var key = Object.keys(item)[0];\n                switch (key) {\n                    case \"@\":\n                        var attrs = item[\"@\"];\n                        var attrKeys = Object.keys(attrs);\n                        if (!options.group || attrKeys.length === 1) {\n                            for (var attrName in attrs) {\n                                obj[defAttrKey + attrName] = attrs[attrName];\n                            }\n                        }\n                        else {\n                            obj[defAttrKey] = attrs;\n                        }\n                        break;\n                    case \"#\":\n                        textId = this._processSpecItem(item[\"#\"], obj, options.group, defTextKey, textCount, textId);\n                        break;\n                    case \"!\":\n                        commentId = this._processSpecItem(item[\"!\"], obj, options.group, defCommentKey, commentCount, commentId);\n                        break;\n                    case \"?\":\n                        instructionId = this._processSpecItem(item[\"?\"], obj, options.group, defInstructionKey, instructionCount, instructionId);\n                        break;\n                    case \"$\":\n                        cdataId = this._processSpecItem(item[\"$\"], obj, options.group, defCdataKey, cdataCount, cdataId);\n                        break;\n                    default:\n                        // element node\n                        var ele = item;\n                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {\n                            // group of element nodes\n                            var eleGroup = [];\n                            var listOfLists = ele[key];\n                            for (var i_2 = 0; i_2 < listOfLists.length; i_2++) {\n                                eleGroup.push(this._process(listOfLists[i_2], options));\n                            }\n                            obj[key] = eleGroup;\n                        }\n                        else {\n                            // single element node\n                            if (options.verbose) {\n                                obj[key] = [this._process(ele[key], options)];\n                            }\n                            else {\n                                obj[key] = this._process(ele[key], options);\n                            }\n                        }\n                        break;\n                }\n            }\n            return obj;\n        }\n    };\n    ObjectWriter.prototype._processSpecItem = function (item, obj, group, defKey, count, id) {\n        var e_1, _a;\n        if (!group && util_1.isArray(item) && count + item.length > 2) {\n            try {\n                for (var item_1 = __values(item), item_1_1 = item_1.next(); !item_1_1.done; item_1_1 = item_1.next()) {\n                    var subItem = item_1_1.value;\n                    var key = defKey + (id++).toString();\n                    obj[key] = subItem;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (item_1_1 && !item_1_1.done && (_a = item_1.return)) _a.call(item_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        else {\n            var key = count > 1 ? defKey + (id++).toString() : defKey;\n            obj[key] = item;\n        }\n        return id;\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.beginElement = function (name) {\n        var _a, _b;\n        var childItems = [];\n        if (this._currentList.length === 0) {\n            this._currentList.push((_a = {}, _a[name] = childItems, _a));\n        }\n        else {\n            var lastItem = this._currentList[this._currentList.length - 1];\n            if (this._isElementNode(lastItem, name)) {\n                if (lastItem[name].length !== 0 && util_1.isArray(lastItem[name][0])) {\n                    var listOfLists = lastItem[name];\n                    listOfLists.push(childItems);\n                }\n                else {\n                    lastItem[name] = [lastItem[name], childItems];\n                }\n            }\n            else {\n                this._currentList.push((_b = {}, _b[name] = childItems, _b));\n            }\n        }\n        this._currentIndex++;\n        if (this._listRegister.length > this._currentIndex) {\n            this._listRegister[this._currentIndex] = childItems;\n        }\n        else {\n            this._listRegister.push(childItems);\n        }\n        this._currentList = childItems;\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.endElement = function () {\n        this._currentList = this._listRegister[--this._currentIndex];\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.attribute = function (name, value) {\n        var _a, _b;\n        if (this._currentList.length === 0) {\n            this._currentList.push({ \"@\": (_a = {}, _a[name] = value, _a) });\n        }\n        else {\n            var lastItem = this._currentList[this._currentList.length - 1];\n            /* istanbul ignore else */\n            if (this._isAttrNode(lastItem)) {\n                lastItem[\"@\"][name] = value;\n            }\n            else {\n                this._currentList.push({ \"@\": (_b = {}, _b[name] = value, _b) });\n            }\n        }\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.comment = function (data) {\n        if (this._currentList.length === 0) {\n            this._currentList.push({ \"!\": data });\n        }\n        else {\n            var lastItem = this._currentList[this._currentList.length - 1];\n            if (this._isCommentNode(lastItem)) {\n                if (util_1.isArray(lastItem[\"!\"])) {\n                    lastItem[\"!\"].push(data);\n                }\n                else {\n                    lastItem[\"!\"] = [lastItem[\"!\"], data];\n                }\n            }\n            else {\n                this._currentList.push({ \"!\": data });\n            }\n        }\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.text = function (data) {\n        if (this._currentList.length === 0) {\n            this._currentList.push({ \"#\": data });\n        }\n        else {\n            var lastItem = this._currentList[this._currentList.length - 1];\n            if (this._isTextNode(lastItem)) {\n                if (util_1.isArray(lastItem[\"#\"])) {\n                    lastItem[\"#\"].push(data);\n                }\n                else {\n                    lastItem[\"#\"] = [lastItem[\"#\"], data];\n                }\n            }\n            else {\n                this._currentList.push({ \"#\": data });\n            }\n        }\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.instruction = function (target, data) {\n        var value = (data === \"\" ? target : target + \" \" + data);\n        if (this._currentList.length === 0) {\n            this._currentList.push({ \"?\": value });\n        }\n        else {\n            var lastItem = this._currentList[this._currentList.length - 1];\n            if (this._isInstructionNode(lastItem)) {\n                if (util_1.isArray(lastItem[\"?\"])) {\n                    lastItem[\"?\"].push(value);\n                }\n                else {\n                    lastItem[\"?\"] = [lastItem[\"?\"], value];\n                }\n            }\n            else {\n                this._currentList.push({ \"?\": value });\n            }\n        }\n    };\n    /** @inheritdoc */\n    ObjectWriter.prototype.cdata = function (data) {\n        if (this._currentList.length === 0) {\n            this._currentList.push({ \"$\": data });\n        }\n        else {\n            var lastItem = this._currentList[this._currentList.length - 1];\n            if (this._isCDATANode(lastItem)) {\n                if (util_1.isArray(lastItem[\"$\"])) {\n                    lastItem[\"$\"].push(data);\n                }\n                else {\n                    lastItem[\"$\"] = [lastItem[\"$\"], data];\n                }\n            }\n            else {\n                this._currentList.push({ \"$\": data });\n            }\n        }\n    };\n    ObjectWriter.prototype._isAttrNode = function (x) {\n        return \"@\" in x;\n    };\n    ObjectWriter.prototype._isTextNode = function (x) {\n        return \"#\" in x;\n    };\n    ObjectWriter.prototype._isCommentNode = function (x) {\n        return \"!\" in x;\n    };\n    ObjectWriter.prototype._isInstructionNode = function (x) {\n        return \"?\" in x;\n    };\n    ObjectWriter.prototype._isCDATANode = function (x) {\n        return \"$\" in x;\n    };\n    ObjectWriter.prototype._isElementNode = function (x, name) {\n        return name in x;\n    };\n    /**\n     * Returns an object key for an attribute or namespace declaration.\n     */\n    ObjectWriter.prototype._getAttrKey = function () {\n        return this._builderOptions.convert.att;\n    };\n    /**\n     * Returns an object key for the given node type.\n     *\n     * @param nodeType - node type to get a key for\n     */\n    ObjectWriter.prototype._getNodeKey = function (nodeType) {\n        switch (nodeType) {\n            case interfaces_1.NodeType.Comment:\n                return this._builderOptions.convert.comment;\n            case interfaces_1.NodeType.Text:\n                return this._builderOptions.convert.text;\n            case interfaces_1.NodeType.ProcessingInstruction:\n                return this._builderOptions.convert.ins;\n            case interfaces_1.NodeType.CData:\n                return this._builderOptions.convert.cdata;\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"Invalid node type.\");\n        }\n    };\n    return ObjectWriter;\n}(BaseWriter_1.BaseWriter));\nexports.ObjectWriter = ObjectWriter;\n//# sourceMappingURL=ObjectWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseCBWriter_1 = require(\"./BaseCBWriter\");\n/**\n * Serializes XML nodes.\n */\nvar XMLCBWriter = /** @class */ (function (_super) {\n    __extends(XMLCBWriter, _super);\n    /**\n     * Initializes a new instance of `XMLCBWriter`.\n     *\n     * @param builderOptions - XML builder options\n     */\n    function XMLCBWriter(builderOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        _this._lineLength = 0;\n        return _this;\n    }\n    /** @inheritdoc */\n    XMLCBWriter.prototype.frontMatter = function () {\n        return \"\";\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.declaration = function (version, encoding, standalone) {\n        var markup = this._beginLine() + \"<?xml\";\n        markup += \" version=\\\"\" + version + \"\\\"\";\n        if (encoding !== undefined) {\n            markup += \" encoding=\\\"\" + encoding + \"\\\"\";\n        }\n        if (standalone !== undefined) {\n            markup += \" standalone=\\\"\" + (standalone ? \"yes\" : \"no\") + \"\\\"\";\n        }\n        markup += \"?>\";\n        return markup;\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.docType = function (name, publicId, systemId) {\n        var markup = this._beginLine();\n        if (publicId && systemId) {\n            markup += \"<!DOCTYPE \" + name + \" PUBLIC \\\"\" + publicId + \"\\\" \\\"\" + systemId + \"\\\">\";\n        }\n        else if (publicId) {\n            markup += \"<!DOCTYPE \" + name + \" PUBLIC \\\"\" + publicId + \"\\\">\";\n        }\n        else if (systemId) {\n            markup += \"<!DOCTYPE \" + name + \" SYSTEM \\\"\" + systemId + \"\\\">\";\n        }\n        else {\n            markup += \"<!DOCTYPE \" + name + \">\";\n        }\n        return markup;\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.comment = function (data) {\n        return this._beginLine() + \"<!--\" + data + \"-->\";\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.text = function (data) {\n        return this._beginLine() + data;\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.instruction = function (target, data) {\n        if (data) {\n            return this._beginLine() + \"<?\" + target + \" \" + data + \"?>\";\n        }\n        else {\n            return this._beginLine() + \"<?\" + target + \"?>\";\n        }\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.cdata = function (data) {\n        return this._beginLine() + \"<![CDATA[\" + data + \"]]>\";\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.openTagBegin = function (name) {\n        this._lineLength += 1 + name.length;\n        return this._beginLine() + \"<\" + name;\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {\n        if (voidElement) {\n            return \" />\";\n        }\n        else if (selfClosing) {\n            if (this._writerOptions.allowEmptyTags) {\n                return \"></\" + name + \">\";\n            }\n            else if (this._writerOptions.spaceBeforeSlash) {\n                return \" />\";\n            }\n            else {\n                return \"/>\";\n            }\n        }\n        else {\n            return \">\";\n        }\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.closeTag = function (name) {\n        return this._beginLine() + \"</\" + name + \">\";\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.attribute = function (name, value) {\n        var str = name + \"=\\\"\" + value + \"\\\"\";\n        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 &&\n            this._lineLength + 1 + str.length > this._writerOptions.width) {\n            str = this._beginLine() + this._indent(1) + str;\n            this._lineLength = str.length;\n            return str;\n        }\n        else {\n            this._lineLength += 1 + str.length;\n            return \" \" + str;\n        }\n    };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.beginElement = function (name) { };\n    /** @inheritdoc */\n    XMLCBWriter.prototype.endElement = function (name) { };\n    /**\n     * Produces characters to be prepended to a line of string in pretty-print\n     * mode.\n     */\n    XMLCBWriter.prototype._beginLine = function () {\n        if (this._writerOptions.prettyPrint) {\n            var str = (this.hasData ? this._writerOptions.newline : \"\") +\n                this._indent(this._writerOptions.offset + this.level);\n            this._lineLength = str.length;\n            return str;\n        }\n        else {\n            return \"\";\n        }\n    };\n    /**\n     * Produces an indentation string.\n     *\n     * @param level - depth of the tree\n     */\n    XMLCBWriter.prototype._indent = function (level) {\n        if (level <= 0) {\n            return \"\";\n        }\n        else {\n            return this._writerOptions.indent.repeat(level);\n        }\n    };\n    return XMLCBWriter;\n}(BaseCBWriter_1.BaseCBWriter));\nexports.XMLCBWriter = XMLCBWriter;\n//# sourceMappingURL=XMLCBWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@oozcitak/util\");\nvar interfaces_1 = require(\"@oozcitak/dom/lib/dom/interfaces\");\nvar BaseWriter_1 = require(\"./BaseWriter\");\nvar util_2 = require(\"@oozcitak/dom/lib/util\");\n/**\n * Serializes XML nodes into strings.\n */\nvar XMLWriter = /** @class */ (function (_super) {\n    __extends(XMLWriter, _super);\n    /**\n     * Initializes a new instance of `XMLWriter`.\n     *\n     * @param builderOptions - XML builder options\n     * @param writerOptions - serialization options\n     */\n    function XMLWriter(builderOptions, writerOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        _this._indentation = {};\n        _this._lengthToLastNewline = 0;\n        // provide default options\n        _this._writerOptions = util_1.applyDefaults(writerOptions, {\n            wellFormed: false,\n            noDoubleEncoding: false,\n            headless: false,\n            prettyPrint: false,\n            indent: \"  \",\n            newline: \"\\n\",\n            offset: 0,\n            width: 0,\n            allowEmptyTags: false,\n            indentTextOnlyNodes: false,\n            spaceBeforeSlash: false\n        });\n        return _this;\n    }\n    /**\n     * Produces an XML serialization of the given node.\n     *\n     * @param node - node to serialize\n     */\n    XMLWriter.prototype.serialize = function (node) {\n        this._refs = { suppressPretty: false, emptyNode: false, markup: \"\" };\n        // Serialize XML declaration\n        if (node.nodeType === interfaces_1.NodeType.Document && !this._writerOptions.headless) {\n            this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone);\n        }\n        // recursively serialize node\n        this.serializeNode(node, this._writerOptions.wellFormed, this._writerOptions.noDoubleEncoding);\n        // remove trailing newline\n        if (this._writerOptions.prettyPrint &&\n            this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {\n            this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length);\n        }\n        return this._refs.markup;\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.declaration = function (version, encoding, standalone) {\n        this._beginLine();\n        this._refs.markup += \"<?xml version=\\\"\" + version + \"\\\"\";\n        if (encoding !== undefined) {\n            this._refs.markup += \" encoding=\\\"\" + encoding + \"\\\"\";\n        }\n        if (standalone !== undefined) {\n            this._refs.markup += \" standalone=\\\"\" + (standalone ? \"yes\" : \"no\") + \"\\\"\";\n        }\n        this._refs.markup += \"?>\";\n        this._endLine();\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.docType = function (name, publicId, systemId) {\n        this._beginLine();\n        if (publicId && systemId) {\n            this._refs.markup += \"<!DOCTYPE \" + name + \" PUBLIC \\\"\" + publicId + \"\\\" \\\"\" + systemId + \"\\\">\";\n        }\n        else if (publicId) {\n            this._refs.markup += \"<!DOCTYPE \" + name + \" PUBLIC \\\"\" + publicId + \"\\\">\";\n        }\n        else if (systemId) {\n            this._refs.markup += \"<!DOCTYPE \" + name + \" SYSTEM \\\"\" + systemId + \"\\\">\";\n        }\n        else {\n            this._refs.markup += \"<!DOCTYPE \" + name + \">\";\n        }\n        this._endLine();\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.openTagBegin = function (name) {\n        this._beginLine();\n        this._refs.markup += \"<\" + name;\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {\n        // do not indent text only elements or elements with empty text nodes\n        this._refs.suppressPretty = false;\n        this._refs.emptyNode = false;\n        if (this._writerOptions.prettyPrint && !selfClosing && !voidElement) {\n            var textOnlyNode = true;\n            var emptyNode = true;\n            var childNode = this.currentNode.firstChild;\n            var cdataCount = 0;\n            var textCount = 0;\n            while (childNode) {\n                if (util_2.Guard.isExclusiveTextNode(childNode)) {\n                    textCount++;\n                }\n                else if (util_2.Guard.isCDATASectionNode(childNode)) {\n                    cdataCount++;\n                }\n                else {\n                    textOnlyNode = false;\n                    emptyNode = false;\n                    break;\n                }\n                if (childNode.data !== '') {\n                    emptyNode = false;\n                }\n                childNode = childNode.nextSibling;\n            }\n            this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && textOnlyNode && ((cdataCount <= 1 && textCount === 0) || cdataCount === 0);\n            this._refs.emptyNode = emptyNode;\n        }\n        if ((voidElement || selfClosing || this._refs.emptyNode) && this._writerOptions.allowEmptyTags) {\n            this._refs.markup += \"></\" + name + \">\";\n        }\n        else {\n            this._refs.markup += voidElement ? \" />\" :\n                (selfClosing || this._refs.emptyNode) ? (this._writerOptions.spaceBeforeSlash ? \" />\" : \"/>\") : \">\";\n        }\n        this._endLine();\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.closeTag = function (name) {\n        if (!this._refs.emptyNode) {\n            this._beginLine();\n            this._refs.markup += \"</\" + name + \">\";\n        }\n        this._refs.suppressPretty = false;\n        this._refs.emptyNode = false;\n        this._endLine();\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.attribute = function (name, value) {\n        var str = name + \"=\\\"\" + value + \"\\\"\";\n        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 &&\n            this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._writerOptions.width) {\n            this._endLine();\n            this._beginLine();\n            this._refs.markup += this._indent(1) + str;\n        }\n        else {\n            this._refs.markup += \" \" + str;\n        }\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.text = function (data) {\n        if (data !== '') {\n            this._beginLine();\n            this._refs.markup += data;\n            this._endLine();\n        }\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.cdata = function (data) {\n        if (data !== '') {\n            this._beginLine();\n            this._refs.markup += \"<![CDATA[\" + data + \"]]>\";\n            this._endLine();\n        }\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.comment = function (data) {\n        this._beginLine();\n        this._refs.markup += \"<!--\" + data + \"-->\";\n        this._endLine();\n    };\n    /** @inheritdoc */\n    XMLWriter.prototype.instruction = function (target, data) {\n        this._beginLine();\n        this._refs.markup += \"<?\" + (data === \"\" ? target : target + \" \" + data) + \"?>\";\n        this._endLine();\n    };\n    /**\n     * Produces characters to be prepended to a line of string in pretty-print\n     * mode.\n     */\n    XMLWriter.prototype._beginLine = function () {\n        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {\n            this._refs.markup += this._indent(this._writerOptions.offset + this.level);\n        }\n    };\n    /**\n     * Produces characters to be appended to a line of string in pretty-print\n     * mode.\n     */\n    XMLWriter.prototype._endLine = function () {\n        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {\n            this._refs.markup += this._writerOptions.newline;\n            this._lengthToLastNewline = this._refs.markup.length;\n        }\n    };\n    /**\n     * Produces an indentation string.\n     *\n     * @param level - depth of the tree\n     */\n    XMLWriter.prototype._indent = function (level) {\n        if (level <= 0) {\n            return \"\";\n        }\n        else if (this._indentation[level] !== undefined) {\n            return this._indentation[level];\n        }\n        else {\n            var str = this._writerOptions.indent.repeat(level);\n            this._indentation[level] = str;\n            return str;\n        }\n    };\n    return XMLWriter;\n}(BaseWriter_1.BaseWriter));\nexports.XMLWriter = XMLWriter;\n//# sourceMappingURL=XMLWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BaseCBWriter_1 = require(\"./BaseCBWriter\");\n/**\n * Serializes XML nodes.\n */\nvar YAMLCBWriter = /** @class */ (function (_super) {\n    __extends(YAMLCBWriter, _super);\n    /**\n     * Initializes a new instance of `BaseCBWriter`.\n     *\n     * @param builderOptions - XML builder options\n     */\n    function YAMLCBWriter(builderOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        _this._rootWritten = false;\n        _this._additionalLevel = 0;\n        if (builderOptions.indent.length < 2) {\n            throw new Error(\"YAML indententation string must be at least two characters long.\");\n        }\n        if (builderOptions.offset < 0) {\n            throw new Error(\"YAML offset should be zero or a positive number.\");\n        }\n        return _this;\n    }\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.frontMatter = function () {\n        return this._beginLine() + \"---\";\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.declaration = function (version, encoding, standalone) {\n        return \"\";\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.docType = function (name, publicId, systemId) {\n        return \"\";\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.comment = function (data) {\n        // \"!\": \"hello\"\n        return this._beginLine() +\n            this._key(this._builderOptions.convert.comment) + \" \" +\n            this._val(data);\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.text = function (data) {\n        // \"#\": \"hello\"\n        return this._beginLine() +\n            this._key(this._builderOptions.convert.text) + \" \" +\n            this._val(data);\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.instruction = function (target, data) {\n        // \"?\": \"target hello\"\n        return this._beginLine() +\n            this._key(this._builderOptions.convert.ins) + \" \" +\n            this._val(data ? target + \" \" + data : target);\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.cdata = function (data) {\n        // \"$\": \"hello\"\n        return this._beginLine() +\n            this._key(this._builderOptions.convert.cdata) + \" \" +\n            this._val(data);\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.attribute = function (name, value) {\n        // \"@name\": \"val\"\n        this._additionalLevel++;\n        var str = this._beginLine() +\n            this._key(this._builderOptions.convert.att + name) + \" \" +\n            this._val(value);\n        this._additionalLevel--;\n        return str;\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.openTagBegin = function (name) {\n        // \"node\":\n        //   \"#\":\n        //   -\n        var str = this._beginLine() + this._key(name);\n        if (!this._rootWritten) {\n            this._rootWritten = true;\n        }\n        this.hasData = true;\n        this._additionalLevel++;\n        str += this._beginLine(true) + this._key(this._builderOptions.convert.text);\n        return str;\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {\n        if (selfClosing) {\n            return \" \" + this._val(\"\");\n        }\n        return \"\";\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.closeTag = function (name) {\n        this._additionalLevel--;\n        return \"\";\n    };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.beginElement = function (name) { };\n    /** @inheritdoc */\n    YAMLCBWriter.prototype.endElement = function (name) { };\n    /**\n     * Produces characters to be prepended to a line of string in pretty-print\n     * mode.\n     */\n    YAMLCBWriter.prototype._beginLine = function (suppressArray) {\n        if (suppressArray === void 0) { suppressArray = false; }\n        return (this.hasData ? this._writerOptions.newline : \"\") +\n            this._indent(this._writerOptions.offset + this.level, suppressArray);\n    };\n    /**\n     * Produces an indentation string.\n     *\n     * @param level - depth of the tree\n     * @param suppressArray - whether the suppress array marker\n     */\n    YAMLCBWriter.prototype._indent = function (level, suppressArray) {\n        if (level + this._additionalLevel <= 0) {\n            return \"\";\n        }\n        else {\n            var chars = this._writerOptions.indent.repeat(level + this._additionalLevel);\n            if (!suppressArray && this._rootWritten) {\n                return chars.substr(0, chars.length - 2) + '-' + chars.substr(-1, 1);\n            }\n            return chars;\n        }\n    };\n    /**\n     * Produces a YAML key string delimited with double quotes.\n     */\n    YAMLCBWriter.prototype._key = function (key) {\n        return \"\\\"\" + key + \"\\\":\";\n    };\n    /**\n     * Produces a YAML value string delimited with double quotes.\n     */\n    YAMLCBWriter.prototype._val = function (val) {\n        return JSON.stringify(val);\n    };\n    return YAMLCBWriter;\n}(BaseCBWriter_1.BaseCBWriter));\nexports.YAMLCBWriter = YAMLCBWriter;\n//# sourceMappingURL=YAMLCBWriter.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ObjectWriter_1 = require(\"./ObjectWriter\");\nvar util_1 = require(\"@oozcitak/util\");\nvar BaseWriter_1 = require(\"./BaseWriter\");\n/**\n * Serializes XML nodes into a YAML string.\n */\nvar YAMLWriter = /** @class */ (function (_super) {\n    __extends(YAMLWriter, _super);\n    /**\n     * Initializes a new instance of `YAMLWriter`.\n     *\n     * @param builderOptions - XML builder options\n     * @param writerOptions - serialization options\n     */\n    function YAMLWriter(builderOptions, writerOptions) {\n        var _this = _super.call(this, builderOptions) || this;\n        // provide default options\n        _this._writerOptions = util_1.applyDefaults(writerOptions, {\n            wellFormed: false,\n            noDoubleEncoding: false,\n            indent: '  ',\n            newline: '\\n',\n            offset: 0,\n            group: false,\n            verbose: false\n        });\n        if (_this._writerOptions.indent.length < 2) {\n            throw new Error(\"YAML indententation string must be at least two characters long.\");\n        }\n        if (_this._writerOptions.offset < 0) {\n            throw new Error(\"YAML offset should be zero or a positive number.\");\n        }\n        return _this;\n    }\n    /**\n     * Produces an XML serialization of the given node.\n     *\n     * @param node - node to serialize\n     * @param writerOptions - serialization options\n     */\n    YAMLWriter.prototype.serialize = function (node) {\n        // convert to object\n        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {\n            format: \"object\",\n            wellFormed: false,\n            noDoubleEncoding: false,\n        });\n        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);\n        var val = objectWriter.serialize(node);\n        var markup = this._beginLine(this._writerOptions, 0) + '---' + this._endLine(this._writerOptions) +\n            this._convertObject(val, this._writerOptions, 0);\n        // remove trailing newline\n        /* istanbul ignore else */\n        if (markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {\n            markup = markup.slice(0, -this._writerOptions.newline.length);\n        }\n        return markup;\n    };\n    /**\n     * Produces an XML serialization of the given object.\n     *\n     * @param obj - object to serialize\n     * @param options - serialization options\n     * @param level - depth of the XML tree\n     * @param indentLeaf - indents leaf nodes\n     */\n    YAMLWriter.prototype._convertObject = function (obj, options, level, suppressIndent) {\n        var e_1, _a;\n        var _this = this;\n        if (suppressIndent === void 0) { suppressIndent = false; }\n        var markup = '';\n        if (util_1.isArray(obj)) {\n            try {\n                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {\n                    var val = obj_1_1.value;\n                    markup += this._beginLine(options, level, true);\n                    if (!util_1.isObject(val)) {\n                        markup += this._val(val) + this._endLine(options);\n                    }\n                    else if (util_1.isEmpty(val)) {\n                        markup += '\"\"' + this._endLine(options);\n                    }\n                    else {\n                        markup += this._convertObject(val, options, level, true);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        else /* if (isObject(obj)) */ {\n            util_1.forEachObject(obj, function (key, val) {\n                if (suppressIndent) {\n                    markup += _this._key(key);\n                    suppressIndent = false;\n                }\n                else {\n                    markup += _this._beginLine(options, level) + _this._key(key);\n                }\n                if (!util_1.isObject(val)) {\n                    markup += ' ' + _this._val(val) + _this._endLine(options);\n                }\n                else if (util_1.isEmpty(val)) {\n                    markup += ' \"\"' + _this._endLine(options);\n                }\n                else {\n                    markup += _this._endLine(options) +\n                        _this._convertObject(val, options, level + 1);\n                }\n            }, this);\n        }\n        return markup;\n    };\n    /**\n     * Produces characters to be prepended to a line of string in pretty-print\n     * mode.\n     *\n     * @param options - serialization options\n     * @param level - current depth of the XML tree\n     * @param isArray - whether this line is an array item\n     */\n    YAMLWriter.prototype._beginLine = function (options, level, isArray) {\n        if (isArray === void 0) { isArray = false; }\n        var indentLevel = options.offset + level + 1;\n        var chars = new Array(indentLevel).join(options.indent);\n        if (isArray) {\n            return chars.substr(0, chars.length - 2) + '-' + chars.substr(-1, 1);\n        }\n        else {\n            return chars;\n        }\n    };\n    /**\n     * Produces characters to be appended to a line of string in pretty-print\n     * mode.\n     *\n     * @param options - serialization options\n     */\n    YAMLWriter.prototype._endLine = function (options) {\n        return options.newline;\n    };\n    /**\n     * Produces a YAML key string delimited with double quotes.\n     */\n    YAMLWriter.prototype._key = function (key) {\n        return \"\\\"\" + key + \"\\\":\";\n    };\n    /**\n     * Produces a YAML value string delimited with double quotes.\n     */\n    YAMLWriter.prototype._val = function (val) {\n        return JSON.stringify(val);\n    };\n    return YAMLWriter;\n}(BaseWriter_1.BaseWriter));\nexports.YAMLWriter = YAMLWriter;\n//# sourceMappingURL=YAMLWriter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MapWriter_1 = require(\"./MapWriter\");\nexports.MapWriter = MapWriter_1.MapWriter;\nvar XMLWriter_1 = require(\"./XMLWriter\");\nexports.XMLWriter = XMLWriter_1.XMLWriter;\nvar ObjectWriter_1 = require(\"./ObjectWriter\");\nexports.ObjectWriter = ObjectWriter_1.ObjectWriter;\nvar JSONWriter_1 = require(\"./JSONWriter\");\nexports.JSONWriter = JSONWriter_1.JSONWriter;\nvar YAMLWriter_1 = require(\"./YAMLWriter\");\nexports.YAMLWriter = YAMLWriter_1.YAMLWriter;\n//# sourceMappingURL=index.js.map","'use strict';\n\n\nvar yaml = require('./lib/js-yaml.js');\n\n\nmodule.exports = yaml;\n","'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecated schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c)\n    // byte-order-mark\n    && c !== 0xFEFF\n    // b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    // /* An ns-char preceding */ \"#\"\n    && c !== CHAR_COLON\n    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    _pos = state.position;\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!state.anchorMap.hasOwnProperty(alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n","'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) return null;\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n","// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n","// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n",null,"'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n    return hasDigits && ch !== '_';\n  }\n\n  // base 10 (except 0) or base 60\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  // if !base60 - done;\n  if (ch !== ':') return true;\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n",null,"'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n\n    if (modifiers.length > 3) return false;\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n","'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar Schema = require('./Schema-88e323a7.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: Object.create(null),\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n","'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar warnings = require('./warnings-1000a372.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify$2(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve$1(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify$1(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve$1(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify$2(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve$1(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify$1(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve(sign, bin, 2),\n  stringify: node => intStringify(node, 2, '0b')\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve(sign, oct, 8),\n  stringify: node => intStringify(node, 8, '0')\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve(sign, hex, 16),\n  stringify: node => intStringify(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (!value || typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {\n    value: undefined,\n    node: undefined\n  };\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n","'use strict';\n\nvar parseCst = require('./parse-cst.js');\nvar Document$1 = require('./Document-9b4560a1.js');\nvar Schema = require('./Schema-88e323a7.js');\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar warnings = require('./warnings-1000a372.js');\nrequire('./resolveSeq-d03cb037.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        let inEnd = offset;\n        let lineStart;\n\n        do {\n          lineStart = inEnd + 1;\n          inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        } while (src[inEnd] === '\\n');\n\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (src[inEnd] !== '#' && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      const a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      const o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      const value = toJSON(this.value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = value;\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (!explicitKey && str.length > 1024) {\n      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n      explicitKey = true;\n    }\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow && !explicitKey ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    } else if (valueStr[0] === '\\n') ws = '';\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n          Object.defineProperty(map, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, end)}`;\n    }\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  const limit = lineWidth - indentLength;\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n","module.exports = require('./dist').YAML\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"url\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(7661);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACl+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACppCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACp1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC13BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/fA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACt8CA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACldA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrsFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACx0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACneA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACj1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3mDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC5DA;AACA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC5KA;AACA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACpvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC32BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC5gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC/ZA;;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;;;;A","sourceRoot":""}